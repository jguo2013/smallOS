
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 57 f1 00 00       	call   80f188 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
	...

00800040 <put_buffer>:

	return va;
}

static void
put_buffer(void *va) {
  800040:	55                   	push   %ebp
  800041:	89 e5                	mov    %esp,%ebp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  800043:	2d 00 b0 fe 0f       	sub    $0xffeb000,%eax
  800048:	c1 e8 0c             	shr    $0xc,%eax
  80004b:	c6 80 30 50 81 00 00 	movb   $0x0,0x815030(%eax)
}
  800052:	5d                   	pop    %ebp
  800053:	c3                   	ret    

00800054 <umain>:
	serve();
}

void
umain(int argc, char **argv)
{
  800054:	55                   	push   %ebp
  800055:	89 e5                	mov    %esp,%ebp
  800057:	53                   	push   %ebx
  800058:	83 ec 14             	sub    $0x14,%esp
	envid_t ns_envid = sys_getenvid();
  80005b:	e8 81 00 01 00       	call   8100e1 <sys_getenvid>
  800060:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800062:	c7 05 e8 42 81 00 e0 	movl   $0x810ee0,0x8142e8
  800069:	0e 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  80006c:	e8 25 01 01 00       	call   810196 <fork>
  800071:	a3 24 50 81 00       	mov    %eax,0x815024
	if (timer_envid < 0)
  800076:	85 c0                	test   %eax,%eax
  800078:	79 1c                	jns    800096 <umain+0x42>
		panic("error forking");
  80007a:	c7 44 24 08 e3 0e 81 	movl   $0x810ee3,0x8(%esp)
  800081:	00 
  800082:	c7 44 24 04 44 01 00 	movl   $0x144,0x4(%esp)
  800089:	00 
  80008a:	c7 04 24 f1 0e 81 00 	movl   $0x810ef1,(%esp)
  800091:	e8 56 f1 00 00       	call   80f1ec <_panic>
	else if (timer_envid == 0) {
  800096:	85 c0                	test   %eax,%eax
  800098:	75 15                	jne    8000af <umain+0x5b>
		timer(ns_envid, TIMER_INTERVAL);
  80009a:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  8000a1:	00 
  8000a2:	89 1c 24             	mov    %ebx,(%esp)
  8000a5:	e8 c6 06 00 00       	call   800770 <timer>
		return;
  8000aa:	e9 a1 00 00 00       	jmp    800150 <umain+0xfc>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets

	input_envid = fork();
  8000af:	e8 e2 00 01 00       	call   810196 <fork>
  8000b4:	a3 28 50 81 00       	mov    %eax,0x815028
	if (input_envid < 0)
  8000b9:	85 c0                	test   %eax,%eax
  8000bb:	79 1c                	jns    8000d9 <umain+0x85>
		panic("error forking");
  8000bd:	c7 44 24 08 e3 0e 81 	movl   $0x810ee3,0x8(%esp)
  8000c4:	00 
  8000c5:	c7 44 24 04 4f 01 00 	movl   $0x14f,0x4(%esp)
  8000cc:	00 
  8000cd:	c7 04 24 f1 0e 81 00 	movl   $0x810ef1,(%esp)
  8000d4:	e8 13 f1 00 00       	call   80f1ec <_panic>
	else if (input_envid == 0) {
  8000d9:	85 c0                	test   %eax,%eax
  8000db:	75 0a                	jne    8000e7 <umain+0x93>
		input(ns_envid);
  8000dd:	89 1c 24             	mov    %ebx,(%esp)
  8000e0:	e8 5b 07 00 00       	call   800840 <input>
		return;
  8000e5:	eb 69                	jmp    800150 <umain+0xfc>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8000e7:	e8 aa 00 01 00       	call   810196 <fork>
  8000ec:	a3 2c 50 81 00       	mov    %eax,0x81502c
	if (output_envid < 0)
  8000f1:	85 c0                	test   %eax,%eax
  8000f3:	79 1c                	jns    800111 <umain+0xbd>
		panic("error forking");
  8000f5:	c7 44 24 08 e3 0e 81 	movl   $0x810ee3,0x8(%esp)
  8000fc:	00 
  8000fd:	c7 44 24 04 59 01 00 	movl   $0x159,0x4(%esp)
  800104:	00 
  800105:	c7 04 24 f1 0e 81 00 	movl   $0x810ef1,(%esp)
  80010c:	e8 db f0 00 00       	call   80f1ec <_panic>
	else if (output_envid == 0) {
  800111:	85 c0                	test   %eax,%eax
  800113:	75 0d                	jne    800122 <umain+0xce>
		output(ns_envid);
  800115:	89 1c 24             	mov    %ebx,(%esp)
  800118:	e8 1b 08 00 00       	call   800938 <output>
		return;
  80011d:	8d 76 00             	lea    0x0(%esi),%esi
  800120:	eb 2e                	jmp    800150 <umain+0xfc>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  800122:	e8 f9 ad 00 00       	call   80af20 <thread_init>
	thread_create(0, "main", tmain, 0);
  800127:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80012e:	00 
  80012f:	c7 44 24 08 00 07 80 	movl   $0x800700,0x8(%esp)
  800136:	00 
  800137:	c7 44 24 04 fc 0e 81 	movl   $0x810efc,0x4(%esp)
  80013e:	00 
  80013f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800146:	e8 b3 af 00 00       	call   80b0fe <thread_create>
	thread_yield();
  80014b:	e8 6b ae 00 00       	call   80afbb <thread_yield>
	// never coming here!
}
  800150:	83 c4 14             	add    $0x14,%esp
  800153:	5b                   	pop    %ebx
  800154:	5d                   	pop    %ebp
  800155:	c3                   	ret    

00800156 <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  800156:	55                   	push   %ebp
  800157:	89 e5                	mov    %esp,%ebp
  800159:	57                   	push   %edi
  80015a:	56                   	push   %esi
  80015b:	53                   	push   %ebx
  80015c:	83 ec 3c             	sub    $0x3c,%esp
  80015f:	bb 00 00 00 00       	mov    $0x0,%ebx
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
		if (!buse[i]) break;
  800164:	be 30 50 81 00       	mov    $0x815030,%esi
  800169:	eb 08                	jmp    800173 <serve+0x1d>
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();
  80016b:	e8 4b ae 00 00       	call   80afbb <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800170:	83 c3 01             	add    $0x1,%ebx
  800173:	e8 f6 ad 00 00       	call   80af6e <thread_wakeups_pending>
  800178:	85 c0                	test   %eax,%eax
  80017a:	74 05                	je     800181 <serve+0x2b>
  80017c:	83 fb 1f             	cmp    $0x1f,%ebx
  80017f:	7e ea                	jle    80016b <serve+0x15>
			thread_yield();

		perm = 0;
  800181:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  800188:	b8 00 00 00 00       	mov    $0x0,%eax
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
		if (!buse[i]) break;
  80018d:	80 3c 06 00          	cmpb   $0x0,(%esi,%eax,1)
  800191:	74 0a                	je     80019d <serve+0x47>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  800193:	83 c0 01             	add    $0x1,%eax
  800196:	83 f8 14             	cmp    $0x14,%eax
  800199:	75 f2                	jne    80018d <serve+0x37>
  80019b:	eb 05                	jmp    8001a2 <serve+0x4c>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  80019d:	83 f8 14             	cmp    $0x14,%eax
  8001a0:	75 1c                	jne    8001be <serve+0x68>
		panic("NS: buffer overflow");
  8001a2:	c7 44 24 08 01 0f 81 	movl   $0x810f01,0x8(%esp)
  8001a9:	00 
  8001aa:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%esp)
  8001b1:	00 
  8001b2:	c7 04 24 f1 0e 81 00 	movl   $0x810ef1,(%esp)
  8001b9:	e8 2e f0 00 00       	call   80f1ec <_panic>
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  8001be:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  8001c4:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  8001c7:	c6 04 06 01          	movb   $0x1,(%esi,%eax,1)
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8001cb:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8001ce:	89 44 24 08          	mov    %eax,0x8(%esp)
  8001d2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8001d6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8001d9:	89 04 24             	mov    %eax,(%esp)
  8001dc:	e8 ed 03 01 00       	call   8105ce <ipc_recv>
  8001e1:	89 c7                	mov    %eax,%edi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  8001e3:	83 f8 0c             	cmp    $0xc,%eax
  8001e6:	75 6a                	jne    800252 <serve+0xfc>
			process_timer(whom);
  8001e8:	8b 7d e4             	mov    -0x1c(%ebp),%edi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  8001eb:	3b 3d 24 50 81 00    	cmp    0x815024,%edi
  8001f1:	74 12                	je     800205 <serve+0xaf>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  8001f3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8001f7:	c7 04 24 90 0f 81 00 	movl   $0x810f90,(%esp)
  8001fe:	e8 a2 f0 00 00       	call   80f2a5 <cprintf>
  800203:	eb 3c                	jmp    800241 <serve+0xeb>
		return;
	}

	start = sys_time_msec();
  800205:	e8 e9 fa 00 00       	call   80fcf3 <sys_time_msec>
  80020a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  80020d:	8d 76 00             	lea    0x0(%esi),%esi
  800210:	e8 a6 ad 00 00       	call   80afbb <thread_yield>
	now = sys_time_msec();
  800215:	e8 d9 fa 00 00       	call   80fcf3 <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  80021a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800221:	00 
  800222:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800229:	00 
  80022a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80022d:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  800233:	29 c2                	sub    %eax,%edx
  800235:	89 54 24 04          	mov    %edx,0x4(%esp)
  800239:	89 3c 24             	mov    %edi,(%esp)
  80023c:	e8 21 03 01 00       	call   810562 <ipc_send>
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
  800241:	89 d8                	mov    %ebx,%eax
  800243:	e8 f8 fd ff ff       	call   800040 <put_buffer>
  800248:	bb 00 00 00 00       	mov    $0x0,%ebx
			continue;
  80024d:	e9 21 ff ff ff       	jmp    800173 <serve+0x1d>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  800252:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  800256:	75 1d                	jne    800275 <serve+0x11f>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800258:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80025b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80025f:	c7 04 24 cc 0f 81 00 	movl   $0x810fcc,(%esp)
  800266:	e8 3a f0 00 00       	call   80f2a5 <cprintf>
  80026b:	bb 00 00 00 00       	mov    $0x0,%ebx
			continue; // just leave it hanging...
  800270:	e9 fe fe ff ff       	jmp    800173 <serve+0x1d>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  800275:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  80027c:	e8 6e 07 01 00       	call   8109ef <malloc>
		if (!args)
  800281:	85 c0                	test   %eax,%eax
  800283:	75 1c                	jne    8002a1 <serve+0x14b>
			panic("could not allocate thread args structure");
  800285:	c7 44 24 08 fc 0f 81 	movl   $0x810ffc,0x8(%esp)
  80028c:	00 
  80028d:	c7 44 24 04 27 01 00 	movl   $0x127,0x4(%esp)
  800294:	00 
  800295:	c7 04 24 f1 0e 81 00 	movl   $0x810ef1,(%esp)
  80029c:	e8 4b ef 00 00       	call   80f1ec <_panic>

		args->reqno = reqno;
  8002a1:	89 38                	mov    %edi,(%eax)
		args->whom = whom;
  8002a3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8002a6:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8002a9:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8002ac:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8002b0:	c7 44 24 08 db 02 80 	movl   $0x8002db,0x8(%esp)
  8002b7:	00 
  8002b8:	c7 44 24 04 15 0f 81 	movl   $0x810f15,0x4(%esp)
  8002bf:	00 
  8002c0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8002c7:	e8 32 ae 00 00       	call   80b0fe <thread_create>
		thread_yield(); // let the thread created run
  8002cc:	e8 ea ac 00 00       	call   80afbb <thread_yield>
  8002d1:	bb 00 00 00 00       	mov    $0x0,%ebx
  8002d6:	e9 98 fe ff ff       	jmp    800173 <serve+0x1d>

008002db <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8002db:	55                   	push   %ebp
  8002dc:	89 e5                	mov    %esp,%ebp
  8002de:	81 ec 98 00 00 00    	sub    $0x98,%esp
  8002e4:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8002e7:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8002ea:	89 7d fc             	mov    %edi,-0x4(%ebp)
	struct st_args *args = (struct st_args *)a;
  8002ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
	union Nsipc *req = args->req;
  8002f0:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  8002f3:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8002f6:	0f 87 3a 01 00 00    	ja     800436 <serve_thread+0x15b>
  8002fc:	8b 03                	mov    (%ebx),%eax
  8002fe:	ff 24 85 c8 10 81 00 	jmp    *0x8110c8(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  800305:	8b 46 04             	mov    0x4(%esi),%eax
  800308:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  80030b:	8d 45 94             	lea    -0x6c(%ebp),%eax
  80030e:	89 44 24 08          	mov    %eax,0x8(%esp)
  800312:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800315:	89 44 24 04          	mov    %eax,0x4(%esp)
  800319:	8b 06                	mov    (%esi),%eax
  80031b:	89 04 24             	mov    %eax,(%esp)
  80031e:	e8 08 1e 00 00       	call   80212b <lwip_accept>
  800323:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  800325:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80032c:	00 
  80032d:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800330:	89 44 24 04          	mov    %eax,0x4(%esp)
  800334:	89 34 24             	mov    %esi,(%esp)
  800337:	e8 73 f7 00 00       	call   80faaf <memmove>
		break;
  80033c:	e9 13 01 00 00       	jmp    800454 <serve_thread+0x179>
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800341:	8b 46 14             	mov    0x14(%esi),%eax
  800344:	89 44 24 08          	mov    %eax,0x8(%esp)
  800348:	8d 46 04             	lea    0x4(%esi),%eax
  80034b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80034f:	8b 06                	mov    (%esi),%eax
  800351:	89 04 24             	mov    %eax,(%esp)
  800354:	e8 19 1d 00 00       	call   802072 <lwip_bind>
  800359:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  80035b:	e9 f4 00 00 00       	jmp    800454 <serve_thread+0x179>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800360:	8b 46 04             	mov    0x4(%esi),%eax
  800363:	89 44 24 04          	mov    %eax,0x4(%esp)
  800367:	8b 06                	mov    (%esi),%eax
  800369:	89 04 24             	mov    %eax,(%esp)
  80036c:	e8 a7 1b 00 00       	call   801f18 <lwip_shutdown>
  800371:	89 c7                	mov    %eax,%edi
		break;
  800373:	e9 dc 00 00 00       	jmp    800454 <serve_thread+0x179>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  800378:	8b 06                	mov    (%esi),%eax
  80037a:	89 04 24             	mov    %eax,(%esp)
  80037d:	e8 1a 1b 00 00       	call   801e9c <lwip_close>
  800382:	89 c7                	mov    %eax,%edi
		break;
  800384:	e9 cb 00 00 00       	jmp    800454 <serve_thread+0x179>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  800389:	8b 46 14             	mov    0x14(%esi),%eax
  80038c:	89 44 24 08          	mov    %eax,0x8(%esp)
  800390:	8d 46 04             	lea    0x4(%esi),%eax
  800393:	89 44 24 04          	mov    %eax,0x4(%esp)
  800397:	8b 06                	mov    (%esi),%eax
  800399:	89 04 24             	mov    %eax,(%esp)
  80039c:	e8 18 1c 00 00       	call   801fb9 <lwip_connect>
  8003a1:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  8003a3:	e9 ac 00 00 00       	jmp    800454 <serve_thread+0x179>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8003a8:	8b 46 04             	mov    0x4(%esi),%eax
  8003ab:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003af:	8b 06                	mov    (%esi),%eax
  8003b1:	89 04 24             	mov    %eax,(%esp)
  8003b4:	e8 72 1b 00 00       	call   801f2b <lwip_listen>
  8003b9:	89 c7                	mov    %eax,%edi
		break;
  8003bb:	e9 94 00 00 00       	jmp    800454 <serve_thread+0x179>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8003c0:	8b 46 08             	mov    0x8(%esi),%eax
  8003c3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003c7:	8b 46 04             	mov    0x4(%esi),%eax
  8003ca:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003ce:	89 74 24 04          	mov    %esi,0x4(%esp)
  8003d2:	8b 06                	mov    (%esi),%eax
  8003d4:	89 04 24             	mov    %eax,(%esp)
  8003d7:	e8 4f 1a 00 00       	call   801e2b <lwip_recv>
  8003dc:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  8003de:	eb 74                	jmp    800454 <serve_thread+0x179>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8003e0:	8b 46 08             	mov    0x8(%esi),%eax
  8003e3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003e7:	8b 46 04             	mov    0x4(%esi),%eax
  8003ea:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003ee:	8d 46 0c             	lea    0xc(%esi),%eax
  8003f1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003f5:	8b 06                	mov    (%esi),%eax
  8003f7:	89 04 24             	mov    %eax,(%esp)
  8003fa:	e8 b1 15 00 00       	call   8019b0 <lwip_send>
  8003ff:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  800401:	eb 51                	jmp    800454 <serve_thread+0x179>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  800403:	8b 46 08             	mov    0x8(%esi),%eax
  800406:	89 44 24 08          	mov    %eax,0x8(%esp)
  80040a:	8b 46 04             	mov    0x4(%esi),%eax
  80040d:	89 44 24 04          	mov    %eax,0x4(%esp)
  800411:	8b 06                	mov    (%esi),%eax
  800413:	89 04 24             	mov    %eax,(%esp)
  800416:	e8 ae 14 00 00       	call   8018c9 <lwip_socket>
  80041b:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  80041d:	eb 35                	jmp    800454 <serve_thread+0x179>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  80041f:	89 74 24 04          	mov    %esi,0x4(%esp)
  800423:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  80042a:	e8 f3 b0 00 00       	call   80b522 <jif_input>
  80042f:	bf 00 00 00 00       	mov    $0x0,%edi
		r = 0;
		break;
  800434:	eb 4c                	jmp    800482 <serve_thread+0x1a7>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  800436:	89 74 24 08          	mov    %esi,0x8(%esp)
  80043a:	8b 43 04             	mov    0x4(%ebx),%eax
  80043d:	89 44 24 04          	mov    %eax,0x4(%esp)
  800441:	c7 04 24 28 10 81 00 	movl   $0x811028,(%esp)
  800448:	e8 58 ee 00 00       	call   80f2a5 <cprintf>
  80044d:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
  800452:	eb 2e                	jmp    800482 <serve_thread+0x1a7>
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  800454:	83 ff ff             	cmp    $0xffffffff,%edi
  800457:	75 29                	jne    800482 <serve_thread+0x1a7>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800459:	8b 03                	mov    (%ebx),%eax
  80045b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80045f:	c7 44 24 08 22 0f 81 	movl   $0x810f22,0x8(%esp)
  800466:	00 
  800467:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  80046e:	00 
  80046f:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800472:	89 34 24             	mov    %esi,(%esp)
  800475:	e8 02 f4 00 00       	call   80f87c <snprintf>
		perror(buf);
  80047a:	89 34 24             	mov    %esi,(%esp)
  80047d:	e8 85 ae 00 00       	call   80b307 <perror>
	}

	if (args->reqno != NSREQ_INPUT)
  800482:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800485:	74 1f                	je     8004a6 <serve_thread+0x1cb>
		ipc_send(args->whom, r, 0, 0);
  800487:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80048e:	00 
  80048f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800496:	00 
  800497:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80049b:	8b 43 04             	mov    0x4(%ebx),%eax
  80049e:	89 04 24             	mov    %eax,(%esp)
  8004a1:	e8 bc 00 01 00       	call   810562 <ipc_send>

	put_buffer(args->req);
  8004a6:	8b 43 08             	mov    0x8(%ebx),%eax
  8004a9:	e8 92 fb ff ff       	call   800040 <put_buffer>
	sys_page_unmap(0, (void*) args->req);
  8004ae:	8b 43 08             	mov    0x8(%ebx),%eax
  8004b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8004b5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8004bc:	e8 d1 fa 00 00       	call   80ff92 <sys_page_unmap>
	free(args);
  8004c1:	89 1c 24             	mov    %ebx,(%esp)
  8004c4:	e8 53 04 01 00       	call   81091c <free>
}
  8004c9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8004cc:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8004cf:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8004d2:	89 ec                	mov    %ebp,%esp
  8004d4:	5d                   	pop    %ebp
  8004d5:	c3                   	ret    

008004d6 <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  8004d6:	55                   	push   %ebp
  8004d7:	89 e5                	mov    %esp,%ebp
  8004d9:	56                   	push   %esi
  8004da:	53                   	push   %ebx
  8004db:	83 ec 10             	sub    $0x10,%esp
	struct timer_thread *t = (struct timer_thread *) arg;
  8004de:	8b 5d 08             	mov    0x8(%ebp),%ebx

	for (;;) {
		uint32_t cur = sys_time_msec();
  8004e1:	e8 0d f8 00 00       	call   80fcf3 <sys_time_msec>
  8004e6:	89 c6                	mov    %eax,%esi

		lwip_core_lock();
  8004e8:	e8 72 a1 00 00       	call   80a65f <lwip_core_lock>
		t->func();
  8004ed:	ff 53 04             	call   *0x4(%ebx)
		lwip_core_unlock();
  8004f0:	e8 6f a1 00 00       	call   80a664 <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  8004f5:	03 33                	add    (%ebx),%esi
  8004f7:	89 74 24 08          	mov    %esi,0x8(%esp)
  8004fb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800502:	00 
  800503:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80050a:	e8 37 ad 00 00       	call   80b246 <thread_wait>
  80050f:	eb d0                	jmp    8004e1 <net_timer+0xb>

00800511 <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800511:	55                   	push   %ebp
  800512:	89 e5                	mov    %esp,%ebp
  800514:	53                   	push   %ebx
  800515:	83 ec 14             	sub    $0x14,%esp
	t->msec = msec;
  800518:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80051b:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  80051d:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800520:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  800523:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800527:	c7 44 24 08 d6 04 80 	movl   $0x8004d6,0x8(%esp)
  80052e:	00 
  80052f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800533:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80053a:	e8 bf ab 00 00       	call   80b0fe <thread_create>
	if (r < 0)
  80053f:	85 c0                	test   %eax,%eax
  800541:	79 28                	jns    80056b <start_timer+0x5a>
		panic("cannot create timer thread: %s", e2s(r));
  800543:	89 04 24             	mov    %eax,(%esp)
  800546:	e8 ad ad 00 00       	call   80b2f8 <e2s>
  80054b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80054f:	c7 44 24 08 4c 10 81 	movl   $0x81104c,0x8(%esp)
  800556:	00 
  800557:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  80055e:	00 
  80055f:	c7 04 24 f1 0e 81 00 	movl   $0x810ef1,(%esp)
  800566:	e8 81 ec 00 00       	call   80f1ec <_panic>
}
  80056b:	83 c4 14             	add    $0x14,%esp
  80056e:	5b                   	pop    %ebx
  80056f:	5d                   	pop    %ebp
  800570:	c3                   	ret    

00800571 <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800571:	55                   	push   %ebp
  800572:	89 e5                	mov    %esp,%ebp
  800574:	56                   	push   %esi
  800575:	53                   	push   %ebx
  800576:	83 ec 30             	sub    $0x30,%esp
  800579:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  80057c:	e8 de a0 00 00       	call   80a65f <lwip_core_lock>

	uint32_t done = 0;
  800581:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800588:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80058b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80058f:	c7 04 24 53 07 80 00 	movl   $0x800753,(%esp)
  800596:	e8 88 1d 00 00       	call   802323 <tcpip_init>
	lwip_core_unlock();
  80059b:	e8 c4 a0 00 00       	call   80a664 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8005a0:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  8005a7:	ff 
  8005a8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8005af:	00 
  8005b0:	89 1c 24             	mov    %ebx,(%esp)
  8005b3:	e8 8e ac 00 00       	call   80b246 <thread_wait>
	lwip_core_lock();
  8005b8:	e8 a2 a0 00 00       	call   80a65f <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  8005bd:	89 75 f0             	mov    %esi,-0x10(%ebp)
	netmask.addr = init_mask;
  8005c0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8005c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8005c6:	8b 45 10             	mov    0x10(%ebp),%eax
  8005c9:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8005cc:	c7 44 24 18 0a 6e 80 	movl   $0x806e0a,0x18(%esp)
  8005d3:	00 
  8005d4:	c7 44 24 14 40 b3 80 	movl   $0x80b340,0x14(%esp)
  8005db:	00 
  8005dc:	c7 44 24 10 2c 50 81 	movl   $0x81502c,0x10(%esp)
  8005e3:	00 
  8005e4:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8005e7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8005eb:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8005ee:	89 44 24 08          	mov    %eax,0x8(%esp)
  8005f2:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8005f5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8005f9:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  800600:	e8 48 47 00 00       	call   804d4d <netif_add>
  800605:	85 c0                	test   %eax,%eax
  800607:	75 1c                	jne    800625 <serve_init+0xb4>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  800609:	c7 44 24 08 6c 10 81 	movl   $0x81106c,0x8(%esp)
  800610:	00 
  800611:	c7 44 24 04 5c 00 00 	movl   $0x5c,0x4(%esp)
  800618:	00 
  800619:	c7 04 24 f1 0e 81 00 	movl   $0x810ef1,(%esp)
  800620:	e8 c7 eb 00 00       	call   80f1ec <_panic>

	netif_set_default(nif);
  800625:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  80062c:	e8 ae 45 00 00       	call   804bdf <netif_set_default>
	netif_set_up(nif);
  800631:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  800638:	e8 21 46 00 00       	call   804c5e <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80063d:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800644:	b9 31 0f 81 00       	mov    $0x810f31,%ecx
  800649:	ba fd a0 80 00       	mov    $0x80a0fd,%edx
  80064e:	b8 00 50 81 00       	mov    $0x815000,%eax
  800653:	e8 b9 fe ff ff       	call   800511 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800658:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80065f:	b9 3b 0f 81 00       	mov    $0x810f3b,%ecx
  800664:	ba 65 5c 80 00       	mov    $0x805c65,%edx
  800669:	b8 0c 50 81 00       	mov    $0x81500c,%eax
  80066e:	e8 9e fe ff ff       	call   800511 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800673:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  80067a:	b9 47 0f 81 00       	mov    $0x810f47,%ecx
  80067f:	ba 66 65 80 00       	mov    $0x806566,%edx
  800684:	b8 18 50 81 00       	mov    $0x815018,%eax
  800689:	e8 83 fe ff ff       	call   800511 <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80068e:	89 34 24             	mov    %esi,(%esp)
  800691:	e8 0a 77 00 00       	call   807da0 <inet_ntoa>
  800696:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  80069a:	0f b6 05 2a b2 b3 00 	movzbl 0xb3b22a,%eax
  8006a1:	89 44 24 18          	mov    %eax,0x18(%esp)
  8006a5:	0f b6 05 29 b2 b3 00 	movzbl 0xb3b229,%eax
  8006ac:	89 44 24 14          	mov    %eax,0x14(%esp)
  8006b0:	0f b6 05 28 b2 b3 00 	movzbl 0xb3b228,%eax
  8006b7:	89 44 24 10          	mov    %eax,0x10(%esp)
  8006bb:	0f b6 05 27 b2 b3 00 	movzbl 0xb3b227,%eax
  8006c2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8006c6:	0f b6 05 26 b2 b3 00 	movzbl 0xb3b226,%eax
  8006cd:	89 44 24 08          	mov    %eax,0x8(%esp)
  8006d1:	0f b6 05 25 b2 b3 00 	movzbl 0xb3b225,%eax
  8006d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8006dc:	c7 04 24 8c 10 81 00 	movl   $0x81108c,(%esp)
  8006e3:	e8 bd eb 00 00       	call   80f2a5 <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  8006e8:	e8 77 9f 00 00       	call   80a664 <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  8006ed:	c7 04 24 53 0f 81 00 	movl   $0x810f53,(%esp)
  8006f4:	e8 ac eb 00 00       	call   80f2a5 <cprintf>
}
  8006f9:	83 c4 30             	add    $0x30,%esp
  8006fc:	5b                   	pop    %ebx
  8006fd:	5e                   	pop    %esi
  8006fe:	5d                   	pop    %ebp
  8006ff:	c3                   	ret    

00800700 <tmain>:
		thread_yield(); // let the thread created run
	}
}

static void
tmain(uint32_t arg) {
  800700:	55                   	push   %ebp
  800701:	89 e5                	mov    %esp,%ebp
  800703:	83 ec 18             	sub    $0x18,%esp
  800706:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  800709:	89 75 fc             	mov    %esi,-0x4(%ebp)
	serve_init(inet_addr(IP),
  80070c:	c7 04 24 6c 0f 81 00 	movl   $0x810f6c,(%esp)
  800713:	e8 4f 79 00 00       	call   808067 <inet_addr>
  800718:	89 c3                	mov    %eax,%ebx
  80071a:	c7 04 24 75 0f 81 00 	movl   $0x810f75,(%esp)
  800721:	e8 41 79 00 00       	call   808067 <inet_addr>
  800726:	89 c6                	mov    %eax,%esi
  800728:	c7 04 24 83 0f 81 00 	movl   $0x810f83,(%esp)
  80072f:	e8 33 79 00 00       	call   808067 <inet_addr>
  800734:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800738:	89 74 24 04          	mov    %esi,0x4(%esp)
  80073c:	89 04 24             	mov    %eax,(%esp)
  80073f:	e8 2d fe ff ff       	call   800571 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800744:	e8 0d fa ff ff       	call   800156 <serve>
}
  800749:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80074c:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80074f:	89 ec                	mov    %ebp,%esp
  800751:	5d                   	pop    %ebp
  800752:	c3                   	ret    

00800753 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800753:	55                   	push   %ebp
  800754:	89 e5                	mov    %esp,%ebp
  800756:	83 ec 18             	sub    $0x18,%esp
  800759:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  80075c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800762:	89 04 24             	mov    %eax,(%esp)
  800765:	e8 e5 a7 00 00       	call   80af4f <thread_wakeup>
}
  80076a:	c9                   	leave  
  80076b:	c3                   	ret    
  80076c:	00 00                	add    %al,(%eax)
	...

00800770 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800770:	55                   	push   %ebp
  800771:	89 e5                	mov    %esp,%ebp
  800773:	57                   	push   %edi
  800774:	56                   	push   %esi
  800775:	53                   	push   %ebx
  800776:	83 ec 2c             	sub    $0x2c,%esp
  800779:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80077c:	e8 72 f5 00 00       	call   80fcf3 <sys_time_msec>
  800781:	89 c3                	mov    %eax,%ebx
  800783:	03 5d 0c             	add    0xc(%ebp),%ebx

	binaryname = "ns_timer";
  800786:	c7 05 e8 42 81 00 f4 	movl   $0x8110f4,0x8142e8
  80078d:	10 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800790:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  800793:	eb 05                	jmp    80079a <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  800795:	e8 13 f9 00 00       	call   8100ad <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  80079a:	e8 54 f5 00 00       	call   80fcf3 <sys_time_msec>
  80079f:	39 c3                	cmp    %eax,%ebx
  8007a1:	76 06                	jbe    8007a9 <timer+0x39>
  8007a3:	85 c0                	test   %eax,%eax
  8007a5:	79 ee                	jns    800795 <timer+0x25>
  8007a7:	eb 09                	jmp    8007b2 <timer+0x42>
			sys_yield();
		}
		if (r < 0)
  8007a9:	85 c0                	test   %eax,%eax
  8007ab:	90                   	nop
  8007ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8007b0:	79 20                	jns    8007d2 <timer+0x62>
			panic("sys_time_msec: %e", r);
  8007b2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8007b6:	c7 44 24 08 fd 10 81 	movl   $0x8110fd,0x8(%esp)
  8007bd:	00 
  8007be:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  8007c5:	00 
  8007c6:	c7 04 24 0f 11 81 00 	movl   $0x81110f,(%esp)
  8007cd:	e8 1a ea 00 00       	call   80f1ec <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8007d2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8007d9:	00 
  8007da:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007e1:	00 
  8007e2:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  8007e9:	00 
  8007ea:	89 34 24             	mov    %esi,(%esp)
  8007ed:	e8 70 fd 00 00       	call   810562 <ipc_send>

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007f2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007f9:	00 
  8007fa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800801:	00 
  800802:	89 3c 24             	mov    %edi,(%esp)
  800805:	e8 c4 fd 00 00       	call   8105ce <ipc_recv>
  80080a:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  80080c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80080f:	39 c6                	cmp    %eax,%esi
  800811:	74 12                	je     800825 <timer+0xb5>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800813:	89 44 24 04          	mov    %eax,0x4(%esp)
  800817:	c7 04 24 1c 11 81 00 	movl   $0x81111c,(%esp)
  80081e:	e8 82 ea 00 00       	call   80f2a5 <cprintf>
				continue;
			}

			stop = sys_time_msec() + to;
			break;
		}
  800823:	eb cd                	jmp    8007f2 <timer+0x82>
			if (whom != ns_envid) {
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  800825:	e8 c9 f4 00 00       	call   80fcf3 <sys_time_msec>
  80082a:	01 c3                	add    %eax,%ebx
  80082c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  800830:	e9 65 ff ff ff       	jmp    80079a <timer+0x2a>
	...

00800840 <input>:

void
input(envid_t ns_envid)
//void
//umain(int argc, char **argv)
{
  800840:	55                   	push   %ebp
  800841:	89 e5                	mov    %esp,%ebp
  800843:	57                   	push   %edi
  800844:	56                   	push   %esi
  800845:	53                   	push   %ebx
  800846:	83 ec 2c             	sub    $0x2c,%esp
	uint32_t req, whom, size;
	int perm, ret, even_odd = 0;
	envid_t to_env;

	binaryname = "ns_input";
  800849:	c7 05 e8 42 81 00 57 	movl   $0x811157,0x8142e8
  800850:	11 81 00 
  800853:	bb 00 00 00 00       	mov    $0x0,%ebx
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.

	while (1) 
	{
		ret = sys_net_receive((void *)INPUT_PKTMAP,&size);
  800858:	8d 75 e4             	lea    -0x1c(%ebp),%esi
			ipc_send(ns_envid,NSREQ_INPUT,&nsipcbuf,PTE_P|PTE_W|PTE_U);

		}
		else
		{
			nsipcbuf_1.pkt.jp_len = size;
  80085b:	bf 00 c0 b3 00       	mov    $0xb3c000,%edi
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.

	while (1) 
	{
		ret = sys_net_receive((void *)INPUT_PKTMAP,&size);
  800860:	89 74 24 04          	mov    %esi,0x4(%esp)
  800864:	c7 04 24 00 00 00 10 	movl   $0x10000000,(%esp)
  80086b:	e8 b7 f4 00 00       	call   80fd27 <sys_net_receive>
		if( ret == -E_NO_RDESC ) 
  800870:	83 f8 ef             	cmp    $0xffffffef,%eax
  800873:	75 07                	jne    80087c <input+0x3c>
		  {sys_yield(); continue;}
  800875:	e8 33 f8 00 00       	call   8100ad <sys_yield>
  80087a:	eb e4                	jmp    800860 <input+0x20>
		cprintf("%s get an input packet size %u\n",__func__,size);
  80087c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80087f:	89 44 24 08          	mov    %eax,0x8(%esp)
  800883:	c7 44 24 04 80 11 81 	movl   $0x811180,0x4(%esp)
  80088a:	00 
  80088b:	c7 04 24 60 11 81 00 	movl   $0x811160,(%esp)
  800892:	e8 0e ea 00 00       	call   80f2a5 <cprintf>

		if(even_odd)
  800897:	85 db                	test   %ebx,%ebx
  800899:	74 45                	je     8008e0 <input+0xa0>
		{
			nsipcbuf.pkt.jp_len = size;
  80089b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80089e:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
			memmove(nsipcbuf.pkt.jp_data,(void *)INPUT_PKTMAP,nsipcbuf.pkt.jp_len);
  8008a3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8008a7:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  8008ae:	10 
  8008af:	c7 04 24 04 d0 b3 00 	movl   $0xb3d004,(%esp)
  8008b6:	e8 f4 f1 00 00       	call   80faaf <memmove>
			ipc_send(ns_envid,NSREQ_INPUT,&nsipcbuf,PTE_P|PTE_W|PTE_U);
  8008bb:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  8008c2:	00 
  8008c3:	c7 44 24 08 00 d0 b3 	movl   $0xb3d000,0x8(%esp)
  8008ca:	00 
  8008cb:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  8008d2:	00 
  8008d3:	8b 45 08             	mov    0x8(%ebp),%eax
  8008d6:	89 04 24             	mov    %eax,(%esp)
  8008d9:	e8 84 fc 00 00       	call   810562 <ipc_send>
  8008de:	eb 3c                	jmp    80091c <input+0xdc>

		}
		else
		{
			nsipcbuf_1.pkt.jp_len = size;
  8008e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8008e3:	89 07                	mov    %eax,(%edi)
			memmove(nsipcbuf_1.pkt.jp_data,(void *)INPUT_PKTMAP,nsipcbuf_1.pkt.jp_len);
  8008e5:	89 44 24 08          	mov    %eax,0x8(%esp)
  8008e9:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  8008f0:	10 
  8008f1:	c7 04 24 04 c0 b3 00 	movl   $0xb3c004,(%esp)
  8008f8:	e8 b2 f1 00 00       	call   80faaf <memmove>
			ipc_send(ns_envid,NSREQ_INPUT,&nsipcbuf_1,PTE_P|PTE_W|PTE_U);
  8008fd:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  800904:	00 
  800905:	89 7c 24 08          	mov    %edi,0x8(%esp)
  800909:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  800910:	00 
  800911:	8b 45 08             	mov    0x8(%ebp),%eax
  800914:	89 04 24             	mov    %eax,(%esp)
  800917:	e8 46 fc 00 00       	call   810562 <ipc_send>
		}
		even_odd = (even_odd+1)%2;
  80091c:	83 c3 01             	add    $0x1,%ebx
  80091f:	89 d8                	mov    %ebx,%eax
  800921:	c1 e8 1f             	shr    $0x1f,%eax
  800924:	01 c3                	add    %eax,%ebx
  800926:	83 e3 01             	and    $0x1,%ebx
  800929:	29 c3                	sub    %eax,%ebx
		sys_yield();
  80092b:	e8 7d f7 00 00       	call   8100ad <sys_yield>
  800930:	e9 2b ff ff ff       	jmp    800860 <input+0x20>
  800935:	00 00                	add    %al,(%eax)
	...

00800938 <output>:

void
output(envid_t ns_envid)
//void
//umain(int argc, char **argv)
{
  800938:	55                   	push   %ebp
  800939:	89 e5                	mov    %esp,%ebp
  80093b:	57                   	push   %edi
  80093c:	56                   	push   %esi
  80093d:	53                   	push   %ebx
  80093e:	83 ec 3c             	sub    $0x3c,%esp
	//	- send the packet to the device driver
	uint32_t req, whom;
	int perm, ret;
	void *pg;

	binaryname = "ns_output";
  800941:	c7 05 e8 42 81 00 86 	movl   $0x811186,0x8142e8
  800948:	11 81 00 
	//cprintf("output is running\n");

	while (1) {
		perm = 0;
		req = ipc_recv((int32_t *) &whom, &nsipcbuf, &perm);
  80094b:	8d 75 e0             	lea    -0x20(%ebp),%esi
  80094e:	8d 7d e4             	lea    -0x1c(%ebp),%edi

	binaryname = "ns_output";
	//cprintf("output is running\n");

	while (1) {
		perm = 0;
  800951:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		req = ipc_recv((int32_t *) &whom, &nsipcbuf, &perm);
  800958:	89 74 24 08          	mov    %esi,0x8(%esp)
  80095c:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  800963:	00 
  800964:	89 3c 24             	mov    %edi,(%esp)
  800967:	e8 62 fc 00 00       	call   8105ce <ipc_recv>

		cprintf("%s req %d from %08x size %u\n", __func__, req, whom, nsipcbuf.pkt.jp_len);
  80096c:	8b 15 00 d0 b3 00    	mov    0xb3d000,%edx
  800972:	89 54 24 10          	mov    %edx,0x10(%esp)
  800976:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800979:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80097d:	89 44 24 08          	mov    %eax,0x8(%esp)
  800981:	c7 44 24 04 f3 11 81 	movl   $0x8111f3,0x4(%esp)
  800988:	00 
  800989:	c7 04 24 90 11 81 00 	movl   $0x811190,(%esp)
  800990:	e8 10 e9 00 00       	call   80f2a5 <cprintf>

		// All requests must contain an argument page
		if (!(perm & PTE_P)) 
  800995:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  800999:	75 15                	jne    8009b0 <output+0x78>
		{
			cprintf("Invalid request from %08x: no argument page\n",whom);
  80099b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80099e:	89 44 24 04          	mov    %eax,0x4(%esp)
  8009a2:	c7 04 24 cc 0f 81 00 	movl   $0x810fcc,(%esp)
  8009a9:	e8 f7 e8 00 00       	call   80f2a5 <cprintf>
			continue;
  8009ae:	eb a1                	jmp    800951 <output+0x19>
		}

		if(whom != ns_envid)
  8009b0:	8b 45 08             	mov    0x8(%ebp),%eax
  8009b3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  8009b6:	74 24                	je     8009dc <output+0xa4>
			panic("%s get message from wrong environments",__func__);
  8009b8:	c7 44 24 0c f3 11 81 	movl   $0x8111f3,0xc(%esp)
  8009bf:	00 
  8009c0:	c7 44 24 08 cc 11 81 	movl   $0x8111cc,0x8(%esp)
  8009c7:	00 
  8009c8:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  8009cf:	00 
  8009d0:	c7 04 24 ad 11 81 00 	movl   $0x8111ad,(%esp)
  8009d7:	e8 10 e8 00 00       	call   80f1ec <_panic>

		do 
		{ret = sys_net_send(nsipcbuf.pkt.jp_data,nsipcbuf.pkt.jp_len);}
  8009dc:	bb 00 d0 b3 00       	mov    $0xb3d000,%ebx
  8009e1:	8b 03                	mov    (%ebx),%eax
  8009e3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8009e7:	c7 04 24 04 d0 b3 00 	movl   $0xb3d004,(%esp)
  8009ee:	e8 92 f3 00 00       	call   80fd85 <sys_net_send>
		while(ret == -E_NO_TXDESC);
  8009f3:	83 f8 f0             	cmp    $0xfffffff0,%eax
  8009f6:	74 e9                	je     8009e1 <output+0xa9>

		if(ret)panic("output error %e\n",ret);
  8009f8:	85 c0                	test   %eax,%eax
  8009fa:	0f 84 51 ff ff ff    	je     800951 <output+0x19>
  800a00:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800a04:	c7 44 24 08 ba 11 81 	movl   $0x8111ba,0x8(%esp)
  800a0b:	00 
  800a0c:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  800a13:	00 
  800a14:	c7 04 24 ad 11 81 00 	movl   $0x8111ad,(%esp)
  800a1b:	e8 cc e7 00 00       	call   80f1ec <_panic>

00800a20 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  800a20:	55                   	push   %ebp
  800a21:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  800a23:	83 f8 1f             	cmp    $0x1f,%eax
  800a26:	76 11                	jbe    800a39 <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  800a28:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  800a2f:	00 00 00 
  800a32:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  800a37:	eb 1e                	jmp    800a57 <get_socket+0x37>
  }

  sock = &sockets[s];
  800a39:	8d 04 80             	lea    (%eax,%eax,4),%eax
  800a3c:	8d 04 85 60 50 81 00 	lea    0x815060(,%eax,4),%eax

  if (!sock->conn) {
  800a43:	83 38 00             	cmpl   $0x0,(%eax)
  800a46:	75 0f                	jne    800a57 <get_socket+0x37>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  800a48:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  800a4f:	00 00 00 
  800a52:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  }

  return sock;
}
  800a57:	5d                   	pop    %ebp
  800a58:	c3                   	ret    

00800a59 <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  800a59:	55                   	push   %ebp
  800a5a:	89 e5                	mov    %esp,%ebp
  800a5c:	56                   	push   %esi
  800a5d:	53                   	push   %ebx
  800a5e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  800a61:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  800a64:	8b 45 08             	mov    0x8(%ebp),%eax
  800a67:	e8 b4 ff ff ff       	call   800a20 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  800a6c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800a71:	85 c0                	test   %eax,%eax
  800a73:	0f 84 a1 00 00 00    	je     800b1a <lwip_ioctl+0xc1>
    return -1;

  switch (cmd) {
  800a79:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  800a7f:	74 54                	je     800ad5 <lwip_ioctl+0x7c>
  800a81:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  800a87:	75 7b                	jne    800b04 <lwip_ioctl+0xab>
  case FIONREAD:
    if (!argp) {
  800a89:	85 f6                	test   %esi,%esi
  800a8b:	75 13                	jne    800aa0 <lwip_ioctl+0x47>
      sock_set_errno(sock, EINVAL);
  800a8d:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  800a94:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  800a9b:	00 00 00 
      return -1;
  800a9e:	eb 7a                	jmp    800b1a <lwip_ioctl+0xc1>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  800aa0:	8b 10                	mov    (%eax),%edx
  800aa2:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  800aa6:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  800aa9:	8b 48 04             	mov    0x4(%eax),%ecx
  800aac:	85 c9                	test   %ecx,%ecx
  800aae:	74 0d                	je     800abd <lwip_ioctl+0x64>
      buflen = netbuf_len(sock->lastdata);
  800ab0:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  800ab2:	66 03 51 08          	add    0x8(%ecx),%dx
  800ab6:	66 2b 50 08          	sub    0x8(%eax),%dx
  800aba:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  800abd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  800ac4:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  800acb:	00 00 00 
  800ace:	ba 00 00 00 00       	mov    $0x0,%edx
    return 0;
  800ad3:	eb 45                	jmp    800b1a <lwip_ioctl+0xc1>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  800ad5:	85 f6                	test   %esi,%esi
  800ad7:	74 0d                	je     800ae6 <lwip_ioctl+0x8d>
  800ad9:	83 3e 00             	cmpl   $0x0,(%esi)
  800adc:	74 08                	je     800ae6 <lwip_ioctl+0x8d>
      sock->flags |= O_NONBLOCK;
  800ade:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
    return 0;

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  800ae4:	eb 06                	jmp    800aec <lwip_ioctl+0x93>
      sock->flags |= O_NONBLOCK;
    else
      sock->flags &= ~O_NONBLOCK;
  800ae6:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  800aec:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  800af3:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  800afa:	00 00 00 
  800afd:	ba 00 00 00 00       	mov    $0x0,%edx
    return 0;
  800b02:	eb 16                	jmp    800b1a <lwip_ioctl+0xc1>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  800b04:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  800b0b:	c7 05 e0 b1 b3 00 26 	movl   $0x26,0xb3b1e0
  800b12:	00 00 00 
  800b15:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    return -1;
  } /* switch (cmd) */
}
  800b1a:	89 d0                	mov    %edx,%eax
  800b1c:	5b                   	pop    %ebx
  800b1d:	5e                   	pop    %esi
  800b1e:	5d                   	pop    %ebp
  800b1f:	c3                   	ret    

00800b20 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  800b20:	55                   	push   %ebp
  800b21:	89 e5                	mov    %esp,%ebp
  800b23:	83 ec 48             	sub    $0x48,%esp
  800b26:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  800b29:	89 75 f8             	mov    %esi,-0x8(%ebp)
  800b2c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  800b2f:	8b 75 0c             	mov    0xc(%ebp),%esi
  800b32:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  800b35:	8b 45 08             	mov    0x8(%ebp),%eax
  800b38:	e8 e3 fe ff ff       	call   800a20 <get_socket>
  800b3d:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  800b3f:	85 c0                	test   %eax,%eax
  800b41:	0f 84 28 01 00 00    	je     800c6f <lwip_setsockopt+0x14f>
    return -1;

  if (NULL == optval) {
  800b47:	85 ff                	test   %edi,%edi
  800b49:	75 1b                	jne    800b66 <lwip_setsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  800b4b:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  800b52:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  800b59:	00 00 00 
  800b5c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  800b61:	e9 15 01 00 00       	jmp    800c7b <lwip_setsockopt+0x15b>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  800b66:	83 fe 06             	cmp    $0x6,%esi
  800b69:	74 6c                	je     800bd7 <lwip_setsockopt+0xb7>
  800b6b:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  800b71:	74 09                	je     800b7c <lwip_setsockopt+0x5c>
  800b73:	85 f6                	test   %esi,%esi
  800b75:	74 49                	je     800bc0 <lwip_setsockopt+0xa0>
  800b77:	e9 82 00 00 00       	jmp    800bfe <lwip_setsockopt+0xde>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800b7c:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  800b80:	74 0f                	je     800b91 <lwip_setsockopt+0x71>
  800b82:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  800b89:	74 12                	je     800b9d <lwip_setsockopt+0x7d>
  800b8b:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  800b8f:	75 6d                	jne    800bfe <lwip_setsockopt+0xde>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  800b91:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  800b95:	0f 86 ed 00 00 00    	jbe    800c88 <lwip_setsockopt+0x168>
  800b9b:	eb 79                	jmp    800c16 <lwip_setsockopt+0xf6>
        err = EINVAL;
      }
      break;
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  800b9d:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  800ba1:	19 c0                	sbb    %eax,%eax
  800ba3:	83 e0 16             	and    $0x16,%eax
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  800ba6:	8b 13                	mov    (%ebx),%edx
  800ba8:	83 3a 20             	cmpl   $0x20,(%edx)
  800bab:	0f 85 e1 00 00 00    	jne    800c92 <lwip_setsockopt+0x172>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  800bb1:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  800bb4:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  800bb8:	0f 85 d4 00 00 00    	jne    800c92 <lwip_setsockopt+0x172>
  800bbe:	eb 43                	jmp    800c03 <lwip_setsockopt+0xe3>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800bc0:	8b 45 10             	mov    0x10(%ebp),%eax
  800bc3:	83 e8 01             	sub    $0x1,%eax
  800bc6:	83 f8 01             	cmp    $0x1,%eax
  800bc9:	77 33                	ja     800bfe <lwip_setsockopt+0xde>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  800bcb:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  800bcf:	0f 86 b3 00 00 00    	jbe    800c88 <lwip_setsockopt+0x168>
  800bd5:	eb 3f                	jmp    800c16 <lwip_setsockopt+0xf6>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  800bd7:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  800bdb:	0f 86 a7 00 00 00    	jbe    800c88 <lwip_setsockopt+0x168>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  800be1:	8b 00                	mov    (%eax),%eax
  800be3:	83 38 10             	cmpl   $0x10,(%eax)
  800be6:	0f 85 8a 00 00 00    	jne    800c76 <lwip_setsockopt+0x156>
  800bec:	8b 55 10             	mov    0x10(%ebp),%edx
  800bef:	83 ea 01             	sub    $0x1,%edx
  800bf2:	b8 5c 00 00 00       	mov    $0x5c,%eax
  800bf7:	83 fa 01             	cmp    $0x1,%edx
  800bfa:	77 0b                	ja     800c07 <lwip_setsockopt+0xe7>
  800bfc:	eb 18                	jmp    800c16 <lwip_setsockopt+0xf6>
  800bfe:	b8 5c 00 00 00       	mov    $0x5c,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  800c03:	85 c0                	test   %eax,%eax
  800c05:	74 0f                	je     800c16 <lwip_setsockopt+0xf6>
    sock_set_errno(sock, err);
  800c07:	89 43 10             	mov    %eax,0x10(%ebx)
  800c0a:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  800c0f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  800c14:	eb 65                	jmp    800c7b <lwip_setsockopt+0x15b>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  800c16:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  800c19:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  800c1c:	8b 45 10             	mov    0x10(%ebp),%eax
  800c1f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  800c22:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  800c25:	8d 45 18             	lea    0x18(%ebp),%eax
  800c28:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  800c2b:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  800c2f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  800c36:	00 
  800c37:	8d 45 cc             	lea    -0x34(%ebp),%eax
  800c3a:	89 44 24 04          	mov    %eax,0x4(%esp)
  800c3e:	c7 04 24 44 0e 80 00 	movl   $0x800e44,(%esp)
  800c45:	e8 41 1a 00 00       	call   80268b <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  800c4a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800c51:	00 
  800c52:	8b 03                	mov    (%ebx),%eax
  800c54:	8b 40 10             	mov    0x10(%eax),%eax
  800c57:	89 04 24             	mov    %eax,(%esp)
  800c5a:	e8 4e 9d 00 00       	call   80a9ad <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  800c5f:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  800c63:	89 43 10             	mov    %eax,0x10(%ebx)
  800c66:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return err ? -1 : 0;
  800c6b:	85 c0                	test   %eax,%eax
  800c6d:	74 07                	je     800c76 <lwip_setsockopt+0x156>
  800c6f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800c74:	eb 05                	jmp    800c7b <lwip_setsockopt+0x15b>
  800c76:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800c7b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  800c7e:	8b 75 f8             	mov    -0x8(%ebp),%esi
  800c81:	8b 7d fc             	mov    -0x4(%ebp),%edi
  800c84:	89 ec                	mov    %ebp,%esp
  800c86:	5d                   	pop    %ebp
  800c87:	c3                   	ret    
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
  800c88:	b8 16 00 00 00       	mov    $0x16,%eax
  800c8d:	e9 75 ff ff ff       	jmp    800c07 <lwip_setsockopt+0xe7>
  800c92:	b8 61 00 00 00       	mov    $0x61,%eax
  800c97:	e9 6b ff ff ff       	jmp    800c07 <lwip_setsockopt+0xe7>

00800c9c <lwip_getsockopt>:
  return lwip_getaddrname(s, name, namelen, 1);
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  800c9c:	55                   	push   %ebp
  800c9d:	89 e5                	mov    %esp,%ebp
  800c9f:	57                   	push   %edi
  800ca0:	56                   	push   %esi
  800ca1:	53                   	push   %ebx
  800ca2:	83 ec 3c             	sub    $0x3c,%esp
  800ca5:	8b 75 0c             	mov    0xc(%ebp),%esi
  800ca8:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  800cab:	8b 45 08             	mov    0x8(%ebp),%eax
  800cae:	e8 6d fd ff ff       	call   800a20 <get_socket>
  800cb3:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  800cb5:	85 c0                	test   %eax,%eax
  800cb7:	0f 84 5f 01 00 00    	je     800e1c <lwip_getsockopt+0x180>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  800cbd:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  800cc1:	74 04                	je     800cc7 <lwip_getsockopt+0x2b>
  800cc3:	85 ff                	test   %edi,%edi
  800cc5:	75 1b                	jne    800ce2 <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  800cc7:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  800cce:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  800cd5:	00 00 00 
  800cd8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  800cdd:	e9 46 01 00 00       	jmp    800e28 <lwip_getsockopt+0x18c>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  800ce2:	83 fe 06             	cmp    $0x6,%esi
  800ce5:	0f 84 93 00 00 00    	je     800d7e <lwip_getsockopt+0xe2>
  800ceb:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  800cf1:	74 09                	je     800cfc <lwip_getsockopt+0x60>
  800cf3:	85 f6                	test   %esi,%esi
  800cf5:	74 71                	je     800d68 <lwip_getsockopt+0xcc>
  800cf7:	e9 a8 00 00 00       	jmp    800da4 <lwip_getsockopt+0x108>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800cfc:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  800d00:	74 39                	je     800d3b <lwip_getsockopt+0x9f>
  800d02:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  800d06:	7f 12                	jg     800d1a <lwip_getsockopt+0x7e>
  800d08:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  800d0c:	74 2d                	je     800d3b <lwip_getsockopt+0x9f>
  800d0e:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  800d12:	0f 85 8c 00 00 00    	jne    800da4 <lwip_getsockopt+0x108>
  800d18:	eb 21                	jmp    800d3b <lwip_getsockopt+0x9f>
  800d1a:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  800d21:	0f 8c 7d 00 00 00    	jl     800da4 <lwip_getsockopt+0x108>
  800d27:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  800d2e:	7e 0b                	jle    800d3b <lwip_getsockopt+0x9f>
  800d30:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  800d37:	75 6b                	jne    800da4 <lwip_getsockopt+0x108>
  800d39:	eb 0b                	jmp    800d46 <lwip_getsockopt+0xaa>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  800d3b:	83 3f 03             	cmpl   $0x3,(%edi)
  800d3e:	0f 86 ec 00 00 00    	jbe    800e30 <lwip_getsockopt+0x194>
  800d44:	eb 79                	jmp    800dbf <lwip_getsockopt+0x123>
        err = EINVAL;
      }
      break;

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  800d46:	83 3f 04             	cmpl   $0x4,(%edi)
  800d49:	19 c0                	sbb    %eax,%eax
  800d4b:	83 e0 16             	and    $0x16,%eax
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  800d4e:	8b 13                	mov    (%ebx),%edx
  800d50:	83 3a 20             	cmpl   $0x20,(%edx)
  800d53:	0f 85 e1 00 00 00    	jne    800e3a <lwip_getsockopt+0x19e>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  800d59:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  800d5c:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  800d60:	0f 85 d4 00 00 00    	jne    800e3a <lwip_getsockopt+0x19e>
  800d66:	eb 41                	jmp    800da9 <lwip_getsockopt+0x10d>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800d68:	8b 45 10             	mov    0x10(%ebp),%eax
  800d6b:	83 e8 01             	sub    $0x1,%eax
  800d6e:	83 f8 01             	cmp    $0x1,%eax
  800d71:	77 31                	ja     800da4 <lwip_getsockopt+0x108>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  800d73:	83 3f 03             	cmpl   $0x3,(%edi)
  800d76:	0f 86 b4 00 00 00    	jbe    800e30 <lwip_getsockopt+0x194>
  800d7c:	eb 41                	jmp    800dbf <lwip_getsockopt+0x123>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  800d7e:	83 3f 03             	cmpl   $0x3,(%edi)
  800d81:	0f 86 a9 00 00 00    	jbe    800e30 <lwip_getsockopt+0x194>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  800d87:	8b 00                	mov    (%eax),%eax
  800d89:	83 38 10             	cmpl   $0x10,(%eax)
  800d8c:	0f 85 91 00 00 00    	jne    800e23 <lwip_getsockopt+0x187>
  800d92:	8b 55 10             	mov    0x10(%ebp),%edx
  800d95:	83 ea 01             	sub    $0x1,%edx
  800d98:	b8 5c 00 00 00       	mov    $0x5c,%eax
  800d9d:	83 fa 01             	cmp    $0x1,%edx
  800da0:	77 0b                	ja     800dad <lwip_getsockopt+0x111>
  800da2:	eb 1b                	jmp    800dbf <lwip_getsockopt+0x123>
  800da4:	b8 5c 00 00 00       	mov    $0x5c,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  800da9:	84 c0                	test   %al,%al
  800dab:	74 12                	je     800dbf <lwip_getsockopt+0x123>
    sock_set_errno(sock, err);
  800dad:	0f be c0             	movsbl %al,%eax
  800db0:	89 43 10             	mov    %eax,0x10(%ebx)
  800db3:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  800db8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  800dbd:	eb 69                	jmp    800e28 <lwip_getsockopt+0x18c>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  800dbf:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  800dc2:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  800dc5:	8b 45 10             	mov    0x10(%ebp),%eax
  800dc8:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  800dcb:	8b 45 14             	mov    0x14(%ebp),%eax
  800dce:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  800dd1:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  800dd4:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  800dd8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  800ddf:	00 
  800de0:	8d 45 cc             	lea    -0x34(%ebp),%eax
  800de3:	89 44 24 04          	mov    %eax,0x4(%esp)
  800de7:	c7 04 24 4f 0f 80 00 	movl   $0x800f4f,(%esp)
  800dee:	e8 98 18 00 00       	call   80268b <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  800df3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800dfa:	00 
  800dfb:	8b 03                	mov    (%ebx),%eax
  800dfd:	8b 40 10             	mov    0x10(%eax),%eax
  800e00:	89 04 24             	mov    %eax,(%esp)
  800e03:	e8 a5 9b 00 00       	call   80a9ad <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  800e08:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  800e0c:	0f be d0             	movsbl %al,%edx
  800e0f:	89 53 10             	mov    %edx,0x10(%ebx)
  800e12:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  return err ? -1 : 0;
  800e18:	84 c0                	test   %al,%al
  800e1a:	74 07                	je     800e23 <lwip_getsockopt+0x187>
  800e1c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800e21:	eb 05                	jmp    800e28 <lwip_getsockopt+0x18c>
  800e23:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800e28:	83 c4 3c             	add    $0x3c,%esp
  800e2b:	5b                   	pop    %ebx
  800e2c:	5e                   	pop    %esi
  800e2d:	5f                   	pop    %edi
  800e2e:	5d                   	pop    %ebp
  800e2f:	c3                   	ret    
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
  800e30:	b8 16 00 00 00       	mov    $0x16,%eax
  800e35:	e9 73 ff ff ff       	jmp    800dad <lwip_getsockopt+0x111>
  800e3a:	b8 61 00 00 00       	mov    $0x61,%eax
  800e3f:	e9 69 ff ff ff       	jmp    800dad <lwip_getsockopt+0x111>

00800e44 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800e44:	55                   	push   %ebp
  800e45:	89 e5                	mov    %esp,%ebp
  800e47:	53                   	push   %ebx
  800e48:	83 ec 14             	sub    $0x14,%esp
  800e4b:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800e4e:	85 c0                	test   %eax,%eax
  800e50:	75 1c                	jne    800e6e <lwip_setsockopt_internal+0x2a>
  800e52:	c7 44 24 08 fa 11 81 	movl   $0x8111fa,0x8(%esp)
  800e59:	00 
  800e5a:	c7 44 24 04 ae 06 00 	movl   $0x6ae,0x4(%esp)
  800e61:	00 
  800e62:	c7 04 24 06 12 81 00 	movl   $0x811206,(%esp)
  800e69:	e8 7e e3 00 00       	call   80f1ec <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800e6e:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800e70:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800e73:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800e76:	8b 40 08             	mov    0x8(%eax),%eax
  800e79:	83 f8 06             	cmp    $0x6,%eax
  800e7c:	0f 84 86 00 00 00    	je     800f08 <lwip_setsockopt_internal+0xc4>
  800e82:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800e87:	74 0c                	je     800e95 <lwip_setsockopt_internal+0x51>
  800e89:	85 c0                	test   %eax,%eax
  800e8b:	74 59                	je     800ee6 <lwip_setsockopt_internal+0xa2>
  800e8d:	8d 76 00             	lea    0x0(%esi),%esi
  800e90:	e9 a7 00 00 00       	jmp    800f3c <lwip_setsockopt_internal+0xf8>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800e95:	83 f9 20             	cmp    $0x20,%ecx
  800e98:	74 11                	je     800eab <lwip_setsockopt_internal+0x67>
  800e9a:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800ea0:	74 29                	je     800ecb <lwip_setsockopt_internal+0x87>
  800ea2:	83 f9 08             	cmp    $0x8,%ecx
  800ea5:	0f 85 91 00 00 00    	jne    800f3c <lwip_setsockopt_internal+0xf8>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  800eab:	83 3b 00             	cmpl   $0x0,(%ebx)
  800eae:	74 0e                	je     800ebe <lwip_setsockopt_internal+0x7a>
        sock->conn->pcb.ip->so_options |= optname;
  800eb0:	8b 02                	mov    (%edx),%eax
  800eb2:	8b 40 08             	mov    0x8(%eax),%eax
  800eb5:	66 09 48 08          	or     %cx,0x8(%eax)
  800eb9:	e9 7e 00 00 00       	jmp    800f3c <lwip_setsockopt_internal+0xf8>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  800ebe:	8b 02                	mov    (%edx),%eax
  800ec0:	8b 40 08             	mov    0x8(%eax),%eax
  800ec3:	f7 d1                	not    %ecx
  800ec5:	66 21 48 08          	and    %cx,0x8(%eax)
  800ec9:	eb 71                	jmp    800f3c <lwip_setsockopt_internal+0xf8>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  800ecb:	83 3b 00             	cmpl   $0x0,(%ebx)
  800ece:	74 0b                	je     800edb <lwip_setsockopt_internal+0x97>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800ed0:	8b 02                	mov    (%edx),%eax
  800ed2:	8b 40 08             	mov    0x8(%eax),%eax
  800ed5:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800ed9:	eb 61                	jmp    800f3c <lwip_setsockopt_internal+0xf8>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800edb:	8b 02                	mov    (%edx),%eax
  800edd:	8b 40 08             	mov    0x8(%eax),%eax
  800ee0:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800ee4:	eb 56                	jmp    800f3c <lwip_setsockopt_internal+0xf8>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800ee6:	83 f9 01             	cmp    $0x1,%ecx
  800ee9:	74 11                	je     800efc <lwip_setsockopt_internal+0xb8>
  800eeb:	83 f9 02             	cmp    $0x2,%ecx
  800eee:	75 4c                	jne    800f3c <lwip_setsockopt_internal+0xf8>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800ef0:	8b 02                	mov    (%edx),%eax
  800ef2:	8b 40 08             	mov    0x8(%eax),%eax
  800ef5:	8b 0b                	mov    (%ebx),%ecx
  800ef7:	88 48 0b             	mov    %cl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  800efa:	eb 40                	jmp    800f3c <lwip_setsockopt_internal+0xf8>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800efc:	8b 02                	mov    (%edx),%eax
  800efe:	8b 40 08             	mov    0x8(%eax),%eax
  800f01:	8b 0b                	mov    (%ebx),%ecx
  800f03:	88 48 0a             	mov    %cl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
  800f06:	eb 34                	jmp    800f3c <lwip_setsockopt_internal+0xf8>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800f08:	83 f9 01             	cmp    $0x1,%ecx
  800f0b:	74 07                	je     800f14 <lwip_setsockopt_internal+0xd0>
  800f0d:	83 f9 02             	cmp    $0x2,%ecx
  800f10:	75 2a                	jne    800f3c <lwip_setsockopt_internal+0xf8>
  800f12:	eb 1b                	jmp    800f2f <lwip_setsockopt_internal+0xeb>
    case TCP_NODELAY:
      if (*(int*)optval) {
  800f14:	83 3b 00             	cmpl   $0x0,(%ebx)
  800f17:	74 0b                	je     800f24 <lwip_setsockopt_internal+0xe0>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800f19:	8b 02                	mov    (%edx),%eax
  800f1b:	8b 40 08             	mov    0x8(%eax),%eax
  800f1e:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800f22:	eb 18                	jmp    800f3c <lwip_setsockopt_internal+0xf8>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800f24:	8b 02                	mov    (%edx),%eax
  800f26:	8b 40 08             	mov    0x8(%eax),%eax
  800f29:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800f2d:	eb 0d                	jmp    800f3c <lwip_setsockopt_internal+0xf8>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800f2f:	8b 02                	mov    (%edx),%eax
  800f31:	8b 40 08             	mov    0x8(%eax),%eax
  800f34:	8b 0b                	mov    (%ebx),%ecx
  800f36:	89 88 9c 00 00 00    	mov    %ecx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800f3c:	8b 02                	mov    (%edx),%eax
  800f3e:	8b 40 10             	mov    0x10(%eax),%eax
  800f41:	89 04 24             	mov    %eax,(%esp)
  800f44:	e8 28 9d 00 00       	call   80ac71 <sys_sem_signal>
}
  800f49:	83 c4 14             	add    $0x14,%esp
  800f4c:	5b                   	pop    %ebx
  800f4d:	5d                   	pop    %ebp
  800f4e:	c3                   	ret    

00800f4f <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800f4f:	55                   	push   %ebp
  800f50:	89 e5                	mov    %esp,%ebp
  800f52:	53                   	push   %ebx
  800f53:	83 ec 14             	sub    $0x14,%esp
  800f56:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800f59:	85 c0                	test   %eax,%eax
  800f5b:	75 1c                	jne    800f79 <lwip_getsockopt_internal+0x2a>
  800f5d:	c7 44 24 08 fa 11 81 	movl   $0x8111fa,0x8(%esp)
  800f64:	00 
  800f65:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  800f6c:	00 
  800f6d:	c7 04 24 06 12 81 00 	movl   $0x811206,(%esp)
  800f74:	e8 73 e2 00 00       	call   80f1ec <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800f79:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800f7b:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800f7e:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800f81:	8b 40 08             	mov    0x8(%eax),%eax
  800f84:	83 f8 06             	cmp    $0x6,%eax
  800f87:	0f 84 0f 01 00 00    	je     80109c <lwip_getsockopt_internal+0x14d>
  800f8d:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800f92:	74 11                	je     800fa5 <lwip_getsockopt_internal+0x56>
  800f94:	85 c0                	test   %eax,%eax
  800f96:	0f 84 dc 00 00 00    	je     801078 <lwip_getsockopt_internal+0x129>
  800f9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  800fa0:	e9 20 01 00 00       	jmp    8010c5 <lwip_getsockopt_internal+0x176>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800fa5:	83 f9 20             	cmp    $0x20,%ecx
  800fa8:	74 3a                	je     800fe4 <lwip_getsockopt_internal+0x95>
  800faa:	83 f9 20             	cmp    $0x20,%ecx
  800fad:	8d 76 00             	lea    0x0(%esi),%esi
  800fb0:	7f 10                	jg     800fc2 <lwip_getsockopt_internal+0x73>
  800fb2:	83 f9 02             	cmp    $0x2,%ecx
  800fb5:	74 2d                	je     800fe4 <lwip_getsockopt_internal+0x95>
  800fb7:	83 f9 08             	cmp    $0x8,%ecx
  800fba:	0f 85 05 01 00 00    	jne    8010c5 <lwip_getsockopt_internal+0x176>
  800fc0:	eb 22                	jmp    800fe4 <lwip_getsockopt_internal+0x95>
  800fc2:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  800fc8:	74 2c                	je     800ff6 <lwip_getsockopt_internal+0xa7>
  800fca:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800fd0:	0f 84 92 00 00 00    	je     801068 <lwip_getsockopt_internal+0x119>
  800fd6:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  800fdc:	0f 85 e3 00 00 00    	jne    8010c5 <lwip_getsockopt_internal+0x176>
  800fe2:	eb 4f                	jmp    801033 <lwip_getsockopt_internal+0xe4>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800fe4:	8b 02                	mov    (%edx),%eax
  800fe6:	8b 40 08             	mov    0x8(%eax),%eax
  800fe9:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800fed:	21 c1                	and    %eax,%ecx
  800fef:	89 0b                	mov    %ecx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  800ff1:	e9 cf 00 00 00       	jmp    8010c5 <lwip_getsockopt_internal+0x176>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800ff6:	8b 02                	mov    (%edx),%eax
  800ff8:	8b 08                	mov    (%eax),%ecx
  800ffa:	89 c8                	mov    %ecx,%eax
  800ffc:	25 f0 00 00 00       	and    $0xf0,%eax
  801001:	83 f8 20             	cmp    $0x20,%eax
  801004:	74 22                	je     801028 <lwip_getsockopt_internal+0xd9>
  801006:	83 f8 40             	cmp    $0x40,%eax
  801009:	74 12                	je     80101d <lwip_getsockopt_internal+0xce>
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  80100b:	83 f8 10             	cmp    $0x10,%eax
  80100e:	b8 01 00 00 00       	mov    $0x1,%eax
  801013:	0f 44 c8             	cmove  %eax,%ecx
  801016:	89 0b                	mov    %ecx,(%ebx)
  801018:	e9 a8 00 00 00       	jmp    8010c5 <lwip_getsockopt_internal+0x176>
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  80101d:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  801023:	e9 9d 00 00 00       	jmp    8010c5 <lwip_getsockopt_internal+0x176>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  801028:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  80102e:	e9 92 00 00 00       	jmp    8010c5 <lwip_getsockopt_internal+0x176>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  801033:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  801037:	75 21                	jne    80105a <lwip_getsockopt_internal+0x10b>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  801039:	8b 02                	mov    (%edx),%eax
  80103b:	0f be 48 0c          	movsbl 0xc(%eax),%ecx
  80103f:	f7 d9                	neg    %ecx
  801041:	b8 05 00 00 00       	mov    $0x5,%eax
  801046:	83 f9 0e             	cmp    $0xe,%ecx
  801049:	77 07                	ja     801052 <lwip_getsockopt_internal+0x103>
  80104b:	8b 04 8d e0 12 81 00 	mov    0x8112e0(,%ecx,4),%eax
  801052:	89 42 10             	mov    %eax,0x10(%edx)
  801055:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
      } 
      *(int *)optval = sock->err;
  80105a:	8b 42 10             	mov    0x10(%edx),%eax
  80105d:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  80105f:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  801066:	eb 5d                	jmp    8010c5 <lwip_getsockopt_internal+0x176>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  801068:	8b 02                	mov    (%edx),%eax
  80106a:	8b 40 08             	mov    0x8(%eax),%eax
  80106d:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  801071:	83 e0 01             	and    $0x1,%eax
  801074:	89 03                	mov    %eax,(%ebx)
  801076:	eb 4d                	jmp    8010c5 <lwip_getsockopt_internal+0x176>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801078:	83 f9 01             	cmp    $0x1,%ecx
  80107b:	74 12                	je     80108f <lwip_getsockopt_internal+0x140>
  80107d:	83 f9 02             	cmp    $0x2,%ecx
  801080:	75 43                	jne    8010c5 <lwip_getsockopt_internal+0x176>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  801082:	8b 02                	mov    (%edx),%eax
  801084:	8b 40 08             	mov    0x8(%eax),%eax
  801087:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  80108b:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  80108d:	eb 36                	jmp    8010c5 <lwip_getsockopt_internal+0x176>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  80108f:	8b 02                	mov    (%edx),%eax
  801091:	8b 40 08             	mov    0x8(%eax),%eax
  801094:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  801098:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
  80109a:	eb 29                	jmp    8010c5 <lwip_getsockopt_internal+0x176>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  80109c:	83 f9 01             	cmp    $0x1,%ecx
  80109f:	74 07                	je     8010a8 <lwip_getsockopt_internal+0x159>
  8010a1:	83 f9 02             	cmp    $0x2,%ecx
  8010a4:	75 1f                	jne    8010c5 <lwip_getsockopt_internal+0x176>
  8010a6:	eb 10                	jmp    8010b8 <lwip_getsockopt_internal+0x169>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  8010a8:	8b 02                	mov    (%edx),%eax
  8010aa:	8b 40 08             	mov    0x8(%eax),%eax
  8010ad:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  8010b1:	83 e0 40             	and    $0x40,%eax
  8010b4:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  8010b6:	eb 0d                	jmp    8010c5 <lwip_getsockopt_internal+0x176>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  8010b8:	8b 02                	mov    (%edx),%eax
  8010ba:	8b 40 08             	mov    0x8(%eax),%eax
  8010bd:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  8010c3:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  8010c5:	8b 02                	mov    (%edx),%eax
  8010c7:	8b 40 10             	mov    0x10(%eax),%eax
  8010ca:	89 04 24             	mov    %eax,(%esp)
  8010cd:	e8 9f 9b 00 00       	call   80ac71 <sys_sem_signal>
}
  8010d2:	83 c4 14             	add    $0x14,%esp
  8010d5:	5b                   	pop    %ebx
  8010d6:	5d                   	pop    %ebp
  8010d7:	c3                   	ret    

008010d8 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  8010d8:	55                   	push   %ebp
  8010d9:	89 e5                	mov    %esp,%ebp
  8010db:	57                   	push   %edi
  8010dc:	56                   	push   %esi
  8010dd:	53                   	push   %ebx
  8010de:	83 ec 3c             	sub    $0x3c,%esp
  8010e1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8010e4:	89 55 d0             	mov    %edx,-0x30(%ebp)
  8010e7:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  8010ea:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8010f1:	00 
  8010f2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8010f9:	00 
  8010fa:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8010fd:	89 04 24             	mov    %eax,(%esp)
  801100:	e8 4b e9 00 00       	call   80fa50 <memset>
  FD_ZERO(&lwriteset);
  801105:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80110c:	00 
  80110d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801114:	00 
  801115:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801118:	89 04 24             	mov    %eax,(%esp)
  80111b:	e8 30 e9 00 00       	call   80fa50 <memset>
  FD_ZERO(&lexceptset);
  801120:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801127:	00 
  801128:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80112f:	00 
  801130:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801133:	89 04 24             	mov    %eax,(%esp)
  801136:	e8 15 e9 00 00       	call   80fa50 <memset>
  80113b:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  801142:	bb 00 00 00 00       	mov    $0x0,%ebx
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  801147:	eb 77                	jmp    8011c0 <lwip_selscan+0xe8>
    if (FD_ISSET(i, readset)) {
  801149:	8d 73 07             	lea    0x7(%ebx),%esi
  80114c:	85 db                	test   %ebx,%ebx
  80114e:	0f 49 f3             	cmovns %ebx,%esi
  801151:	c1 fe 03             	sar    $0x3,%esi
  801154:	89 df                	mov    %ebx,%edi
  801156:	83 e7 07             	and    $0x7,%edi
  801159:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80115c:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  801160:	0f a3 f8             	bt     %edi,%eax
  801163:	73 29                	jae    80118e <lwip_selscan+0xb6>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  801165:	89 d8                	mov    %ebx,%eax
  801167:	e8 b4 f8 ff ff       	call   800a20 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  80116c:	85 c0                	test   %eax,%eax
  80116e:	74 1e                	je     80118e <lwip_selscan+0xb6>
  801170:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  801174:	75 07                	jne    80117d <lwip_selscan+0xa5>
  801176:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  80117b:	74 11                	je     80118e <lwip_selscan+0xb6>
        FD_SET(i, &lreadset);
  80117d:	b8 01 00 00 00       	mov    $0x1,%eax
  801182:	89 f9                	mov    %edi,%ecx
  801184:	d3 e0                	shl    %cl,%eax
  801186:	08 44 35 e4          	or     %al,-0x1c(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  80118a:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  80118e:	8b 55 cc             	mov    -0x34(%ebp),%edx
  801191:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  801195:	0f a3 f8             	bt     %edi,%eax
  801198:	73 23                	jae    8011bd <lwip_selscan+0xe5>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  80119a:	89 d8                	mov    %ebx,%eax
  80119c:	e8 7f f8 ff ff       	call   800a20 <get_socket>
      if (p_sock && p_sock->sendevent) {
  8011a1:	85 c0                	test   %eax,%eax
  8011a3:	74 18                	je     8011bd <lwip_selscan+0xe5>
  8011a5:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  8011aa:	74 11                	je     8011bd <lwip_selscan+0xe5>
        FD_SET(i, &lwriteset);
  8011ac:	b8 01 00 00 00       	mov    $0x1,%eax
  8011b1:	89 f9                	mov    %edi,%ecx
  8011b3:	d3 e0                	shl    %cl,%eax
  8011b5:	08 44 35 e0          	or     %al,-0x20(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  8011b9:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  8011bd:	83 c3 01             	add    $0x1,%ebx
  8011c0:	3b 5d d4             	cmp    -0x2c(%ebp),%ebx
  8011c3:	7c 84                	jl     801149 <lwip_selscan+0x71>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  8011c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8011c8:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8011cb:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  8011cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8011d0:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  8011d3:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  8011d5:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8011dc:	00 
  8011dd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8011e4:	00 
  8011e5:	8b 45 08             	mov    0x8(%ebp),%eax
  8011e8:	89 04 24             	mov    %eax,(%esp)
  8011eb:	e8 60 e8 00 00       	call   80fa50 <memset>
  
  return nready;
}
  8011f0:	8b 45 c8             	mov    -0x38(%ebp),%eax
  8011f3:	83 c4 3c             	add    $0x3c,%esp
  8011f6:	5b                   	pop    %ebx
  8011f7:	5e                   	pop    %esi
  8011f8:	5f                   	pop    %edi
  8011f9:	5d                   	pop    %ebp
  8011fa:	c3                   	ret    

008011fb <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  8011fb:	55                   	push   %ebp
  8011fc:	89 e5                	mov    %esp,%ebp
  8011fe:	83 ec 58             	sub    $0x58,%esp
  801201:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801204:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801207:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80120a:	89 d7                	mov    %edx,%edi
  80120c:	89 ce                	mov    %ecx,%esi
  80120e:	0f b6 55 08          	movzbl 0x8(%ebp),%edx
  801212:	88 55 c7             	mov    %dl,-0x39(%ebp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  801215:	e8 06 f8 ff ff       	call   800a20 <get_socket>
  80121a:	89 c3                	mov    %eax,%ebx
  if (!sock)
  80121c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801221:	85 db                	test   %ebx,%ebx
  801223:	0f 84 8f 00 00 00    	je     8012b8 <lwip_getaddrname+0xbd>
    return -1;

  memset(&sin, 0, sizeof(sin));
  801229:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  801230:	00 
  801231:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801238:	00 
  801239:	8d 45 d8             	lea    -0x28(%ebp),%eax
  80123c:	89 04 24             	mov    %eax,(%esp)
  80123f:	e8 0c e8 00 00       	call   80fa50 <memset>
  sin.sin_len = sizeof(sin);
  801244:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  801248:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  80124c:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
  801250:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801254:	8d 45 da             	lea    -0x26(%ebp),%eax
  801257:	89 44 24 08          	mov    %eax,0x8(%esp)
  80125b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80125e:	89 44 24 04          	mov    %eax,0x4(%esp)
  801262:	8b 03                	mov    (%ebx),%eax
  801264:	89 04 24             	mov    %eax,(%esp)
  801267:	e8 73 a6 00 00       	call   80b8df <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  80126c:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  801270:	89 04 24             	mov    %eax,(%esp)
  801273:	e8 e7 6b 00 00       	call   807e5f <htons>
  801278:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  80127c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80127f:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  801282:	83 3e 10             	cmpl   $0x10,(%esi)
  801285:	76 06                	jbe    80128d <lwip_getaddrname+0x92>
    *namelen = sizeof(sin);
  801287:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  80128d:	8b 06                	mov    (%esi),%eax
  80128f:	89 44 24 08          	mov    %eax,0x8(%esp)
  801293:	8d 45 d8             	lea    -0x28(%ebp),%eax
  801296:	89 44 24 04          	mov    %eax,0x4(%esp)
  80129a:	89 3c 24             	mov    %edi,(%esp)
  80129d:	e8 89 e8 00 00       	call   80fb2b <memcpy>
  sock_set_errno(sock, 0);
  8012a2:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8012a9:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8012b0:	00 00 00 
  8012b3:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  8012b8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8012bb:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8012be:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8012c1:	89 ec                	mov    %ebp,%esp
  8012c3:	5d                   	pop    %ebp
  8012c4:	c3                   	ret    

008012c5 <lwip_getsockname>:
  return lwip_getaddrname(s, name, namelen, 0);
}

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  8012c5:	55                   	push   %ebp
  8012c6:	89 e5                	mov    %esp,%ebp
  8012c8:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  8012cb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8012d2:	8b 4d 10             	mov    0x10(%ebp),%ecx
  8012d5:	8b 55 0c             	mov    0xc(%ebp),%edx
  8012d8:	8b 45 08             	mov    0x8(%ebp),%eax
  8012db:	e8 1b ff ff ff       	call   8011fb <lwip_getaddrname>
}
  8012e0:	c9                   	leave  
  8012e1:	c3                   	ret    

008012e2 <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  8012e2:	55                   	push   %ebp
  8012e3:	89 e5                	mov    %esp,%ebp
  8012e5:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  8012e8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8012ef:	8b 4d 10             	mov    0x10(%ebp),%ecx
  8012f2:	8b 55 0c             	mov    0xc(%ebp),%edx
  8012f5:	8b 45 08             	mov    0x8(%ebp),%eax
  8012f8:	e8 fe fe ff ff       	call   8011fb <lwip_getaddrname>
}
  8012fd:	c9                   	leave  
  8012fe:	c3                   	ret    

008012ff <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  8012ff:	55                   	push   %ebp
  801300:	89 e5                	mov    %esp,%ebp
  801302:	56                   	push   %esi
  801303:	53                   	push   %ebx
  801304:	83 ec 10             	sub    $0x10,%esp
  801307:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  801309:	a1 e4 52 81 00       	mov    0x8152e4,%eax
  80130e:	89 04 24             	mov    %eax,(%esp)
  801311:	e8 c3 45 00 00       	call   8058d9 <sys_sem_wait>
  801316:	b8 60 50 81 00       	mov    $0x815060,%eax
  80131b:	bb 00 00 00 00       	mov    $0x0,%ebx

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
    if (!sockets[i].conn) {
  801320:	83 38 00             	cmpl   $0x0,(%eax)
  801323:	75 50                	jne    801375 <alloc_socket+0x76>
      sockets[i].conn       = newconn;
  801325:	ba 60 50 81 00       	mov    $0x815060,%edx
  80132a:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
  801331:	8d 0c 18             	lea    (%eax,%ebx,1),%ecx
  801334:	89 34 8a             	mov    %esi,(%edx,%ecx,4)
      sockets[i].lastdata   = NULL;
  801337:	c7 44 8a 04 00 00 00 	movl   $0x0,0x4(%edx,%ecx,4)
  80133e:	00 
      sockets[i].lastoffset = 0;
  80133f:	66 c7 44 8a 08 00 00 	movw   $0x0,0x8(%edx,%ecx,4)
      sockets[i].rcvevent   = 0;
  801346:	66 c7 44 8a 0a 00 00 	movw   $0x0,0xa(%edx,%ecx,4)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  80134d:	66 c7 44 8a 0c 01 00 	movw   $0x1,0xc(%edx,%ecx,4)
      sockets[i].flags      = 0;
  801354:	66 c7 44 8a 0e 00 00 	movw   $0x0,0xe(%edx,%ecx,4)
      sockets[i].err        = 0;
  80135b:	c7 04 8d 70 50 81 00 	movl   $0x0,0x815070(,%ecx,4)
  801362:	00 00 00 00 
      sys_sem_signal(socksem);
  801366:	a1 e4 52 81 00       	mov    0x8152e4,%eax
  80136b:	89 04 24             	mov    %eax,(%esp)
  80136e:	e8 fe 98 00 00       	call   80ac71 <sys_sem_signal>
      return i;
  801373:	eb 1d                	jmp    801392 <alloc_socket+0x93>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  801375:	83 c3 01             	add    $0x1,%ebx
  801378:	83 c0 14             	add    $0x14,%eax
  80137b:	83 fb 20             	cmp    $0x20,%ebx
  80137e:	75 a0                	jne    801320 <alloc_socket+0x21>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  801380:	a1 e4 52 81 00       	mov    0x8152e4,%eax
  801385:	89 04 24             	mov    %eax,(%esp)
  801388:	e8 e4 98 00 00       	call   80ac71 <sys_sem_signal>
  80138d:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return -1;
}
  801392:	89 d8                	mov    %ebx,%eax
  801394:	83 c4 10             	add    $0x10,%esp
  801397:	5b                   	pop    %ebx
  801398:	5e                   	pop    %esi
  801399:	5d                   	pop    %ebp
  80139a:	c3                   	ret    

0080139b <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  80139b:	55                   	push   %ebp
  80139c:	89 e5                	mov    %esp,%ebp
  80139e:	57                   	push   %edi
  80139f:	56                   	push   %esi
  8013a0:	53                   	push   %ebx
  8013a1:	83 ec 2c             	sub    $0x2c,%esp
  8013a4:	8b 75 08             	mov    0x8(%ebp),%esi
  8013a7:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  8013aa:	85 f6                	test   %esi,%esi
  8013ac:	0f 84 68 01 00 00    	je     80151a <event_callback+0x17f>
    s = conn->socket;
  8013b2:	8b 5e 1c             	mov    0x1c(%esi),%ebx
    if (s < 0) {
  8013b5:	85 db                	test   %ebx,%ebx
  8013b7:	79 3d                	jns    8013f6 <event_callback+0x5b>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  8013b9:	a1 e4 52 81 00       	mov    0x8152e4,%eax
  8013be:	89 04 24             	mov    %eax,(%esp)
  8013c1:	e8 13 45 00 00       	call   8058d9 <sys_sem_wait>
      if (conn->socket < 0) {
  8013c6:	8b 46 1c             	mov    0x1c(%esi),%eax
  8013c9:	85 c0                	test   %eax,%eax
  8013cb:	79 1c                	jns    8013e9 <event_callback+0x4e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  8013cd:	85 ff                	test   %edi,%edi
  8013cf:	75 06                	jne    8013d7 <event_callback+0x3c>
          conn->socket--;
  8013d1:	83 e8 01             	sub    $0x1,%eax
  8013d4:	89 46 1c             	mov    %eax,0x1c(%esi)
        }
        sys_sem_signal(socksem);
  8013d7:	a1 e4 52 81 00       	mov    0x8152e4,%eax
  8013dc:	89 04 24             	mov    %eax,(%esp)
  8013df:	e8 8d 98 00 00       	call   80ac71 <sys_sem_signal>
        return;
  8013e4:	e9 31 01 00 00       	jmp    80151a <event_callback+0x17f>
      }
      sys_sem_signal(socksem);
  8013e9:	a1 e4 52 81 00       	mov    0x8152e4,%eax
  8013ee:	89 04 24             	mov    %eax,(%esp)
  8013f1:	e8 7b 98 00 00       	call   80ac71 <sys_sem_signal>
    }

    sock = get_socket(s);
  8013f6:	89 d8                	mov    %ebx,%eax
  8013f8:	e8 23 f6 ff ff       	call   800a20 <get_socket>
  8013fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  801400:	85 c0                	test   %eax,%eax
  801402:	0f 84 12 01 00 00    	je     80151a <event_callback+0x17f>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  801408:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  80140d:	89 04 24             	mov    %eax,(%esp)
  801410:	e8 c4 44 00 00       	call   8058d9 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  801415:	83 ff 01             	cmp    $0x1,%edi
  801418:	74 1b                	je     801435 <event_callback+0x9a>
  80141a:	83 ff 01             	cmp    $0x1,%edi
  80141d:	72 0c                	jb     80142b <event_callback+0x90>
  80141f:	83 ff 02             	cmp    $0x2,%edi
  801422:	74 1b                	je     80143f <event_callback+0xa4>
  801424:	83 ff 03             	cmp    $0x3,%edi
  801427:	75 2c                	jne    801455 <event_callback+0xba>
  801429:	eb 1f                	jmp    80144a <event_callback+0xaf>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  80142b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80142e:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  801433:	eb 3c                	jmp    801471 <event_callback+0xd6>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  801435:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801438:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  80143d:	eb 32                	jmp    801471 <event_callback+0xd6>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  80143f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801442:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  801448:	eb 27                	jmp    801471 <event_callback+0xd6>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  80144a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80144d:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  801453:	eb 1c                	jmp    801471 <event_callback+0xd6>
    default:
      LWIP_ASSERT("unknown event", 0);
  801455:	c7 44 24 08 1d 12 81 	movl   $0x81121d,0x8(%esp)
  80145c:	00 
  80145d:	c7 44 24 04 17 04 00 	movl   $0x417,0x4(%esp)
  801464:	00 
  801465:	c7 04 24 06 12 81 00 	movl   $0x811206,(%esp)
  80146c:	e8 7b dd 00 00       	call   80f1ec <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  801471:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  801476:	89 04 24             	mov    %eax,(%esp)
  801479:	e8 f3 97 00 00       	call   80ac71 <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  80147e:	8d 73 07             	lea    0x7(%ebx),%esi
  801481:	85 db                	test   %ebx,%ebx
  801483:	0f 49 f3             	cmovns %ebx,%esi
  801486:	c1 fe 03             	sar    $0x3,%esi
  801489:	89 d9                	mov    %ebx,%ecx
  80148b:	83 e1 07             	and    $0x7,%ecx
  80148e:	b8 01 00 00 00       	mov    $0x1,%eax
  801493:	89 c7                	mov    %eax,%edi
  801495:	d3 e7                	shl    %cl,%edi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  801497:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  80149c:	89 04 24             	mov    %eax,(%esp)
  80149f:	e8 35 44 00 00       	call   8058d9 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  8014a4:	8b 1d e0 52 81 00    	mov    0x8152e0,%ebx
  8014aa:	eb 3a                	jmp    8014e6 <event_callback+0x14b>
      if (scb->sem_signalled == 0) {
  8014ac:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8014b0:	75 32                	jne    8014e4 <event_callback+0x149>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  8014b2:	8b 43 04             	mov    0x4(%ebx),%eax
  8014b5:	85 c0                	test   %eax,%eax
  8014b7:	74 12                	je     8014cb <event_callback+0x130>
  8014b9:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  8014bd:	85 f8                	test   %edi,%eax
  8014bf:	74 0a                	je     8014cb <event_callback+0x130>
          if (sock->rcvevent)
  8014c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8014c4:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8014c9:	75 21                	jne    8014ec <event_callback+0x151>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  8014cb:	8b 43 08             	mov    0x8(%ebx),%eax
  8014ce:	85 c0                	test   %eax,%eax
  8014d0:	74 12                	je     8014e4 <event_callback+0x149>
  8014d2:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  8014d6:	85 f8                	test   %edi,%eax
  8014d8:	74 0a                	je     8014e4 <event_callback+0x149>
          if (sock->sendevent)
  8014da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8014dd:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  8014e2:	75 08                	jne    8014ec <event_callback+0x151>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  8014e4:	8b 1b                	mov    (%ebx),%ebx
  8014e6:	85 db                	test   %ebx,%ebx
  8014e8:	75 c2                	jne    8014ac <event_callback+0x111>
  8014ea:	eb 21                	jmp    80150d <event_callback+0x172>
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
      scb->sem_signalled = 1;
  8014ec:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  8014f3:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  8014f8:	89 04 24             	mov    %eax,(%esp)
  8014fb:	e8 71 97 00 00       	call   80ac71 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  801500:	8b 43 14             	mov    0x14(%ebx),%eax
  801503:	89 04 24             	mov    %eax,(%esp)
  801506:	e8 66 97 00 00       	call   80ac71 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  80150b:	eb 8a                	jmp    801497 <event_callback+0xfc>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  80150d:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  801512:	89 04 24             	mov    %eax,(%esp)
  801515:	e8 57 97 00 00       	call   80ac71 <sys_sem_signal>
      break;
    }
  }
}
  80151a:	83 c4 2c             	add    $0x2c,%esp
  80151d:	5b                   	pop    %ebx
  80151e:	5e                   	pop    %esi
  80151f:	5f                   	pop    %edi
  801520:	5d                   	pop    %ebp
  801521:	c3                   	ret    

00801522 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  801522:	55                   	push   %ebp
  801523:	89 e5                	mov    %esp,%ebp
  801525:	83 ec 18             	sub    $0x18,%esp
  socksem   = sys_sem_new(1);
  801528:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80152f:	e8 9b 95 00 00       	call   80aacf <sys_sem_new>
  801534:	a3 e4 52 81 00       	mov    %eax,0x8152e4
  selectsem = sys_sem_new(1);
  801539:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801540:	e8 8a 95 00 00       	call   80aacf <sys_sem_new>
  801545:	a3 e8 52 81 00       	mov    %eax,0x8152e8
}
  80154a:	c9                   	leave  
  80154b:	c3                   	ret    

0080154c <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  80154c:	55                   	push   %ebp
  80154d:	89 e5                	mov    %esp,%ebp
  80154f:	57                   	push   %edi
  801550:	56                   	push   %esi
  801551:	53                   	push   %ebx
  801552:	83 ec 5c             	sub    $0x5c,%esp
  801555:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801558:	8b 75 10             	mov    0x10(%ebp),%esi
  80155b:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  80155e:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  801565:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  801568:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  80156b:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  80156e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  801575:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  80157a:	89 04 24             	mov    %eax,(%esp)
  80157d:	e8 57 43 00 00       	call   8058d9 <sys_sem_wait>

  if (readset)
  801582:	85 ff                	test   %edi,%edi
  801584:	74 07                	je     80158d <lwip_select+0x41>
    lreadset = *readset;
  801586:	8b 07                	mov    (%edi),%eax
  801588:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80158b:	eb 1b                	jmp    8015a8 <lwip_select+0x5c>
  else
    FD_ZERO(&lreadset);
  80158d:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801594:	00 
  801595:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80159c:	00 
  80159d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8015a0:	89 04 24             	mov    %eax,(%esp)
  8015a3:	e8 a8 e4 00 00       	call   80fa50 <memset>
  if (writeset)
  8015a8:	85 f6                	test   %esi,%esi
  8015aa:	74 07                	je     8015b3 <lwip_select+0x67>
    lwriteset = *writeset;
  8015ac:	8b 06                	mov    (%esi),%eax
  8015ae:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8015b1:	eb 1b                	jmp    8015ce <lwip_select+0x82>
  else
    FD_ZERO(&lwriteset);
  8015b3:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8015ba:	00 
  8015bb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8015c2:	00 
  8015c3:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8015c6:	89 04 24             	mov    %eax,(%esp)
  8015c9:	e8 82 e4 00 00       	call   80fa50 <memset>
  if (exceptset)
  8015ce:	85 db                	test   %ebx,%ebx
  8015d0:	74 07                	je     8015d9 <lwip_select+0x8d>
    lexceptset = *exceptset;
  8015d2:	8b 03                	mov    (%ebx),%eax
  8015d4:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8015d7:	eb 1b                	jmp    8015f4 <lwip_select+0xa8>
  else
    FD_ZERO(&lexceptset);
  8015d9:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8015e0:	00 
  8015e1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8015e8:	00 
  8015e9:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8015ec:	89 04 24             	mov    %eax,(%esp)
  8015ef:	e8 5c e4 00 00       	call   80fa50 <memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8015f4:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  8015f7:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8015fa:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8015fd:	89 04 24             	mov    %eax,(%esp)
  801600:	8b 45 08             	mov    0x8(%ebp),%eax
  801603:	e8 d0 fa ff ff       	call   8010d8 <lwip_selscan>
  801608:	89 45 b0             	mov    %eax,-0x50(%ebp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  80160b:	85 c0                	test   %eax,%eax
  80160d:	0f 85 18 02 00 00    	jne    80182b <lwip_select+0x2df>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  801613:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801617:	0f 84 86 00 00 00    	je     8016a3 <lwip_select+0x157>
  80161d:	8b 45 18             	mov    0x18(%ebp),%eax
  801620:	83 38 00             	cmpl   $0x0,(%eax)
  801623:	0f 85 3f 02 00 00    	jne    801868 <lwip_select+0x31c>
  801629:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  80162d:	0f 85 35 02 00 00    	jne    801868 <lwip_select+0x31c>
      sys_sem_signal(selectsem);
  801633:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  801638:	89 04 24             	mov    %eax,(%esp)
  80163b:	e8 31 96 00 00       	call   80ac71 <sys_sem_signal>
      if (readset)
  801640:	85 ff                	test   %edi,%edi
  801642:	74 18                	je     80165c <lwip_select+0x110>
        FD_ZERO(readset);
  801644:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80164b:	00 
  80164c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801653:	00 
  801654:	89 3c 24             	mov    %edi,(%esp)
  801657:	e8 f4 e3 00 00       	call   80fa50 <memset>
      if (writeset)
  80165c:	85 f6                	test   %esi,%esi
  80165e:	74 18                	je     801678 <lwip_select+0x12c>
        FD_ZERO(writeset);
  801660:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801667:	00 
  801668:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80166f:	00 
  801670:	89 34 24             	mov    %esi,(%esp)
  801673:	e8 d8 e3 00 00       	call   80fa50 <memset>
      if (exceptset)
  801678:	85 db                	test   %ebx,%ebx
  80167a:	74 18                	je     801694 <lwip_select+0x148>
        FD_ZERO(exceptset);
  80167c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801683:	00 
  801684:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80168b:	00 
  80168c:	89 1c 24             	mov    %ebx,(%esp)
  80168f:	e8 bc e3 00 00       	call   80fa50 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  801694:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80169b:	00 00 00 
  
      return 0;
  80169e:	e9 ba 01 00 00       	jmp    80185d <lwip_select+0x311>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  8016a3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8016aa:	e8 20 94 00 00       	call   80aacf <sys_sem_new>
  8016af:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  8016b2:	a1 e0 52 81 00       	mov    0x8152e0,%eax
  8016b7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  8016ba:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  8016bd:	a3 e0 52 81 00       	mov    %eax,0x8152e0
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  8016c2:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  8016c7:	89 04 24             	mov    %eax,(%esp)
  8016ca:	e8 a2 95 00 00       	call   80ac71 <sys_sem_signal>
  8016cf:	ba 00 00 00 00       	mov    $0x0,%edx
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  8016d4:	89 54 24 04          	mov    %edx,0x4(%esp)
  8016d8:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8016db:	89 04 24             	mov    %eax,(%esp)
  8016de:	e8 83 42 00 00       	call   805966 <sys_sem_wait_timeout>
  8016e3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  8016e6:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  8016eb:	89 04 24             	mov    %eax,(%esp)
  8016ee:	e8 e6 41 00 00       	call   8058d9 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  8016f3:	a1 e0 52 81 00       	mov    0x8152e0,%eax
  8016f8:	8d 55 c4             	lea    -0x3c(%ebp),%edx
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  8016fb:	8d 4d c4             	lea    -0x3c(%ebp),%ecx
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
  8016fe:	39 d0                	cmp    %edx,%eax
  801700:	75 19                	jne    80171b <lwip_select+0x1cf>
      select_cb_list = select_cb.next;
  801702:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801705:	a3 e0 52 81 00       	mov    %eax,0x8152e0
  80170a:	eb 13                	jmp    80171f <lwip_select+0x1d3>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  80170c:	8b 10                	mov    (%eax),%edx
  80170e:	39 ca                	cmp    %ecx,%edx
  801710:	75 07                	jne    801719 <lwip_select+0x1cd>
          p_selcb->next = select_cb.next;
  801712:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801715:	89 10                	mov    %edx,(%eax)
          break;
  801717:	eb 06                	jmp    80171f <lwip_select+0x1d3>
  801719:	89 d0                	mov    %edx,%eax
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  80171b:	85 c0                	test   %eax,%eax
  80171d:	75 ed                	jne    80170c <lwip_select+0x1c0>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  80171f:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  801724:	89 04 24             	mov    %eax,(%esp)
  801727:	e8 45 95 00 00       	call   80ac71 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  80172c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80172f:	89 04 24             	mov    %eax,(%esp)
  801732:	e8 32 8f 00 00       	call   80a669 <sys_sem_free>
    if (i == 0)  {
  801737:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  80173b:	75 63                	jne    8017a0 <lwip_select+0x254>
      /* Timeout */
      if (readset)
  80173d:	85 ff                	test   %edi,%edi
  80173f:	74 18                	je     801759 <lwip_select+0x20d>
        FD_ZERO(readset);
  801741:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801748:	00 
  801749:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801750:	00 
  801751:	89 3c 24             	mov    %edi,(%esp)
  801754:	e8 f7 e2 00 00       	call   80fa50 <memset>
      if (writeset)
  801759:	85 f6                	test   %esi,%esi
  80175b:	74 18                	je     801775 <lwip_select+0x229>
        FD_ZERO(writeset);
  80175d:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801764:	00 
  801765:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80176c:	00 
  80176d:	89 34 24             	mov    %esi,(%esp)
  801770:	e8 db e2 00 00       	call   80fa50 <memset>
      if (exceptset)
  801775:	85 db                	test   %ebx,%ebx
  801777:	74 18                	je     801791 <lwip_select+0x245>
        FD_ZERO(exceptset);
  801779:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801780:	00 
  801781:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801788:	00 
  801789:	89 1c 24             	mov    %ebx,(%esp)
  80178c:	e8 bf e2 00 00       	call   80fa50 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  801791:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801798:	00 00 00 
  
      return 0;
  80179b:	e9 bd 00 00 00       	jmp    80185d <lwip_select+0x311>
    }
    
    if (readset)
  8017a0:	85 ff                	test   %edi,%edi
  8017a2:	74 07                	je     8017ab <lwip_select+0x25f>
      lreadset = *readset;
  8017a4:	8b 07                	mov    (%edi),%eax
  8017a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8017a9:	eb 1b                	jmp    8017c6 <lwip_select+0x27a>
    else
      FD_ZERO(&lreadset);
  8017ab:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8017b2:	00 
  8017b3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8017ba:	00 
  8017bb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8017be:	89 04 24             	mov    %eax,(%esp)
  8017c1:	e8 8a e2 00 00       	call   80fa50 <memset>
    if (writeset)
  8017c6:	85 f6                	test   %esi,%esi
  8017c8:	74 07                	je     8017d1 <lwip_select+0x285>
      lwriteset = *writeset;
  8017ca:	8b 06                	mov    (%esi),%eax
  8017cc:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8017cf:	eb 1b                	jmp    8017ec <lwip_select+0x2a0>
    else
      FD_ZERO(&lwriteset);
  8017d1:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8017d8:	00 
  8017d9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8017e0:	00 
  8017e1:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8017e4:	89 04 24             	mov    %eax,(%esp)
  8017e7:	e8 64 e2 00 00       	call   80fa50 <memset>
    if (exceptset)
  8017ec:	85 db                	test   %ebx,%ebx
  8017ee:	74 07                	je     8017f7 <lwip_select+0x2ab>
      lexceptset = *exceptset;
  8017f0:	8b 03                	mov    (%ebx),%eax
  8017f2:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8017f5:	eb 1b                	jmp    801812 <lwip_select+0x2c6>
    else
      FD_ZERO(&lexceptset);
  8017f7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8017fe:	00 
  8017ff:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801806:	00 
  801807:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80180a:	89 04 24             	mov    %eax,(%esp)
  80180d:	e8 3e e2 00 00       	call   80fa50 <memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801812:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801815:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801818:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80181b:	89 04 24             	mov    %eax,(%esp)
  80181e:	8b 45 08             	mov    0x8(%ebp),%eax
  801821:	e8 b2 f8 ff ff       	call   8010d8 <lwip_selscan>
  801826:	89 45 b0             	mov    %eax,-0x50(%ebp)
  801829:	eb 0d                	jmp    801838 <lwip_select+0x2ec>
  } else
    sys_sem_signal(selectsem);
  80182b:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  801830:	89 04 24             	mov    %eax,(%esp)
  801833:	e8 39 94 00 00       	call   80ac71 <sys_sem_signal>
  
  if (readset)
  801838:	85 ff                	test   %edi,%edi
  80183a:	74 05                	je     801841 <lwip_select+0x2f5>
    *readset = lreadset;
  80183c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80183f:	89 07                	mov    %eax,(%edi)
  if (writeset)
  801841:	85 f6                	test   %esi,%esi
  801843:	74 05                	je     80184a <lwip_select+0x2fe>
    *writeset = lwriteset;
  801845:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801848:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  80184a:	85 db                	test   %ebx,%ebx
  80184c:	74 05                	je     801853 <lwip_select+0x307>
    *exceptset = lexceptset;
  80184e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801851:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  801853:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80185a:	00 00 00 
  
  return nready;
}
  80185d:	8b 45 b0             	mov    -0x50(%ebp),%eax
  801860:	83 c4 5c             	add    $0x5c,%esp
  801863:	5b                   	pop    %ebx
  801864:	5e                   	pop    %esi
  801865:	5f                   	pop    %edi
  801866:	5d                   	pop    %ebp
  801867:	c3                   	ret    
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801868:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80186f:	e8 5b 92 00 00       	call   80aacf <sys_sem_new>
  801874:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801877:	a1 e0 52 81 00       	mov    0x8152e0,%eax
  80187c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  80187f:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801882:	a3 e0 52 81 00       	mov    %eax,0x8152e0
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801887:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  80188c:	89 04 24             	mov    %eax,(%esp)
  80188f:	e8 dd 93 00 00       	call   80ac71 <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801894:	8b 45 18             	mov    0x18(%ebp),%eax
  801897:	8b 48 04             	mov    0x4(%eax),%ecx
  80189a:	81 c1 f4 01 00 00    	add    $0x1f4,%ecx
  8018a0:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8018a5:	89 c8                	mov    %ecx,%eax
  8018a7:	f7 ea                	imul   %edx
  8018a9:	c1 fa 06             	sar    $0x6,%edx
  8018ac:	c1 f9 1f             	sar    $0x1f,%ecx
  8018af:	29 ca                	sub    %ecx,%edx
  8018b1:	8b 45 18             	mov    0x18(%ebp),%eax
  8018b4:	69 08 e8 03 00 00    	imul   $0x3e8,(%eax),%ecx
      if(msectimeout == 0)
  8018ba:	01 ca                	add    %ecx,%edx
  8018bc:	b8 01 00 00 00       	mov    $0x1,%eax
  8018c1:	0f 44 d0             	cmove  %eax,%edx
  8018c4:	e9 0b fe ff ff       	jmp    8016d4 <lwip_select+0x188>

008018c9 <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  8018c9:	55                   	push   %ebp
  8018ca:	89 e5                	mov    %esp,%ebp
  8018cc:	56                   	push   %esi
  8018cd:	53                   	push   %ebx
  8018ce:	83 ec 10             	sub    $0x10,%esp
  8018d1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8018d4:	8b 55 10             	mov    0x10(%ebp),%edx
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  8018d7:	83 f8 02             	cmp    $0x2,%eax
  8018da:	74 2b                	je     801907 <lwip_socket+0x3e>
  8018dc:	83 f8 03             	cmp    $0x3,%eax
  8018df:	74 07                	je     8018e8 <lwip_socket+0x1f>
  8018e1:	83 f8 01             	cmp    $0x1,%eax
  8018e4:	75 6c                	jne    801952 <lwip_socket+0x89>
  8018e6:	eb 4a                	jmp    801932 <lwip_socket+0x69>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  8018e8:	c7 44 24 08 9b 13 80 	movl   $0x80139b,0x8(%esp)
  8018ef:	00 
  8018f0:	0f b6 d2             	movzbl %dl,%edx
  8018f3:	89 54 24 04          	mov    %edx,0x4(%esp)
  8018f7:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  8018fe:	e8 ee a2 00 00       	call   80bbf1 <netconn_new_with_proto_and_callback>
  801903:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  801905:	eb 5c                	jmp    801963 <lwip_socket+0x9a>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  801907:	81 fa 88 00 00 00    	cmp    $0x88,%edx
  80190d:	0f 94 c0             	sete   %al
  801910:	0f b6 c0             	movzbl %al,%eax
  801913:	83 c0 20             	add    $0x20,%eax
  801916:	c7 44 24 08 9b 13 80 	movl   $0x80139b,0x8(%esp)
  80191d:	00 
  80191e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801925:	00 
  801926:	89 04 24             	mov    %eax,(%esp)
  801929:	e8 c3 a2 00 00       	call   80bbf1 <netconn_new_with_proto_and_callback>
  80192e:	89 c6                	mov    %eax,%esi
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  801930:	eb 31                	jmp    801963 <lwip_socket+0x9a>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  801932:	c7 44 24 08 9b 13 80 	movl   $0x80139b,0x8(%esp)
  801939:	00 
  80193a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801941:	00 
  801942:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  801949:	e8 a3 a2 00 00       	call   80bbf1 <netconn_new_with_proto_and_callback>
  80194e:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  801950:	eb 11                	jmp    801963 <lwip_socket+0x9a>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  801952:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801959:	00 00 00 
  80195c:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    return -1;
  801961:	eb 44                	jmp    8019a7 <lwip_socket+0xde>
  }

  if (!conn) {
  801963:	85 f6                	test   %esi,%esi
  801965:	75 11                	jne    801978 <lwip_socket+0xaf>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  801967:	c7 05 e0 b1 b3 00 69 	movl   $0x69,0xb3b1e0
  80196e:	00 00 00 
  801971:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    return -1;
  801976:	eb 2f                	jmp    8019a7 <lwip_socket+0xde>
  }

  i = alloc_socket(conn);
  801978:	89 f0                	mov    %esi,%eax
  80197a:	e8 80 f9 ff ff       	call   8012ff <alloc_socket>
  80197f:	89 c3                	mov    %eax,%ebx

  if (i == -1) {
  801981:	83 f8 ff             	cmp    $0xffffffff,%eax
  801984:	75 14                	jne    80199a <lwip_socket+0xd1>
    netconn_delete(conn);
  801986:	89 34 24             	mov    %esi,(%esp)
  801989:	e8 26 a2 00 00       	call   80bbb4 <netconn_delete>
    set_errno(ENFILE);
  80198e:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  801995:	00 00 00 
    return -1;
  801998:	eb 0d                	jmp    8019a7 <lwip_socket+0xde>
  }
  conn->socket = i;
  80199a:	89 46 1c             	mov    %eax,0x1c(%esi)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  80199d:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8019a4:	00 00 00 
  return i;
}
  8019a7:	89 d8                	mov    %ebx,%eax
  8019a9:	83 c4 10             	add    $0x10,%esp
  8019ac:	5b                   	pop    %ebx
  8019ad:	5e                   	pop    %esi
  8019ae:	5d                   	pop    %ebp
  8019af:	c3                   	ret    

008019b0 <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  8019b0:	55                   	push   %ebp
  8019b1:	89 e5                	mov    %esp,%ebp
  8019b3:	83 ec 38             	sub    $0x38,%esp
  8019b6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8019b9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8019bc:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8019bf:	8b 7d 08             	mov    0x8(%ebp),%edi
  8019c2:	8b 75 10             	mov    0x10(%ebp),%esi
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  8019c5:	89 f8                	mov    %edi,%eax
  8019c7:	e8 54 f0 ff ff       	call   800a20 <get_socket>
  8019cc:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8019ce:	85 c0                	test   %eax,%eax
  8019d0:	0f 84 80 00 00 00    	je     801a56 <lwip_send+0xa6>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  8019d6:	8b 00                	mov    (%eax),%eax
  8019d8:	83 38 10             	cmpl   $0x10,(%eax)
  8019db:	74 2e                	je     801a0b <lwip_send+0x5b>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  8019dd:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8019e4:	00 
  8019e5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8019ec:	00 
  8019ed:	8b 45 14             	mov    0x14(%ebp),%eax
  8019f0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8019f4:	89 74 24 08          	mov    %esi,0x8(%esp)
  8019f8:	8b 55 0c             	mov    0xc(%ebp),%edx
  8019fb:	89 54 24 04          	mov    %edx,0x4(%esp)
  8019ff:	89 3c 24             	mov    %edi,(%esp)
  801a02:	e8 8c 00 00 00       	call   801a93 <lwip_sendto>
  801a07:	89 c6                	mov    %eax,%esi
  801a09:	eb 50                	jmp    801a5b <lwip_send+0xab>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801a0b:	8b 55 14             	mov    0x14(%ebp),%edx
  801a0e:	83 e2 10             	and    $0x10,%edx
  801a11:	83 fa 01             	cmp    $0x1,%edx
  801a14:	19 d2                	sbb    %edx,%edx
  801a16:	83 e2 fe             	and    $0xfffffffe,%edx
  801a19:	83 c2 03             	add    $0x3,%edx
  801a1c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  801a20:	89 74 24 08          	mov    %esi,0x8(%esp)
  801a24:	8b 55 0c             	mov    0xc(%ebp),%edx
  801a27:	89 54 24 04          	mov    %edx,0x4(%esp)
  801a2b:	89 04 24             	mov    %eax,(%esp)
  801a2e:	e8 6f 9c 00 00       	call   80b6a2 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  801a33:	0f be c8             	movsbl %al,%ecx
  801a36:	f7 d9                	neg    %ecx
  801a38:	ba 05 00 00 00       	mov    $0x5,%edx
  801a3d:	83 f9 0e             	cmp    $0xe,%ecx
  801a40:	77 07                	ja     801a49 <lwip_send+0x99>
  801a42:	8b 14 8d e0 12 81 00 	mov    0x8112e0(,%ecx,4),%edx
  801a49:	89 53 10             	mov    %edx,0x10(%ebx)
  801a4c:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  return (err==ERR_OK?size:-1);
  801a52:	84 c0                	test   %al,%al
  801a54:	74 05                	je     801a5b <lwip_send+0xab>
  801a56:	be ff ff ff ff       	mov    $0xffffffff,%esi
}
  801a5b:	89 f0                	mov    %esi,%eax
  801a5d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801a60:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801a63:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801a66:	89 ec                	mov    %ebp,%esp
  801a68:	5d                   	pop    %ebp
  801a69:	c3                   	ret    

00801a6a <lwip_write>:
  return i;
}

int
lwip_write(int s, const void *data, int size)
{
  801a6a:	55                   	push   %ebp
  801a6b:	89 e5                	mov    %esp,%ebp
  801a6d:	83 ec 18             	sub    $0x18,%esp
  return lwip_send(s, data, size, 0);
  801a70:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801a77:	00 
  801a78:	8b 45 10             	mov    0x10(%ebp),%eax
  801a7b:	89 44 24 08          	mov    %eax,0x8(%esp)
  801a7f:	8b 45 0c             	mov    0xc(%ebp),%eax
  801a82:	89 44 24 04          	mov    %eax,0x4(%esp)
  801a86:	8b 45 08             	mov    0x8(%ebp),%eax
  801a89:	89 04 24             	mov    %eax,(%esp)
  801a8c:	e8 1f ff ff ff       	call   8019b0 <lwip_send>
}
  801a91:	c9                   	leave  
  801a92:	c3                   	ret    

00801a93 <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  801a93:	55                   	push   %ebp
  801a94:	89 e5                	mov    %esp,%ebp
  801a96:	57                   	push   %edi
  801a97:	56                   	push   %esi
  801a98:	53                   	push   %ebx
  801a99:	83 ec 3c             	sub    $0x3c,%esp
  801a9c:	8b 7d 10             	mov    0x10(%ebp),%edi
  801a9f:	8b 75 18             	mov    0x18(%ebp),%esi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  801aa2:	8b 45 08             	mov    0x8(%ebp),%eax
  801aa5:	e8 76 ef ff ff       	call   800a20 <get_socket>
  801aaa:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801aac:	85 c0                	test   %eax,%eax
  801aae:	0f 84 2c 01 00 00    	je     801be0 <lwip_sendto+0x14d>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  801ab4:	8b 00                	mov    (%eax),%eax
  801ab6:	83 38 10             	cmpl   $0x10,(%eax)
  801ab9:	75 24                	jne    801adf <lwip_sendto+0x4c>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  801abb:	8b 45 14             	mov    0x14(%ebp),%eax
  801abe:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801ac2:	89 7c 24 08          	mov    %edi,0x8(%esp)
  801ac6:	8b 45 0c             	mov    0xc(%ebp),%eax
  801ac9:	89 44 24 04          	mov    %eax,0x4(%esp)
  801acd:	8b 45 08             	mov    0x8(%ebp),%eax
  801ad0:	89 04 24             	mov    %eax,(%esp)
  801ad3:	e8 d8 fe ff ff       	call   8019b0 <lwip_send>
  801ad8:	89 c7                	mov    %eax,%edi
  801ada:	e9 06 01 00 00       	jmp    801be5 <lwip_sendto+0x152>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  801adf:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  801ae5:	76 1c                	jbe    801b03 <lwip_sendto+0x70>
  801ae7:	c7 44 24 08 b0 12 81 	movl   $0x8112b0,0x8(%esp)
  801aee:	00 
  801aef:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
  801af6:	00 
  801af7:	c7 04 24 06 12 81 00 	movl   $0x811206,(%esp)
  801afe:	e8 e9 d6 00 00       	call   80f1ec <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  801b03:	85 f6                	test   %esi,%esi
  801b05:	0f 95 c0             	setne  %al
  801b08:	75 06                	jne    801b10 <lwip_sendto+0x7d>
  801b0a:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801b0e:	74 28                	je     801b38 <lwip_sendto+0xa5>
  801b10:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  801b14:	75 06                	jne    801b1c <lwip_sendto+0x89>
  801b16:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801b1a:	74 1c                	je     801b38 <lwip_sendto+0xa5>
  801b1c:	c7 44 24 08 2b 12 81 	movl   $0x81122b,0x8(%esp)
  801b23:	00 
  801b24:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
  801b2b:	00 
  801b2c:	c7 04 24 06 12 81 00 	movl   $0x811206,(%esp)
  801b33:	e8 b4 d6 00 00       	call   80f1ec <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  801b38:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801b3f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  801b46:	84 c0                	test   %al,%al
  801b48:	74 1e                	je     801b68 <lwip_sendto+0xd5>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  801b4a:	8b 46 04             	mov    0x4(%esi),%eax
  801b4d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  801b50:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801b54:	89 04 24             	mov    %eax,(%esp)
  801b57:	e8 10 63 00 00       	call   807e6c <ntohs>
    buf.addr         = &remote_addr;
  801b5c:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801b5f:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  801b62:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  801b66:	eb 14                	jmp    801b7c <lwip_sendto+0xe9>
  } else {
    remote_addr.addr = 0;
  801b68:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  801b6f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  801b76:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  801b7c:	0f b7 c7             	movzwl %di,%eax
  801b7f:	89 44 24 08          	mov    %eax,0x8(%esp)
  801b83:	8b 45 0c             	mov    0xc(%ebp),%eax
  801b86:	89 44 24 04          	mov    %eax,0x4(%esp)
  801b8a:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801b8d:	89 04 24             	mov    %eax,(%esp)
  801b90:	e8 a0 0e 00 00       	call   802a35 <netbuf_ref>
  801b95:	0f be f0             	movsbl %al,%esi
  801b98:	85 f6                	test   %esi,%esi
  801b9a:	75 14                	jne    801bb0 <lwip_sendto+0x11d>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  801b9c:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801b9f:	89 44 24 04          	mov    %eax,0x4(%esp)
  801ba3:	8b 03                	mov    (%ebx),%eax
  801ba5:	89 04 24             	mov    %eax,(%esp)
  801ba8:	e8 72 9b 00 00       	call   80b71f <netconn_send>
  801bad:	0f be f0             	movsbl %al,%esi
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  801bb0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  801bb3:	85 c0                	test   %eax,%eax
  801bb5:	74 08                	je     801bbf <lwip_sendto+0x12c>
    pbuf_free(buf.p);
  801bb7:	89 04 24             	mov    %eax,(%esp)
  801bba:	e8 65 36 00 00       	call   805224 <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  801bbf:	89 f2                	mov    %esi,%edx
  801bc1:	f7 da                	neg    %edx
  801bc3:	b8 05 00 00 00       	mov    $0x5,%eax
  801bc8:	83 fa 0e             	cmp    $0xe,%edx
  801bcb:	77 07                	ja     801bd4 <lwip_sendto+0x141>
  801bcd:	8b 04 95 e0 12 81 00 	mov    0x8112e0(,%edx,4),%eax
  801bd4:	89 43 10             	mov    %eax,0x10(%ebx)
  801bd7:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return (err==ERR_OK?size:-1);
  801bdc:	85 f6                	test   %esi,%esi
  801bde:	74 05                	je     801be5 <lwip_sendto+0x152>
  801be0:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
  801be5:	89 f8                	mov    %edi,%eax
  801be7:	83 c4 3c             	add    $0x3c,%esp
  801bea:	5b                   	pop    %ebx
  801beb:	5e                   	pop    %esi
  801bec:	5f                   	pop    %edi
  801bed:	5d                   	pop    %ebp
  801bee:	c3                   	ret    

00801bef <lwip_recvfrom>:
}

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  801bef:	55                   	push   %ebp
  801bf0:	89 e5                	mov    %esp,%ebp
  801bf2:	57                   	push   %edi
  801bf3:	56                   	push   %esi
  801bf4:	53                   	push   %ebx
  801bf5:	83 ec 5c             	sub    $0x5c,%esp
  801bf8:	8b 75 14             	mov    0x14(%ebp),%esi
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  801bfb:	8b 45 08             	mov    0x8(%ebp),%eax
  801bfe:	e8 1d ee ff ff       	call   800a20 <get_socket>
  801c03:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801c05:	66 c7 45 c6 00 00    	movw   $0x0,-0x3a(%ebp)
  801c0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801c10:	85 db                	test   %ebx,%ebx
  801c12:	0f 84 0b 02 00 00    	je     801e23 <lwip_recvfrom+0x234>
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801c18:	89 f0                	mov    %esi,%eax
  801c1a:	83 e0 08             	and    $0x8,%eax
  801c1d:	89 45 b0             	mov    %eax,-0x50(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  801c20:	83 e6 01             	and    $0x1,%esi
  801c23:	89 75 b4             	mov    %esi,-0x4c(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  801c26:	8b 73 04             	mov    0x4(%ebx),%esi
  801c29:	85 f6                	test   %esi,%esi
  801c2b:	75 7d                	jne    801caa <lwip_recvfrom+0xbb>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801c2d:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  801c31:	75 06                	jne    801c39 <lwip_recvfrom+0x4a>
  801c33:	f6 43 0f 08          	testb  $0x8,0xf(%ebx)
  801c37:	74 22                	je     801c5b <lwip_recvfrom+0x6c>
  801c39:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  801c3e:	75 1b                	jne    801c5b <lwip_recvfrom+0x6c>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  801c40:	c7 43 10 0b 00 00 00 	movl   $0xb,0x10(%ebx)
  801c47:	c7 05 e0 b1 b3 00 0b 	movl   $0xb,0xb3b1e0
  801c4e:	00 00 00 
  801c51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
        return -1;
  801c56:	e9 c8 01 00 00       	jmp    801e23 <lwip_recvfrom+0x234>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  801c5b:	8b 03                	mov    (%ebx),%eax
  801c5d:	89 04 24             	mov    %eax,(%esp)
  801c60:	e8 a0 9d 00 00       	call   80ba05 <netconn_recv>
  801c65:	89 c6                	mov    %eax,%esi
  801c67:	89 43 04             	mov    %eax,0x4(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  801c6a:	85 c0                	test   %eax,%eax
  801c6c:	75 3c                	jne    801caa <lwip_recvfrom+0xbb>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  801c6e:	8b 13                	mov    (%ebx),%edx
  801c70:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  801c74:	74 0b                	je     801c81 <lwip_recvfrom+0x92>
  801c76:	b8 6e 00 00 00       	mov    $0x6e,%eax
  801c7b:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  801c7f:	74 17                	je     801c98 <lwip_recvfrom+0xa9>
  801c81:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  801c85:	f7 da                	neg    %edx
  801c87:	b8 05 00 00 00       	mov    $0x5,%eax
  801c8c:	83 fa 0e             	cmp    $0xe,%edx
  801c8f:	77 07                	ja     801c98 <lwip_recvfrom+0xa9>
  801c91:	8b 04 95 e0 12 81 00 	mov    0x8112e0(,%edx,4),%eax
  801c98:	89 43 10             	mov    %eax,0x10(%ebx)
  801c9b:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  801ca0:	b8 00 00 00 00       	mov    $0x0,%eax
        return 0;
  801ca5:	e9 79 01 00 00       	jmp    801e23 <lwip_recvfrom+0x234>
      }
    }

    buflen = netbuf_len(buf);
  801caa:	8b 06                	mov    (%esi),%eax
  801cac:	0f b7 78 08          	movzwl 0x8(%eax),%edi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  801cb0:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  801cb4:	66 29 d7             	sub    %dx,%di

    if (len > buflen) {
  801cb7:	0f b7 cf             	movzwl %di,%ecx
  801cba:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  801cbd:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  801cc0:	0f 4e 7d 10          	cmovle 0x10(%ebp),%edi
      copylen = len;
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  801cc4:	0f b7 cf             	movzwl %di,%ecx
  801cc7:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  801cca:	0f b7 d2             	movzwl %dx,%edx
  801ccd:	89 54 24 0c          	mov    %edx,0xc(%esp)
  801cd1:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  801cd5:	0f b7 55 c6          	movzwl -0x3a(%ebp),%edx
  801cd9:	03 55 0c             	add    0xc(%ebp),%edx
  801cdc:	89 54 24 04          	mov    %edx,0x4(%esp)
  801ce0:	89 04 24             	mov    %eax,(%esp)
  801ce3:	e8 d2 32 00 00       	call   804fba <pbuf_copy_partial>

    off += copylen;
  801ce8:	66 01 7d c6          	add    %di,-0x3a(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801cec:	8b 03                	mov    (%ebx),%eax
  801cee:	89 04 24             	mov    %eax,(%esp)
  801cf1:	e8 36 99 00 00       	call   80b62c <netconn_type>
  801cf6:	83 f8 10             	cmp    $0x10,%eax
  801cf9:	75 1f                	jne    801d1a <lwip_recvfrom+0x12b>
      len -= copylen;
  801cfb:	8b 45 c0             	mov    -0x40(%ebp),%eax
  801cfe:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  801d01:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801d05:	7e 13                	jle    801d1a <lwip_recvfrom+0x12b>
  801d07:	8b 06                	mov    (%esi),%eax
  801d09:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  801d0d:	75 0b                	jne    801d1a <lwip_recvfrom+0x12b>
  801d0f:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
  801d13:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  801d18:	75 04                	jne    801d1e <lwip_recvfrom+0x12f>
  801d1a:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  801d1e:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801d22:	75 39                	jne    801d5d <lwip_recvfrom+0x16e>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  801d24:	8b 03                	mov    (%ebx),%eax
  801d26:	83 38 10             	cmpl   $0x10,(%eax)
  801d29:	75 13                	jne    801d3e <lwip_recvfrom+0x14f>
  801d2b:	8b 45 bc             	mov    -0x44(%ebp),%eax
  801d2e:	2b 45 c0             	sub    -0x40(%ebp),%eax
  801d31:	85 c0                	test   %eax,%eax
  801d33:	7e 09                	jle    801d3e <lwip_recvfrom+0x14f>
        sock->lastdata = buf;
  801d35:	89 73 04             	mov    %esi,0x4(%ebx)
        sock->lastoffset += copylen;
  801d38:	66 01 7b 08          	add    %di,0x8(%ebx)
    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  801d3c:	eb 15                	jmp    801d53 <lwip_recvfrom+0x164>
        sock->lastdata = buf;
        sock->lastoffset += copylen;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
      } else {
        sock->lastdata = NULL;
  801d3e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
        sock->lastoffset = 0;
  801d45:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  801d4b:	89 34 24             	mov    %esi,(%esp)
  801d4e:	e8 a3 0c 00 00       	call   8029f6 <netbuf_delete>
      }
    } else {
      done = 1;
    }
  } while (!done);
  801d53:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
  801d57:	0f 84 c9 fe ff ff    	je     801c26 <lwip_recvfrom+0x37>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  801d5d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801d61:	0f 84 a7 00 00 00    	je     801e0e <lwip_recvfrom+0x21f>
  801d67:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801d6b:	0f 84 9d 00 00 00    	je     801e0e <lwip_recvfrom+0x21f>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801d71:	8b 03                	mov    (%ebx),%eax
  801d73:	89 04 24             	mov    %eax,(%esp)
  801d76:	e8 b1 98 00 00       	call   80b62c <netconn_type>
  801d7b:	83 f8 10             	cmp    $0x10,%eax
  801d7e:	75 22                	jne    801da2 <lwip_recvfrom+0x1b3>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  801d80:	8d 7d d8             	lea    -0x28(%ebp),%edi
      netconn_getaddr(sock->conn, addr, &port, 0);
  801d83:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801d8a:	00 
  801d8b:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  801d8e:	89 44 24 08          	mov    %eax,0x8(%esp)
  801d92:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801d96:	8b 03                	mov    (%ebx),%eax
  801d98:	89 04 24             	mov    %eax,(%esp)
  801d9b:	e8 3f 9b 00 00       	call   80b8df <netconn_getaddr>
  801da0:	eb 0b                	jmp    801dad <lwip_recvfrom+0x1be>
    } else {
      addr = netbuf_fromaddr(buf);
  801da2:	8b 7e 08             	mov    0x8(%esi),%edi
      port = netbuf_fromport(buf);
  801da5:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  801da9:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  801dad:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  801db4:	00 
  801db5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801dbc:	00 
  801dbd:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801dc0:	89 04 24             	mov    %eax,(%esp)
  801dc3:	e8 88 dc 00 00       	call   80fa50 <memset>
    sin.sin_len = sizeof(sin);
  801dc8:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  801dcc:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  801dd0:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  801dd4:	89 04 24             	mov    %eax,(%esp)
  801dd7:	e8 83 60 00 00       	call   807e5f <htons>
  801ddc:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  801de0:	8b 07                	mov    (%edi),%eax
  801de2:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  801de5:	8b 55 1c             	mov    0x1c(%ebp),%edx
  801de8:	83 3a 10             	cmpl   $0x10,(%edx)
  801deb:	76 06                	jbe    801df3 <lwip_recvfrom+0x204>
      *fromlen = sizeof(sin);
  801ded:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

    SMEMCPY(from, &sin, *fromlen);
  801df3:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  801df6:	8b 01                	mov    (%ecx),%eax
  801df8:	89 44 24 08          	mov    %eax,0x8(%esp)
  801dfc:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801dff:	89 44 24 04          	mov    %eax,0x4(%esp)
  801e03:	8b 45 18             	mov    0x18(%ebp),%eax
  801e06:	89 04 24             	mov    %eax,(%esp)
  801e09:	e8 1d dd 00 00       	call   80fb2b <memcpy>
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  801e0e:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801e15:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801e1c:	00 00 00 
  return off;
  801e1f:	0f b7 45 c6          	movzwl -0x3a(%ebp),%eax
}
  801e23:	83 c4 5c             	add    $0x5c,%esp
  801e26:	5b                   	pop    %ebx
  801e27:	5e                   	pop    %esi
  801e28:	5f                   	pop    %edi
  801e29:	5d                   	pop    %ebp
  801e2a:	c3                   	ret    

00801e2b <lwip_recv>:
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
}

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  801e2b:	55                   	push   %ebp
  801e2c:	89 e5                	mov    %esp,%ebp
  801e2e:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  801e31:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  801e38:	00 
  801e39:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  801e40:	00 
  801e41:	8b 45 14             	mov    0x14(%ebp),%eax
  801e44:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801e48:	8b 45 10             	mov    0x10(%ebp),%eax
  801e4b:	89 44 24 08          	mov    %eax,0x8(%esp)
  801e4f:	8b 45 0c             	mov    0xc(%ebp),%eax
  801e52:	89 44 24 04          	mov    %eax,0x4(%esp)
  801e56:	8b 45 08             	mov    0x8(%ebp),%eax
  801e59:	89 04 24             	mov    %eax,(%esp)
  801e5c:	e8 8e fd ff ff       	call   801bef <lwip_recvfrom>
}
  801e61:	c9                   	leave  
  801e62:	c3                   	ret    

00801e63 <lwip_read>:
  return off;
}

int
lwip_read(int s, void *mem, int len)
{
  801e63:	55                   	push   %ebp
  801e64:	89 e5                	mov    %esp,%ebp
  801e66:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  801e69:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  801e70:	00 
  801e71:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  801e78:	00 
  801e79:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801e80:	00 
  801e81:	8b 45 10             	mov    0x10(%ebp),%eax
  801e84:	89 44 24 08          	mov    %eax,0x8(%esp)
  801e88:	8b 45 0c             	mov    0xc(%ebp),%eax
  801e8b:	89 44 24 04          	mov    %eax,0x4(%esp)
  801e8f:	8b 45 08             	mov    0x8(%ebp),%eax
  801e92:	89 04 24             	mov    %eax,(%esp)
  801e95:	e8 55 fd ff ff       	call   801bef <lwip_recvfrom>
}
  801e9a:	c9                   	leave  
  801e9b:	c3                   	ret    

00801e9c <lwip_close>:
  return 0;
}

int
lwip_close(int s)
{
  801e9c:	55                   	push   %ebp
  801e9d:	89 e5                	mov    %esp,%ebp
  801e9f:	53                   	push   %ebx
  801ea0:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  801ea3:	8b 45 08             	mov    0x8(%ebp),%eax
  801ea6:	e8 75 eb ff ff       	call   800a20 <get_socket>
  801eab:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  801ead:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801eb2:	85 db                	test   %ebx,%ebx
  801eb4:	74 5c                	je     801f12 <lwip_close+0x76>
    return -1;
  }

  netconn_delete(sock->conn);
  801eb6:	8b 03                	mov    (%ebx),%eax
  801eb8:	89 04 24             	mov    %eax,(%esp)
  801ebb:	e8 f4 9c 00 00       	call   80bbb4 <netconn_delete>

  sys_sem_wait(socksem);
  801ec0:	a1 e4 52 81 00       	mov    0x8152e4,%eax
  801ec5:	89 04 24             	mov    %eax,(%esp)
  801ec8:	e8 0c 3a 00 00       	call   8058d9 <sys_sem_wait>
  if (sock->lastdata) {
  801ecd:	8b 43 04             	mov    0x4(%ebx),%eax
  801ed0:	85 c0                	test   %eax,%eax
  801ed2:	74 08                	je     801edc <lwip_close+0x40>
    netbuf_delete(sock->lastdata);
  801ed4:	89 04 24             	mov    %eax,(%esp)
  801ed7:	e8 1a 0b 00 00       	call   8029f6 <netbuf_delete>
  }
  sock->lastdata   = NULL;
  801edc:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  801ee3:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  801ee9:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  801eef:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801ef6:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801efd:	00 00 00 
  sys_sem_signal(socksem);
  801f00:	a1 e4 52 81 00       	mov    0x8152e4,%eax
  801f05:	89 04 24             	mov    %eax,(%esp)
  801f08:	e8 64 8d 00 00       	call   80ac71 <sys_sem_signal>
  801f0d:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  801f12:	83 c4 14             	add    $0x14,%esp
  801f15:	5b                   	pop    %ebx
  801f16:	5d                   	pop    %ebp
  801f17:	c3                   	ret    

00801f18 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  801f18:	55                   	push   %ebp
  801f19:	89 e5                	mov    %esp,%ebp
  801f1b:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801f1e:	8b 45 08             	mov    0x8(%ebp),%eax
  801f21:	89 04 24             	mov    %eax,(%esp)
  801f24:	e8 73 ff ff ff       	call   801e9c <lwip_close>
}
  801f29:	c9                   	leave  
  801f2a:	c3                   	ret    

00801f2b <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  801f2b:	55                   	push   %ebp
  801f2c:	89 e5                	mov    %esp,%ebp
  801f2e:	56                   	push   %esi
  801f2f:	53                   	push   %ebx
  801f30:	83 ec 10             	sub    $0x10,%esp
  801f33:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  801f36:	8b 45 08             	mov    0x8(%ebp),%eax
  801f39:	e8 e2 ea ff ff       	call   800a20 <get_socket>
  801f3e:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801f40:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f45:	85 db                	test   %ebx,%ebx
  801f47:	74 69                	je     801fb2 <lwip_listen+0x87>
  801f49:	85 f6                	test   %esi,%esi
  801f4b:	b8 00 00 00 00       	mov    $0x0,%eax
  801f50:	0f 48 f0             	cmovs  %eax,%esi
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  801f53:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  801f59:	b0 ff                	mov    $0xff,%al
  801f5b:	0f 4f f0             	cmovg  %eax,%esi
  801f5e:	81 e6 ff 00 00 00    	and    $0xff,%esi
  801f64:	89 74 24 04          	mov    %esi,0x4(%esp)
  801f68:	8b 03                	mov    (%ebx),%eax
  801f6a:	89 04 24             	mov    %eax,(%esp)
  801f6d:	e8 2d 98 00 00       	call   80b79f <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  801f72:	84 c0                	test   %al,%al
  801f74:	74 26                	je     801f9c <lwip_listen+0x71>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  801f76:	0f be c0             	movsbl %al,%eax
  801f79:	f7 d8                	neg    %eax
  801f7b:	ba 05 00 00 00       	mov    $0x5,%edx
  801f80:	83 f8 0e             	cmp    $0xe,%eax
  801f83:	77 07                	ja     801f8c <lwip_listen+0x61>
  801f85:	8b 14 85 e0 12 81 00 	mov    0x8112e0(,%eax,4),%edx
  801f8c:	89 53 10             	mov    %edx,0x10(%ebx)
  801f8f:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  801f95:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  801f9a:	eb 16                	jmp    801fb2 <lwip_listen+0x87>
  }

  sock_set_errno(sock, 0);
  801f9c:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801fa3:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801faa:	00 00 00 
  801fad:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  801fb2:	83 c4 10             	add    $0x10,%esp
  801fb5:	5b                   	pop    %ebx
  801fb6:	5e                   	pop    %esi
  801fb7:	5d                   	pop    %ebp
  801fb8:	c3                   	ret    

00801fb9 <lwip_connect>:
  return 0;
}

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  801fb9:	55                   	push   %ebp
  801fba:	89 e5                	mov    %esp,%ebp
  801fbc:	53                   	push   %ebx
  801fbd:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  801fc0:	8b 45 08             	mov    0x8(%ebp),%eax
  801fc3:	e8 58 ea ff ff       	call   800a20 <get_socket>
  801fc8:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801fca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801fcf:	85 db                	test   %ebx,%ebx
  801fd1:	0f 84 95 00 00 00    	je     80206c <lwip_connect+0xb3>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801fd7:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801fdb:	75 09                	jne    801fe6 <lwip_connect+0x2d>
  801fdd:	8b 45 0c             	mov    0xc(%ebp),%eax
  801fe0:	80 78 01 02          	cmpb   $0x2,0x1(%eax)
  801fe4:	74 1c                	je     802002 <lwip_connect+0x49>
  801fe6:	c7 44 24 08 48 12 81 	movl   $0x811248,0x8(%esp)
  801fed:	00 
  801fee:	c7 44 24 04 86 01 00 	movl   $0x186,0x4(%esp)
  801ff5:	00 
  801ff6:	c7 04 24 06 12 81 00 	movl   $0x811206,(%esp)
  801ffd:	e8 ea d1 00 00       	call   80f1ec <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  802002:	8b 50 04             	mov    0x4(%eax),%edx
  802005:	89 55 f4             	mov    %edx,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  802008:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  80200c:	89 04 24             	mov    %eax,(%esp)
  80200f:	e8 58 5e 00 00       	call   807e6c <ntohs>
  802014:	0f b7 c0             	movzwl %ax,%eax
  802017:	89 44 24 08          	mov    %eax,0x8(%esp)
  80201b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80201e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802022:	8b 03                	mov    (%ebx),%eax
  802024:	89 04 24             	mov    %eax,(%esp)
  802027:	e8 05 98 00 00       	call   80b831 <netconn_connect>
  }

  if (err != ERR_OK) {
  80202c:	84 c0                	test   %al,%al
  80202e:	74 26                	je     802056 <lwip_connect+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  802030:	0f be c0             	movsbl %al,%eax
  802033:	f7 d8                	neg    %eax
  802035:	ba 05 00 00 00       	mov    $0x5,%edx
  80203a:	83 f8 0e             	cmp    $0xe,%eax
  80203d:	77 07                	ja     802046 <lwip_connect+0x8d>
  80203f:	8b 14 85 e0 12 81 00 	mov    0x8112e0(,%eax,4),%edx
  802046:	89 53 10             	mov    %edx,0x10(%ebx)
  802049:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  80204f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  802054:	eb 16                	jmp    80206c <lwip_connect+0xb3>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  802056:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80205d:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  802064:	00 00 00 
  802067:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  80206c:	83 c4 24             	add    $0x24,%esp
  80206f:	5b                   	pop    %ebx
  802070:	5d                   	pop    %ebp
  802071:	c3                   	ret    

00802072 <lwip_bind>:
  return newsock;
}

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  802072:	55                   	push   %ebp
  802073:	89 e5                	mov    %esp,%ebp
  802075:	53                   	push   %ebx
  802076:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  802079:	8b 45 08             	mov    0x8(%ebp),%eax
  80207c:	e8 9f e9 ff ff       	call   800a20 <get_socket>
  802081:	89 c3                	mov    %eax,%ebx
  if (!sock)
  802083:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802088:	85 db                	test   %ebx,%ebx
  80208a:	0f 84 95 00 00 00    	je     802125 <lwip_bind+0xb3>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  802090:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  802094:	75 09                	jne    80209f <lwip_bind+0x2d>
  802096:	8b 45 0c             	mov    0xc(%ebp),%eax
  802099:	80 78 01 02          	cmpb   $0x2,0x1(%eax)
  80209d:	74 1c                	je     8020bb <lwip_bind+0x49>
  80209f:	c7 44 24 08 66 12 81 	movl   $0x811266,0x8(%esp)
  8020a6:	00 
  8020a7:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
  8020ae:	00 
  8020af:	c7 04 24 06 12 81 00 	movl   $0x811206,(%esp)
  8020b6:	e8 31 d1 00 00       	call   80f1ec <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8020bb:	8b 50 04             	mov    0x4(%eax),%edx
  8020be:	89 55 f4             	mov    %edx,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  8020c1:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  8020c5:	89 04 24             	mov    %eax,(%esp)
  8020c8:	e8 9f 5d 00 00       	call   807e6c <ntohs>
  8020cd:	0f b7 c0             	movzwl %ax,%eax
  8020d0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8020d4:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8020d7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8020db:	8b 03                	mov    (%ebx),%eax
  8020dd:	89 04 24             	mov    %eax,(%esp)
  8020e0:	e8 a3 97 00 00       	call   80b888 <netconn_bind>

  if (err != ERR_OK) {
  8020e5:	84 c0                	test   %al,%al
  8020e7:	74 26                	je     80210f <lwip_bind+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8020e9:	0f be c0             	movsbl %al,%eax
  8020ec:	f7 d8                	neg    %eax
  8020ee:	ba 05 00 00 00       	mov    $0x5,%edx
  8020f3:	83 f8 0e             	cmp    $0xe,%eax
  8020f6:	77 07                	ja     8020ff <lwip_bind+0x8d>
  8020f8:	8b 14 85 e0 12 81 00 	mov    0x8112e0(,%eax,4),%edx
  8020ff:	89 53 10             	mov    %edx,0x10(%ebx)
  802102:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  802108:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  80210d:	eb 16                	jmp    802125 <lwip_bind+0xb3>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  80210f:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  802116:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80211d:	00 00 00 
  802120:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  802125:	83 c4 24             	add    $0x24,%esp
  802128:	5b                   	pop    %ebx
  802129:	5d                   	pop    %ebp
  80212a:	c3                   	ret    

0080212b <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80212b:	55                   	push   %ebp
  80212c:	89 e5                	mov    %esp,%ebp
  80212e:	57                   	push   %edi
  80212f:	56                   	push   %esi
  802130:	53                   	push   %ebx
  802131:	83 ec 4c             	sub    $0x4c,%esp
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  802134:	8b 45 08             	mov    0x8(%ebp),%eax
  802137:	e8 e4 e8 ff ff       	call   800a20 <get_socket>
  80213c:	89 c7                	mov    %eax,%edi
  if (!sock)
  80213e:	be ff ff ff ff       	mov    $0xffffffff,%esi
  802143:	85 c0                	test   %eax,%eax
  802145:	0f 84 ae 01 00 00    	je     8022f9 <lwip_accept+0x1ce>
    return -1;

  newconn = netconn_accept(sock->conn);
  80214b:	8b 00                	mov    (%eax),%eax
  80214d:	89 04 24             	mov    %eax,(%esp)
  802150:	e8 26 98 00 00       	call   80b97b <netconn_accept>
  802155:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  802157:	85 c0                	test   %eax,%eax
  802159:	75 2b                	jne    802186 <lwip_accept+0x5b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  80215b:	8b 07                	mov    (%edi),%eax
  80215d:	0f be 50 0c          	movsbl 0xc(%eax),%edx
  802161:	f7 da                	neg    %edx
  802163:	b8 05 00 00 00       	mov    $0x5,%eax
  802168:	83 fa 0e             	cmp    $0xe,%edx
  80216b:	77 07                	ja     802174 <lwip_accept+0x49>
  80216d:	8b 04 95 e0 12 81 00 	mov    0x8112e0(,%edx,4),%eax
  802174:	89 47 10             	mov    %eax,0x10(%edi)
  802177:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  80217c:	be ff ff ff ff       	mov    $0xffffffff,%esi
    return -1;
  802181:	e9 73 01 00 00       	jmp    8022f9 <lwip_accept+0x1ce>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  802186:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80218d:	00 
  80218e:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  802191:	89 44 24 08          	mov    %eax,0x8(%esp)
  802195:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  802198:	89 44 24 04          	mov    %eax,0x4(%esp)
  80219c:	89 1c 24             	mov    %ebx,(%esp)
  80219f:	e8 3b 97 00 00       	call   80b8df <netconn_getaddr>
  8021a4:	89 c6                	mov    %eax,%esi
  if (err != ERR_OK) {
  8021a6:	84 c0                	test   %al,%al
  8021a8:	74 32                	je     8021dc <lwip_accept+0xb1>
    netconn_delete(newconn);
  8021aa:	89 1c 24             	mov    %ebx,(%esp)
  8021ad:	e8 02 9a 00 00       	call   80bbb4 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  8021b2:	89 f0                	mov    %esi,%eax
  8021b4:	0f be f0             	movsbl %al,%esi
  8021b7:	f7 de                	neg    %esi
  8021b9:	b8 05 00 00 00       	mov    $0x5,%eax
  8021be:	83 fe 0e             	cmp    $0xe,%esi
  8021c1:	77 07                	ja     8021ca <lwip_accept+0x9f>
  8021c3:	8b 04 b5 e0 12 81 00 	mov    0x8112e0(,%esi,4),%eax
  8021ca:	89 47 10             	mov    %eax,0x10(%edi)
  8021cd:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  8021d2:	be ff ff ff ff       	mov    $0xffffffff,%esi
    return -1;
  8021d7:	e9 1d 01 00 00       	jmp    8022f9 <lwip_accept+0x1ce>
  }

  memset(&sin, 0, sizeof(sin));
  8021dc:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  8021e3:	00 
  8021e4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8021eb:	00 
  8021ec:	8d 45 d0             	lea    -0x30(%ebp),%eax
  8021ef:	89 04 24             	mov    %eax,(%esp)
  8021f2:	e8 59 d8 00 00       	call   80fa50 <memset>
  sin.sin_len = sizeof(sin);
  8021f7:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  8021fb:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  8021ff:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  802203:	89 04 24             	mov    %eax,(%esp)
  802206:	e8 54 5c 00 00       	call   807e5f <htons>
  80220b:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  80220f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802212:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  802215:	8b 55 10             	mov    0x10(%ebp),%edx
  802218:	83 3a 10             	cmpl   $0x10,(%edx)
  80221b:	76 06                	jbe    802223 <lwip_accept+0xf8>
    *addrlen = sizeof(sin);
  80221d:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

  SMEMCPY(addr, &sin, *addrlen);
  802223:	8b 55 10             	mov    0x10(%ebp),%edx
  802226:	8b 02                	mov    (%edx),%eax
  802228:	89 44 24 08          	mov    %eax,0x8(%esp)
  80222c:	8d 45 d0             	lea    -0x30(%ebp),%eax
  80222f:	89 44 24 04          	mov    %eax,0x4(%esp)
  802233:	8b 45 0c             	mov    0xc(%ebp),%eax
  802236:	89 04 24             	mov    %eax,(%esp)
  802239:	e8 ed d8 00 00       	call   80fb2b <memcpy>

  newsock = alloc_socket(newconn);
  80223e:	89 d8                	mov    %ebx,%eax
  802240:	e8 ba f0 ff ff       	call   8012ff <alloc_socket>
  802245:	89 c6                	mov    %eax,%esi
  if (newsock == -1) {
  802247:	83 f8 ff             	cmp    $0xffffffff,%eax
  80224a:	75 1e                	jne    80226a <lwip_accept+0x13f>
    netconn_delete(newconn);
  80224c:	89 1c 24             	mov    %ebx,(%esp)
  80224f:	e8 60 99 00 00       	call   80bbb4 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  802254:	c7 47 10 17 00 00 00 	movl   $0x17,0x10(%edi)
  80225b:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  802262:	00 00 00 
    return -1;
  802265:	e9 8f 00 00 00       	jmp    8022f9 <lwip_accept+0x1ce>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  80226a:	83 fe 1f             	cmp    $0x1f,%esi
  80226d:	76 1c                	jbe    80228b <lwip_accept+0x160>
  80226f:	c7 44 24 08 81 12 81 	movl   $0x811281,0x8(%esp)
  802276:	00 
  802277:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  80227e:	00 
  80227f:	c7 04 24 06 12 81 00 	movl   $0x811206,(%esp)
  802286:	e8 61 cf 00 00       	call   80f1ec <_panic>
  newconn->callback = event_callback;
  80228b:	c7 43 2c 9b 13 80 00 	movl   $0x80139b,0x2c(%ebx)
  nsock = &sockets[newsock];
  802292:	8d 04 80             	lea    (%eax,%eax,4),%eax
  802295:	8d 04 85 60 50 81 00 	lea    0x815060(,%eax,4),%eax
  80229c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  80229f:	85 c0                	test   %eax,%eax
  8022a1:	75 1c                	jne    8022bf <lwip_accept+0x194>
  8022a3:	c7 44 24 08 96 12 81 	movl   $0x811296,0x8(%esp)
  8022aa:	00 
  8022ab:	c7 44 24 04 28 01 00 	movl   $0x128,0x4(%esp)
  8022b2:	00 
  8022b3:	c7 04 24 06 12 81 00 	movl   $0x811206,(%esp)
  8022ba:	e8 2d cf 00 00       	call   80f1ec <_panic>

  sys_sem_wait(socksem);
  8022bf:	a1 e4 52 81 00       	mov    0x8152e4,%eax
  8022c4:	89 04 24             	mov    %eax,(%esp)
  8022c7:	e8 0d 36 00 00       	call   8058d9 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  8022cc:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8022cf:	f7 d0                	not    %eax
  8022d1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  8022d4:	66 01 42 0a          	add    %ax,0xa(%edx)
  newconn->socket = newsock;
  8022d8:	89 73 1c             	mov    %esi,0x1c(%ebx)
  sys_sem_signal(socksem);
  8022db:	a1 e4 52 81 00       	mov    0x8152e4,%eax
  8022e0:	89 04 24             	mov    %eax,(%esp)
  8022e3:	e8 89 89 00 00       	call   80ac71 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  8022e8:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  8022ef:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8022f6:	00 00 00 
  return newsock;
}
  8022f9:	89 f0                	mov    %esi,%eax
  8022fb:	83 c4 4c             	add    $0x4c,%esp
  8022fe:	5b                   	pop    %ebx
  8022ff:	5e                   	pop    %esi
  802300:	5f                   	pop    %edi
  802301:	5d                   	pop    %ebp
  802302:	c3                   	ret    
	...

00802310 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  802310:	55                   	push   %ebp
  802311:	89 e5                	mov    %esp,%ebp
  802313:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  802316:	8b 45 08             	mov    0x8(%ebp),%eax
  802319:	89 04 24             	mov    %eax,(%esp)
  80231c:	e8 03 2f 00 00       	call   805224 <pbuf_free>
}
  802321:	c9                   	leave  
  802322:	c3                   	ret    

00802323 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  802323:	55                   	push   %ebp
  802324:	89 e5                	mov    %esp,%ebp
  802326:	83 ec 28             	sub    $0x28,%esp
  lwip_init();
  802329:	e8 62 08 00 00       	call   802b90 <lwip_init>

  tcpip_init_done = initfunc;
  80232e:	8b 45 08             	mov    0x8(%ebp),%eax
  802331:	a3 ec 52 81 00       	mov    %eax,0x8152ec
  tcpip_init_done_arg = arg;
  802336:	8b 45 0c             	mov    0xc(%ebp),%eax
  802339:	a3 f0 52 81 00       	mov    %eax,0x8152f0
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  80233e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802345:	e8 0f 88 00 00       	call   80ab59 <sys_mbox_new>
  80234a:	a3 00 40 81 00       	mov    %eax,0x814000
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  80234f:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  802356:	00 
  802357:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80235e:	00 
  80235f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802366:	00 
  802367:	c7 44 24 04 c6 23 80 	movl   $0x8023c6,0x4(%esp)
  80236e:	00 
  80236f:	c7 04 24 1c 13 81 00 	movl   $0x81131c,(%esp)
  802376:	e8 76 85 00 00       	call   80a8f1 <sys_thread_new>
}
  80237b:	c9                   	leave  
  80237c:	c3                   	ret    

0080237d <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  80237d:	55                   	push   %ebp
  80237e:	89 e5                	mov    %esp,%ebp
  802380:	83 ec 18             	sub    $0x18,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802383:	83 3d f4 52 81 00 00 	cmpl   $0x0,0x8152f4
  80238a:	75 38                	jne    8023c4 <tcp_timer_needed+0x47>
  80238c:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  802393:	75 09                	jne    80239e <tcp_timer_needed+0x21>
  802395:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  80239c:	74 26                	je     8023c4 <tcp_timer_needed+0x47>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  80239e:	c7 05 f4 52 81 00 01 	movl   $0x1,0x8152f4
  8023a5:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8023a8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8023af:	00 
  8023b0:	c7 44 24 04 d6 27 80 	movl   $0x8027d6,0x4(%esp)
  8023b7:	00 
  8023b8:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  8023bf:	e8 56 34 00 00       	call   80581a <sys_timeout>
  }
}
  8023c4:	c9                   	leave  
  8023c5:	c3                   	ret    

008023c6 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  8023c6:	55                   	push   %ebp
  8023c7:	89 e5                	mov    %esp,%ebp
  8023c9:	53                   	push   %ebx
  8023ca:	83 ec 24             	sub    $0x24,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  8023cd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8023d4:	00 
  8023d5:	c7 44 24 04 b3 25 80 	movl   $0x8025b3,0x4(%esp)
  8023dc:	00 
  8023dd:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  8023e4:	e8 31 34 00 00       	call   80581a <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8023e9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8023f0:	00 
  8023f1:	c7 44 24 04 8a 25 80 	movl   $0x80258a,0x4(%esp)
  8023f8:	00 
  8023f9:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  802400:	e8 15 34 00 00       	call   80581a <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802405:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80240c:	00 
  80240d:	c7 44 24 04 61 25 80 	movl   $0x802561,0x4(%esp)
  802414:	00 
  802415:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  80241c:	e8 f9 33 00 00       	call   80581a <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802421:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802428:	00 
  802429:	c7 44 24 04 38 25 80 	movl   $0x802538,0x4(%esp)
  802430:	00 
  802431:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  802438:	e8 dd 33 00 00       	call   80581a <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  80243d:	a1 ec 52 81 00       	mov    0x8152ec,%eax
  802442:	85 c0                	test   %eax,%eax
  802444:	74 0b                	je     802451 <tcpip_thread+0x8b>
    tcpip_init_done(tcpip_init_done_arg);
  802446:	8b 15 f0 52 81 00    	mov    0x8152f0,%edx
  80244c:	89 14 24             	mov    %edx,(%esp)
  80244f:	ff d0                	call   *%eax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  802451:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  802454:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802458:	a1 00 40 81 00       	mov    0x814000,%eax
  80245d:	89 04 24             	mov    %eax,(%esp)
  802460:	e8 94 35 00 00       	call   8059f9 <sys_mbox_fetch>
    switch (msg->type) {
  802465:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802468:	8b 10                	mov    (%eax),%edx
  80246a:	83 fa 01             	cmp    $0x1,%edx
  80246d:	74 20                	je     80248f <tcpip_thread+0xc9>
  80246f:	83 fa 01             	cmp    $0x1,%edx
  802472:	72 0e                	jb     802482 <tcpip_thread+0xbc>
  802474:	83 fa 02             	cmp    $0x2,%edx
  802477:	74 54                	je     8024cd <tcpip_thread+0x107>
  802479:	83 fa 03             	cmp    $0x3,%edx
  80247c:	75 d6                	jne    802454 <tcpip_thread+0x8e>
  80247e:	66 90                	xchg   %ax,%ax
  802480:	eb 6c                	jmp    8024ee <tcpip_thread+0x128>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  802482:	8b 40 08             	mov    0x8(%eax),%eax
  802485:	8d 50 04             	lea    0x4(%eax),%edx
  802488:	89 14 24             	mov    %edx,(%esp)
  80248b:	ff 10                	call   *(%eax)
      break;
  80248d:	eb c5                	jmp    802454 <tcpip_thread+0x8e>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  80248f:	8b 50 0c             	mov    0xc(%eax),%edx
  802492:	f6 42 2e 20          	testb  $0x20,0x2e(%edx)
  802496:	74 11                	je     8024a9 <tcpip_thread+0xe3>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  802498:	89 54 24 04          	mov    %edx,0x4(%esp)
  80249c:	8b 40 08             	mov    0x8(%eax),%eax
  80249f:	89 04 24             	mov    %eax,(%esp)
  8024a2:	e8 77 80 00 00       	call   80a51e <ethernet_input>
  8024a7:	eb 0f                	jmp    8024b8 <tcpip_thread+0xf2>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  8024a9:	89 54 24 04          	mov    %edx,0x4(%esp)
  8024ad:	8b 40 08             	mov    0x8(%eax),%eax
  8024b0:	89 04 24             	mov    %eax,(%esp)
  8024b3:	e8 52 49 00 00       	call   806e0a <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8024b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8024bb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8024bf:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8024c6:	e8 f9 25 00 00       	call   804ac4 <memp_free>
      break;
  8024cb:	eb 87                	jmp    802454 <tcpip_thread+0x8e>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  8024cd:	8b 50 0c             	mov    0xc(%eax),%edx
  8024d0:	89 14 24             	mov    %edx,(%esp)
  8024d3:	ff 50 08             	call   *0x8(%eax)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8024d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8024d9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8024dd:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8024e4:	e8 db 25 00 00       	call   804ac4 <memp_free>
      break;
  8024e9:	e9 66 ff ff ff       	jmp    802454 <tcpip_thread+0x8e>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8024ee:	8b 50 08             	mov    0x8(%eax),%edx
  8024f1:	83 fa ff             	cmp    $0xffffffff,%edx
  8024f4:	74 18                	je     80250e <tcpip_thread+0x148>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  8024f6:	8b 48 10             	mov    0x10(%eax),%ecx
  8024f9:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8024fd:	8b 40 0c             	mov    0xc(%eax),%eax
  802500:	89 44 24 04          	mov    %eax,0x4(%esp)
  802504:	89 14 24             	mov    %edx,(%esp)
  802507:	e8 0e 33 00 00       	call   80581a <sys_timeout>
  80250c:	eb 12                	jmp    802520 <tcpip_thread+0x15a>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  80250e:	8b 50 10             	mov    0x10(%eax),%edx
  802511:	89 54 24 04          	mov    %edx,0x4(%esp)
  802515:	8b 40 0c             	mov    0xc(%eax),%eax
  802518:	89 04 24             	mov    %eax,(%esp)
  80251b:	e8 6d 32 00 00       	call   80578d <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802520:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802523:	89 44 24 04          	mov    %eax,0x4(%esp)
  802527:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80252e:	e8 91 25 00 00       	call   804ac4 <memp_free>
  802533:	e9 1c ff ff ff       	jmp    802454 <tcpip_thread+0x8e>

00802538 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  802538:	55                   	push   %ebp
  802539:	89 e5                	mov    %esp,%ebp
  80253b:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  80253e:	e8 c5 1e 00 00       	call   804408 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802543:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80254a:	00 
  80254b:	c7 44 24 04 38 25 80 	movl   $0x802538,0x4(%esp)
  802552:	00 
  802553:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  80255a:	e8 bb 32 00 00       	call   80581a <sys_timeout>
}
  80255f:	c9                   	leave  
  802560:	c3                   	ret    

00802561 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  802561:	55                   	push   %ebp
  802562:	89 e5                	mov    %esp,%ebp
  802564:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  802567:	e8 7f 12 00 00       	call   8037eb <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  80256c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802573:	00 
  802574:	c7 44 24 04 61 25 80 	movl   $0x802561,0x4(%esp)
  80257b:	00 
  80257c:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  802583:	e8 92 32 00 00       	call   80581a <sys_timeout>
}
  802588:	c9                   	leave  
  802589:	c3                   	ret    

0080258a <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  80258a:	55                   	push   %ebp
  80258b:	89 e5                	mov    %esp,%ebp
  80258d:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  802590:	e8 68 7b 00 00       	call   80a0fd <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802595:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80259c:	00 
  80259d:	c7 44 24 04 8a 25 80 	movl   $0x80258a,0x4(%esp)
  8025a4:	00 
  8025a5:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  8025ac:	e8 69 32 00 00       	call   80581a <sys_timeout>
}
  8025b1:	c9                   	leave  
  8025b2:	c3                   	ret    

008025b3 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  8025b3:	55                   	push   %ebp
  8025b4:	89 e5                	mov    %esp,%ebp
  8025b6:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  8025b9:	e8 19 4f 00 00       	call   8074d7 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  8025be:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8025c5:	00 
  8025c6:	c7 44 24 04 b3 25 80 	movl   $0x8025b3,0x4(%esp)
  8025cd:	00 
  8025ce:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  8025d5:	e8 40 32 00 00       	call   80581a <sys_timeout>
}
  8025da:	c9                   	leave  
  8025db:	c3                   	ret    

008025dc <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  8025dc:	55                   	push   %ebp
  8025dd:	89 e5                	mov    %esp,%ebp
  8025df:	53                   	push   %ebx
  8025e0:	83 ec 34             	sub    $0x34,%esp
  8025e3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  8025e6:	8b 15 00 40 81 00    	mov    0x814000,%edx
  8025ec:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8025f1:	83 fa ff             	cmp    $0xffffffff,%edx
  8025f4:	74 34                	je     80262a <tcpip_apimsg+0x4e>
    msg.type = TCPIP_MSG_API;
  8025f6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  8025fd:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802600:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  802603:	89 44 24 04          	mov    %eax,0x4(%esp)
  802607:	89 14 24             	mov    %edx,(%esp)
  80260a:	e8 cb 88 00 00       	call   80aeda <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  80260f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802616:	00 
  802617:	8b 43 04             	mov    0x4(%ebx),%eax
  80261a:	8b 40 10             	mov    0x10(%eax),%eax
  80261d:	89 04 24             	mov    %eax,(%esp)
  802620:	e8 88 83 00 00       	call   80a9ad <sys_arch_sem_wait>
  802625:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  80262a:	83 c4 34             	add    $0x34,%esp
  80262d:	5b                   	pop    %ebx
  80262e:	5d                   	pop    %ebp
  80262f:	c3                   	ret    

00802630 <tcpip_timeout>:
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  802630:	55                   	push   %ebp
  802631:	89 e5                	mov    %esp,%ebp
  802633:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  802636:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80263b:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802642:	74 45                	je     802689 <tcpip_timeout+0x59>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802644:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80264b:	e8 b8 24 00 00       	call   804b08 <memp_malloc>
  802650:	89 c2                	mov    %eax,%edx
    if (msg == NULL) {
  802652:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802657:	85 d2                	test   %edx,%edx
  802659:	74 2e                	je     802689 <tcpip_timeout+0x59>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  80265b:	c7 02 03 00 00 00    	movl   $0x3,(%edx)
    msg->msg.tmo.msecs = msecs;
  802661:	8b 45 08             	mov    0x8(%ebp),%eax
  802664:	89 42 08             	mov    %eax,0x8(%edx)
    msg->msg.tmo.h = h;
  802667:	8b 45 0c             	mov    0xc(%ebp),%eax
  80266a:	89 42 0c             	mov    %eax,0xc(%edx)
    msg->msg.tmo.arg = arg;
  80266d:	8b 45 10             	mov    0x10(%ebp),%eax
  802670:	89 42 10             	mov    %eax,0x10(%edx)
    sys_mbox_post(mbox, msg);
  802673:	89 54 24 04          	mov    %edx,0x4(%esp)
  802677:	a1 00 40 81 00       	mov    0x814000,%eax
  80267c:	89 04 24             	mov    %eax,(%esp)
  80267f:	e8 56 88 00 00       	call   80aeda <sys_mbox_post>
  802684:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  802689:	c9                   	leave  
  80268a:	c3                   	ret    

0080268b <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  80268b:	55                   	push   %ebp
  80268c:	89 e5                	mov    %esp,%ebp
  80268e:	83 ec 18             	sub    $0x18,%esp
  802691:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802694:	89 75 fc             	mov    %esi,-0x4(%ebp)
  802697:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80269b:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8026a0:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8026a7:	74 6f                	je     802718 <tcpip_callback_with_block+0x8d>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8026a9:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8026b0:	e8 53 24 00 00       	call   804b08 <memp_malloc>
  8026b5:	89 c6                	mov    %eax,%esi
    if (msg == NULL) {
  8026b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8026bc:	85 f6                	test   %esi,%esi
  8026be:	74 58                	je     802718 <tcpip_callback_with_block+0x8d>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  8026c0:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
    msg->msg.cb.f = f;
  8026c6:	8b 45 08             	mov    0x8(%ebp),%eax
  8026c9:	89 46 08             	mov    %eax,0x8(%esi)
    msg->msg.cb.ctx = ctx;
  8026cc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8026cf:	89 46 0c             	mov    %eax,0xc(%esi)
    if (block) {
  8026d2:	84 db                	test   %bl,%bl
  8026d4:	74 18                	je     8026ee <tcpip_callback_with_block+0x63>
      sys_mbox_post(mbox, msg);
  8026d6:	89 74 24 04          	mov    %esi,0x4(%esp)
  8026da:	a1 00 40 81 00       	mov    0x814000,%eax
  8026df:	89 04 24             	mov    %eax,(%esp)
  8026e2:	e8 f3 87 00 00       	call   80aeda <sys_mbox_post>
  8026e7:	b8 00 00 00 00       	mov    $0x0,%eax
  8026ec:	eb 2a                	jmp    802718 <tcpip_callback_with_block+0x8d>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8026ee:	89 74 24 04          	mov    %esi,0x4(%esp)
  8026f2:	a1 00 40 81 00       	mov    0x814000,%eax
  8026f7:	89 04 24             	mov    %eax,(%esp)
  8026fa:	e8 0d 87 00 00       	call   80ae0c <sys_mbox_trypost>
  8026ff:	84 c0                	test   %al,%al
  802701:	74 15                	je     802718 <tcpip_callback_with_block+0x8d>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  802703:	89 74 24 04          	mov    %esi,0x4(%esp)
  802707:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80270e:	e8 b1 23 00 00       	call   804ac4 <memp_free>
  802713:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  802718:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80271b:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80271e:	89 ec                	mov    %ebp,%esp
  802720:	5d                   	pop    %ebp
  802721:	c3                   	ret    

00802722 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  802722:	55                   	push   %ebp
  802723:	89 e5                	mov    %esp,%ebp
  802725:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  802728:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80272f:	00 
  802730:	8b 45 08             	mov    0x8(%ebp),%eax
  802733:	89 44 24 04          	mov    %eax,0x4(%esp)
  802737:	c7 04 24 67 48 80 00 	movl   $0x804867,(%esp)
  80273e:	e8 48 ff ff ff       	call   80268b <tcpip_callback_with_block>
}
  802743:	c9                   	leave  
  802744:	c3                   	ret    

00802745 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  802745:	55                   	push   %ebp
  802746:	89 e5                	mov    %esp,%ebp
  802748:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  80274b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802752:	00 
  802753:	8b 45 08             	mov    0x8(%ebp),%eax
  802756:	89 44 24 04          	mov    %eax,0x4(%esp)
  80275a:	c7 04 24 10 23 80 00 	movl   $0x802310,(%esp)
  802761:	e8 25 ff ff ff       	call   80268b <tcpip_callback_with_block>
}
  802766:	c9                   	leave  
  802767:	c3                   	ret    

00802768 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  802768:	55                   	push   %ebp
  802769:	89 e5                	mov    %esp,%ebp
  80276b:	53                   	push   %ebx
  80276c:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80276f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  802774:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  80277b:	74 53                	je     8027d0 <tcpip_input+0x68>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  80277d:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  802784:	e8 7f 23 00 00       	call   804b08 <memp_malloc>
  802789:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  80278b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802790:	85 db                	test   %ebx,%ebx
  802792:	74 3c                	je     8027d0 <tcpip_input+0x68>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  802794:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
    msg->msg.inp.p = p;
  80279a:	8b 45 08             	mov    0x8(%ebp),%eax
  80279d:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8027a0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8027a3:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8027a6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8027aa:	a1 00 40 81 00       	mov    0x814000,%eax
  8027af:	89 04 24             	mov    %eax,(%esp)
  8027b2:	e8 55 86 00 00       	call   80ae0c <sys_mbox_trypost>
  8027b7:	84 c0                	test   %al,%al
  8027b9:	74 15                	je     8027d0 <tcpip_input+0x68>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8027bb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8027bf:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8027c6:	e8 f9 22 00 00       	call   804ac4 <memp_free>
  8027cb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  8027d0:	83 c4 14             	add    $0x14,%esp
  8027d3:	5b                   	pop    %ebx
  8027d4:	5d                   	pop    %ebp
  8027d5:	c3                   	ret    

008027d6 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  8027d6:	55                   	push   %ebp
  8027d7:	89 e5                	mov    %esp,%ebp
  8027d9:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  8027dc:	e8 be 41 00 00       	call   80699f <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  8027e1:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  8027e8:	75 09                	jne    8027f3 <tcpip_tcp_timer+0x1d>
  8027ea:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  8027f1:	74 1e                	je     802811 <tcpip_tcp_timer+0x3b>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8027f3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8027fa:	00 
  8027fb:	c7 44 24 04 d6 27 80 	movl   $0x8027d6,0x4(%esp)
  802802:	00 
  802803:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80280a:	e8 0b 30 00 00       	call   80581a <sys_timeout>
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  80280f:	eb 0a                	jmp    80281b <tcpip_tcp_timer+0x45>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  802811:	c7 05 f4 52 81 00 00 	movl   $0x0,0x8152f4
  802818:	00 00 00 
  }
}
  80281b:	c9                   	leave  
  80281c:	c3                   	ret    
  80281d:	00 00                	add    %al,(%eax)
	...

00802820 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  802820:	55                   	push   %ebp
  802821:	89 e5                	mov    %esp,%ebp
  802823:	83 ec 18             	sub    $0x18,%esp
  802826:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802829:	85 c0                	test   %eax,%eax
  80282b:	75 1c                	jne    802849 <netbuf_first+0x29>
  80282d:	c7 44 24 08 29 13 81 	movl   $0x811329,0x8(%esp)
  802834:	00 
  802835:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
  80283c:	00 
  80283d:	c7 04 24 42 13 81 00 	movl   $0x811342,(%esp)
  802844:	e8 a3 c9 00 00       	call   80f1ec <_panic>
  buf->ptr = buf->p;
  802849:	8b 10                	mov    (%eax),%edx
  80284b:	89 50 04             	mov    %edx,0x4(%eax)
}
  80284e:	c9                   	leave  
  80284f:	c3                   	ret    

00802850 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  802850:	55                   	push   %ebp
  802851:	89 e5                	mov    %esp,%ebp
  802853:	83 ec 18             	sub    $0x18,%esp
  802856:	8b 55 08             	mov    0x8(%ebp),%edx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  802859:	85 d2                	test   %edx,%edx
  80285b:	75 1c                	jne    802879 <netbuf_next+0x29>
  80285d:	c7 44 24 08 29 13 81 	movl   $0x811329,0x8(%esp)
  802864:	00 
  802865:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
  80286c:	00 
  80286d:	c7 04 24 42 13 81 00 	movl   $0x811342,(%esp)
  802874:	e8 73 c9 00 00       	call   80f1ec <_panic>
  if (buf->ptr->next == NULL) {
  802879:	8b 42 04             	mov    0x4(%edx),%eax
  80287c:	8b 08                	mov    (%eax),%ecx
  80287e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802883:	85 c9                	test   %ecx,%ecx
  802885:	74 09                	je     802890 <netbuf_next+0x40>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  802887:	89 4a 04             	mov    %ecx,0x4(%edx)
  80288a:	83 39 00             	cmpl   $0x0,(%ecx)
  80288d:	0f 94 c0             	sete   %al
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  802890:	c9                   	leave  
  802891:	c3                   	ret    

00802892 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  802892:	55                   	push   %ebp
  802893:	89 e5                	mov    %esp,%ebp
  802895:	56                   	push   %esi
  802896:	53                   	push   %ebx
  802897:	83 ec 10             	sub    $0x10,%esp
  80289a:	8b 55 08             	mov    0x8(%ebp),%edx
  80289d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8028a0:	8b 4d 10             	mov    0x10(%ebp),%ecx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  8028a3:	85 d2                	test   %edx,%edx
  8028a5:	75 1c                	jne    8028c3 <netbuf_data+0x31>
  8028a7:	c7 44 24 08 58 13 81 	movl   $0x811358,0x8(%esp)
  8028ae:	00 
  8028af:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  8028b6:	00 
  8028b7:	c7 04 24 42 13 81 00 	movl   $0x811342,(%esp)
  8028be:	e8 29 c9 00 00       	call   80f1ec <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  8028c3:	85 db                	test   %ebx,%ebx
  8028c5:	75 1c                	jne    8028e3 <netbuf_data+0x51>
  8028c7:	c7 44 24 08 71 13 81 	movl   $0x811371,0x8(%esp)
  8028ce:	00 
  8028cf:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
  8028d6:	00 
  8028d7:	c7 04 24 42 13 81 00 	movl   $0x811342,(%esp)
  8028de:	e8 09 c9 00 00       	call   80f1ec <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  8028e3:	85 c9                	test   %ecx,%ecx
  8028e5:	75 1c                	jne    802903 <netbuf_data+0x71>
  8028e7:	c7 44 24 08 8e 13 81 	movl   $0x81138e,0x8(%esp)
  8028ee:	00 
  8028ef:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  8028f6:	00 
  8028f7:	c7 04 24 42 13 81 00 	movl   $0x811342,(%esp)
  8028fe:	e8 e9 c8 00 00       	call   80f1ec <_panic>

  if (buf->ptr == NULL) {
  802903:	8b 72 04             	mov    0x4(%edx),%esi
  802906:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80290b:	85 f6                	test   %esi,%esi
  80290d:	74 14                	je     802923 <netbuf_data+0x91>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  80290f:	8b 46 04             	mov    0x4(%esi),%eax
  802912:	89 03                	mov    %eax,(%ebx)
  *len = buf->ptr->len;
  802914:	8b 42 04             	mov    0x4(%edx),%eax
  802917:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  80291b:	66 89 01             	mov    %ax,(%ecx)
  80291e:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  802923:	83 c4 10             	add    $0x10,%esp
  802926:	5b                   	pop    %ebx
  802927:	5e                   	pop    %esi
  802928:	5d                   	pop    %ebp
  802929:	c3                   	ret    

0080292a <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  80292a:	55                   	push   %ebp
  80292b:	89 e5                	mov    %esp,%ebp
  80292d:	83 ec 18             	sub    $0x18,%esp
  802930:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802933:	89 75 fc             	mov    %esi,-0x4(%ebp)
  802936:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802939:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  80293c:	85 db                	test   %ebx,%ebx
  80293e:	75 1c                	jne    80295c <netbuf_chain+0x32>
  802940:	c7 44 24 08 a7 13 81 	movl   $0x8113a7,0x8(%esp)
  802947:	00 
  802948:	c7 44 24 04 a6 00 00 	movl   $0xa6,0x4(%esp)
  80294f:	00 
  802950:	c7 04 24 42 13 81 00 	movl   $0x811342,(%esp)
  802957:	e8 90 c8 00 00       	call   80f1ec <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  80295c:	85 f6                	test   %esi,%esi
  80295e:	75 1c                	jne    80297c <netbuf_chain+0x52>
  802960:	c7 44 24 08 c0 13 81 	movl   $0x8113c0,0x8(%esp)
  802967:	00 
  802968:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  80296f:	00 
  802970:	c7 04 24 42 13 81 00 	movl   $0x811342,(%esp)
  802977:	e8 70 c8 00 00       	call   80f1ec <_panic>
  pbuf_chain(head->p, tail->p);
  80297c:	8b 06                	mov    (%esi),%eax
  80297e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802982:	8b 03                	mov    (%ebx),%eax
  802984:	89 04 24             	mov    %eax,(%esp)
  802987:	e8 14 25 00 00       	call   804ea0 <pbuf_chain>
  head->ptr = head->p;
  80298c:	8b 03                	mov    (%ebx),%eax
  80298e:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  802991:	89 74 24 04          	mov    %esi,0x4(%esp)
  802995:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80299c:	e8 23 21 00 00       	call   804ac4 <memp_free>
}
  8029a1:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8029a4:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8029a7:	89 ec                	mov    %ebp,%esp
  8029a9:	5d                   	pop    %ebp
  8029aa:	c3                   	ret    

008029ab <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8029ab:	55                   	push   %ebp
  8029ac:	89 e5                	mov    %esp,%ebp
  8029ae:	53                   	push   %ebx
  8029af:	83 ec 14             	sub    $0x14,%esp
  8029b2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8029b5:	85 db                	test   %ebx,%ebx
  8029b7:	75 1c                	jne    8029d5 <netbuf_free+0x2a>
  8029b9:	c7 44 24 08 29 13 81 	movl   $0x811329,0x8(%esp)
  8029c0:	00 
  8029c1:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  8029c8:	00 
  8029c9:	c7 04 24 42 13 81 00 	movl   $0x811342,(%esp)
  8029d0:	e8 17 c8 00 00       	call   80f1ec <_panic>
  if (buf->p != NULL) {
  8029d5:	8b 03                	mov    (%ebx),%eax
  8029d7:	85 c0                	test   %eax,%eax
  8029d9:	74 08                	je     8029e3 <netbuf_free+0x38>
    pbuf_free(buf->p);
  8029db:	89 04 24             	mov    %eax,(%esp)
  8029de:	e8 41 28 00 00       	call   805224 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  8029e3:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8029ea:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8029f0:	83 c4 14             	add    $0x14,%esp
  8029f3:	5b                   	pop    %ebx
  8029f4:	5d                   	pop    %ebp
  8029f5:	c3                   	ret    

008029f6 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8029f6:	55                   	push   %ebp
  8029f7:	89 e5                	mov    %esp,%ebp
  8029f9:	53                   	push   %ebx
  8029fa:	83 ec 14             	sub    $0x14,%esp
  8029fd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  802a00:	85 db                	test   %ebx,%ebx
  802a02:	74 2b                	je     802a2f <netbuf_delete+0x39>
    if (buf->p != NULL) {
  802a04:	8b 03                	mov    (%ebx),%eax
  802a06:	85 c0                	test   %eax,%eax
  802a08:	74 15                	je     802a1f <netbuf_delete+0x29>
      pbuf_free(buf->p);
  802a0a:	89 04 24             	mov    %eax,(%esp)
  802a0d:	e8 12 28 00 00       	call   805224 <pbuf_free>
      buf->p = buf->ptr = NULL;
  802a12:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802a19:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
    memp_free(MEMP_NETBUF, buf);
  802a1f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802a23:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  802a2a:	e8 95 20 00 00       	call   804ac4 <memp_free>
  }
}
  802a2f:	83 c4 14             	add    $0x14,%esp
  802a32:	5b                   	pop    %ebx
  802a33:	5d                   	pop    %ebp
  802a34:	c3                   	ret    

00802a35 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  802a35:	55                   	push   %ebp
  802a36:	89 e5                	mov    %esp,%ebp
  802a38:	56                   	push   %esi
  802a39:	53                   	push   %ebx
  802a3a:	83 ec 10             	sub    $0x10,%esp
  802a3d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802a40:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802a44:	85 db                	test   %ebx,%ebx
  802a46:	75 1c                	jne    802a64 <netbuf_ref+0x2f>
  802a48:	c7 44 24 08 db 13 81 	movl   $0x8113db,0x8(%esp)
  802a4f:	00 
  802a50:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  802a57:	00 
  802a58:	c7 04 24 42 13 81 00 	movl   $0x811342,(%esp)
  802a5f:	e8 88 c7 00 00       	call   80f1ec <_panic>
  if (buf->p != NULL) {
  802a64:	8b 03                	mov    (%ebx),%eax
  802a66:	85 c0                	test   %eax,%eax
  802a68:	74 08                	je     802a72 <netbuf_ref+0x3d>
    pbuf_free(buf->p);
  802a6a:	89 04 24             	mov    %eax,(%esp)
  802a6d:	e8 b2 27 00 00       	call   805224 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  802a72:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  802a79:	00 
  802a7a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802a81:	00 
  802a82:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802a89:	e8 51 2a 00 00       	call   8054df <pbuf_alloc>
  802a8e:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802a90:	85 c0                	test   %eax,%eax
  802a92:	75 0e                	jne    802aa2 <netbuf_ref+0x6d>
    buf->ptr = NULL;
  802a94:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802a9b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  802aa0:	eb 1a                	jmp    802abc <netbuf_ref+0x87>
  }
  buf->p->payload = (void*)dataptr;
  802aa2:	8b 55 0c             	mov    0xc(%ebp),%edx
  802aa5:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  802aa8:	8b 03                	mov    (%ebx),%eax
  802aaa:	66 89 70 08          	mov    %si,0x8(%eax)
  802aae:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  802ab2:	8b 03                	mov    (%ebx),%eax
  802ab4:	89 43 04             	mov    %eax,0x4(%ebx)
  802ab7:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  802abc:	83 c4 10             	add    $0x10,%esp
  802abf:	5b                   	pop    %ebx
  802ac0:	5e                   	pop    %esi
  802ac1:	5d                   	pop    %ebp
  802ac2:	c3                   	ret    

00802ac3 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  802ac3:	55                   	push   %ebp
  802ac4:	89 e5                	mov    %esp,%ebp
  802ac6:	56                   	push   %esi
  802ac7:	53                   	push   %ebx
  802ac8:	83 ec 10             	sub    $0x10,%esp
  802acb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802ace:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802ad2:	85 db                	test   %ebx,%ebx
  802ad4:	75 1c                	jne    802af2 <netbuf_alloc+0x2f>
  802ad6:	c7 44 24 08 f3 13 81 	movl   $0x8113f3,0x8(%esp)
  802add:	00 
  802ade:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  802ae5:	00 
  802ae6:	c7 04 24 42 13 81 00 	movl   $0x811342,(%esp)
  802aed:	e8 fa c6 00 00       	call   80f1ec <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802af2:	8b 03                	mov    (%ebx),%eax
  802af4:	85 c0                	test   %eax,%eax
  802af6:	74 08                	je     802b00 <netbuf_alloc+0x3d>
    pbuf_free(buf->p);
  802af8:	89 04 24             	mov    %eax,(%esp)
  802afb:	e8 24 27 00 00       	call   805224 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  802b00:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802b07:	00 
  802b08:	0f b7 c6             	movzwl %si,%eax
  802b0b:	89 44 24 04          	mov    %eax,0x4(%esp)
  802b0f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802b16:	e8 c4 29 00 00       	call   8054df <pbuf_alloc>
  802b1b:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802b1d:	ba 00 00 00 00       	mov    $0x0,%edx
  802b22:	85 c0                	test   %eax,%eax
  802b24:	74 28                	je     802b4e <netbuf_alloc+0x8b>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  802b26:	66 3b 70 0a          	cmp    0xa(%eax),%si
  802b2a:	76 1c                	jbe    802b48 <netbuf_alloc+0x85>
  802b2c:	c7 44 24 08 10 14 81 	movl   $0x811410,0x8(%esp)
  802b33:	00 
  802b34:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  802b3b:	00 
  802b3c:	c7 04 24 42 13 81 00 	movl   $0x811342,(%esp)
  802b43:	e8 a4 c6 00 00       	call   80f1ec <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  802b48:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  802b4b:	8b 50 04             	mov    0x4(%eax),%edx
}
  802b4e:	89 d0                	mov    %edx,%eax
  802b50:	83 c4 10             	add    $0x10,%esp
  802b53:	5b                   	pop    %ebx
  802b54:	5e                   	pop    %esi
  802b55:	5d                   	pop    %ebp
  802b56:	c3                   	ret    

00802b57 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  802b57:	55                   	push   %ebp
  802b58:	89 e5                	mov    %esp,%ebp
  802b5a:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  802b5d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  802b64:	e8 9f 1f 00 00       	call   804b08 <memp_malloc>
  if (buf != NULL) {
  802b69:	85 c0                	test   %eax,%eax
  802b6b:	74 14                	je     802b81 <netbuf_new+0x2a>
    buf->p = NULL;
  802b6d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  802b73:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  802b7a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  802b81:	c9                   	leave  
  802b82:	c3                   	ret    
	...

00802b90 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  802b90:	55                   	push   %ebp
  802b91:	89 e5                	mov    %esp,%ebp
  802b93:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  802b96:	e8 35 7a 00 00       	call   80a5d0 <sys_init>
  mem_init();
  802b9b:	e8 65 1e 00 00       	call   804a05 <mem_init>
  memp_init();
  802ba0:	e8 bf 1e 00 00       	call   804a64 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802ba5:	e8 78 e9 ff ff       	call   801522 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  802baa:	c9                   	leave  
  802bab:	c3                   	ret    
  802bac:	00 00                	add    %al,(%eax)
	...

00802bb0 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  802bb0:	55                   	push   %ebp
  802bb1:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  802bb3:	38 10                	cmp    %dl,(%eax)
  802bb5:	74 06                	je     802bbd <dhcp_set_state+0xd>
    dhcp->state = new_state;
  802bb7:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  802bb9:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  802bbd:	5d                   	pop    %ebp
  802bbe:	c3                   	ret    

00802bbf <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  802bbf:	55                   	push   %ebp
  802bc0:	89 e5                	mov    %esp,%ebp
  802bc2:	57                   	push   %edi
  802bc3:	56                   	push   %esi
  802bc4:	53                   	push   %ebx
  802bc5:	83 ec 08             	sub    $0x8,%esp
  802bc8:	88 55 f3             	mov    %dl,-0xd(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802bcb:	8b 70 14             	mov    0x14(%eax),%esi
  802bce:	85 f6                	test   %esi,%esi
  802bd0:	0f 84 c8 00 00 00    	je     802c9e <dhcp_get_option_ptr+0xdf>
  802bd6:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  802bda:	66 85 ff             	test   %di,%di
  802bdd:	0f 84 bb 00 00 00    	je     802c9e <dhcp_get_option_ptr+0xdf>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
  802be3:	ba 00 00 00 00       	mov    $0x0,%edx
  802be8:	c6 45 f2 00          	movb   $0x0,-0xe(%ebp)
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802bec:	eb 2e                	jmp    802c1c <dhcp_get_option_ptr+0x5d>
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  802bee:	80 f9 34             	cmp    $0x34,%cl
  802bf1:	75 12                	jne    802c05 <dhcp_get_option_ptr+0x46>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  802bf3:	8d 4a 02             	lea    0x2(%edx),%ecx
        overload = options[offset++];
  802bf6:	0f b7 c9             	movzwl %cx,%ecx
  802bf9:	0f b6 0c 0e          	movzbl (%esi,%ecx,1),%ecx
  802bfd:	88 4d f2             	mov    %cl,-0xe(%ebp)
  802c00:	83 c2 03             	add    $0x3,%edx
  802c03:	eb 17                	jmp    802c1c <dhcp_get_option_ptr+0x5d>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  802c05:	3a 4d f3             	cmp    -0xd(%ebp),%cl
  802c08:	0f 84 95 00 00 00    	je     802ca3 <dhcp_get_option_ptr+0xe4>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  802c0e:	8d 4a 01             	lea    0x1(%edx),%ecx
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  802c11:	0f b7 c9             	movzwl %cx,%ecx
  802c14:	0f b6 0c 0e          	movzbl (%esi,%ecx,1),%ecx
  802c18:	8d 54 0a 02          	lea    0x2(%edx,%ecx,1),%edx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802c1c:	66 39 fa             	cmp    %di,%dx
  802c1f:	73 0e                	jae    802c2f <dhcp_get_option_ptr+0x70>
  802c21:	0f b7 da             	movzwl %dx,%ebx
  802c24:	8d 1c 1e             	lea    (%esi,%ebx,1),%ebx
  802c27:	0f b6 0b             	movzbl (%ebx),%ecx
  802c2a:	80 f9 ff             	cmp    $0xff,%cl
  802c2d:	75 bf                	jne    802bee <dhcp_get_option_ptr+0x2f>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  802c2f:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
  802c33:	74 69                	je     802c9e <dhcp_get_option_ptr+0xdf>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  802c35:	80 7d f2 01          	cmpb   $0x1,-0xe(%ebp)
  802c39:	75 0d                	jne    802c48 <dhcp_get_option_ptr+0x89>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  802c3b:	8b 48 10             	mov    0x10(%eax),%ecx
  802c3e:	83 c1 6c             	add    $0x6c,%ecx
  802c41:	be 80 00 00 00       	mov    $0x80,%esi
  802c46:	eb 1e                	jmp    802c66 <dhcp_get_option_ptr+0xa7>
        field_len = DHCP_FILE_LEN;
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  802c48:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
  802c4c:	75 0d                	jne    802c5b <dhcp_get_option_ptr+0x9c>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802c4e:	8b 48 10             	mov    0x10(%eax),%ecx
  802c51:	83 c1 2c             	add    $0x2c,%ecx
  802c54:	be 40 00 00 00       	mov    $0x40,%esi
  802c59:	eb 0b                	jmp    802c66 <dhcp_get_option_ptr+0xa7>
        field_len = DHCP_SNAME_LEN;
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802c5b:	8b 48 10             	mov    0x10(%eax),%ecx
  802c5e:	83 c1 2c             	add    $0x2c,%ecx
  802c61:	be c0 00 00 00       	mov    $0xc0,%esi
  802c66:	b8 00 00 00 00       	mov    $0x0,%eax
  802c6b:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  802c6e:	0f b6 7d f3          	movzbl -0xd(%ebp),%edi
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802c72:	eb 17                	jmp    802c8b <dhcp_get_option_ptr+0xcc>
        if (options[offset] == option_type) {
  802c74:	89 f9                	mov    %edi,%ecx
  802c76:	38 d1                	cmp    %dl,%cl
  802c78:	74 29                	je     802ca3 <dhcp_get_option_ptr+0xe4>
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  802c7a:	8d 50 01             	lea    0x1(%eax),%edx
          offset += 1 + options[offset];
  802c7d:	0f b7 d2             	movzwl %dx,%edx
  802c80:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  802c83:	0f b6 14 11          	movzbl (%ecx,%edx,1),%edx
  802c87:	8d 44 02 02          	lea    0x2(%edx,%eax,1),%eax
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802c8b:	66 39 f0             	cmp    %si,%ax
  802c8e:	73 0e                	jae    802c9e <dhcp_get_option_ptr+0xdf>
  802c90:	0f b7 d8             	movzwl %ax,%ebx
  802c93:	03 5d ec             	add    -0x14(%ebp),%ebx
  802c96:	0f b6 13             	movzbl (%ebx),%edx
  802c99:	80 fa ff             	cmp    $0xff,%dl
  802c9c:	75 d6                	jne    802c74 <dhcp_get_option_ptr+0xb5>
  802c9e:	bb 00 00 00 00       	mov    $0x0,%ebx
        }
      }
    }
  }
  return NULL;
}
  802ca3:	89 d8                	mov    %ebx,%eax
  802ca5:	83 c4 08             	add    $0x8,%esp
  802ca8:	5b                   	pop    %ebx
  802ca9:	5e                   	pop    %esi
  802caa:	5f                   	pop    %edi
  802cab:	5d                   	pop    %ebp
  802cac:	c3                   	ret    

00802cad <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  802cad:	55                   	push   %ebp
  802cae:	89 e5                	mov    %esp,%ebp
  802cb0:	0f b6 00             	movzbl (%eax),%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
}
  802cb3:	5d                   	pop    %ebp
  802cb4:	c3                   	ret    

00802cb5 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  802cb5:	55                   	push   %ebp
  802cb6:	89 e5                	mov    %esp,%ebp
  802cb8:	53                   	push   %ebx
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802cb9:	0f b6 10             	movzbl (%eax),%edx
  802cbc:	c1 e2 18             	shl    $0x18,%edx
  value |= (u32_t)(*ptr++) << 16;
  802cbf:	0f b6 58 01          	movzbl 0x1(%eax),%ebx
  802cc3:	c1 e3 10             	shl    $0x10,%ebx
  802cc6:	09 d3                	or     %edx,%ebx
  802cc8:	8d 50 02             	lea    0x2(%eax),%edx
  value |= (u32_t)(*ptr++) << 8;
  802ccb:	0f b6 0a             	movzbl (%edx),%ecx
  802cce:	c1 e1 08             	shl    $0x8,%ecx
  802cd1:	89 d8                	mov    %ebx,%eax
  802cd3:	09 c8                	or     %ecx,%eax
  802cd5:	0f b6 52 01          	movzbl 0x1(%edx),%edx
  802cd9:	09 d0                	or     %edx,%eax
  value |= (u32_t)(*ptr++);
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  802cdb:	5b                   	pop    %ebx
  802cdc:	5d                   	pop    %ebp
  802cdd:	c3                   	ret    

00802cde <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  802cde:	55                   	push   %ebp
  802cdf:	89 e5                	mov    %esp,%ebp
  802ce1:	83 ec 28             	sub    $0x28,%esp
  802ce4:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  802ce7:	89 75 f8             	mov    %esi,-0x8(%ebp)
  802cea:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802ced:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  802cf1:	0f b7 fb             	movzwl %bx,%edi
  802cf4:	0f b6 f1             	movzbl %cl,%esi
  802cf7:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  802cfb:	83 fe 44             	cmp    $0x44,%esi
  802cfe:	76 1c                	jbe    802d1c <dhcp_option+0x3e>
  802d00:	c7 44 24 08 34 14 81 	movl   $0x811434,0x8(%esp)
  802d07:	00 
  802d08:	c7 44 24 04 5a 04 00 	movl   $0x45a,0x4(%esp)
  802d0f:	00 
  802d10:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  802d17:	e8 d0 c4 00 00       	call   80f1ec <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  802d1c:	8b 78 20             	mov    0x20(%eax),%edi
  802d1f:	0f b7 f3             	movzwl %bx,%esi
  802d22:	88 94 37 f0 00 00 00 	mov    %dl,0xf0(%edi,%esi,1)
  802d29:	8d 53 01             	lea    0x1(%ebx),%edx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  802d2c:	8b 70 20             	mov    0x20(%eax),%esi
  802d2f:	0f b7 d2             	movzwl %dx,%edx
  802d32:	88 8c 16 f0 00 00 00 	mov    %cl,0xf0(%esi,%edx,1)
  802d39:	83 c3 02             	add    $0x2,%ebx
  802d3c:	66 89 58 24          	mov    %bx,0x24(%eax)
}
  802d40:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  802d43:	8b 75 f8             	mov    -0x8(%ebp),%esi
  802d46:	8b 7d fc             	mov    -0x4(%ebp),%edi
  802d49:	89 ec                	mov    %ebp,%esp
  802d4b:	5d                   	pop    %ebp
  802d4c:	c3                   	ret    

00802d4d <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  802d4d:	55                   	push   %ebp
  802d4e:	89 e5                	mov    %esp,%ebp
  802d50:	83 ec 18             	sub    $0x18,%esp
  802d53:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802d56:	89 75 fc             	mov    %esi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802d59:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802d5d:	66 83 f9 43          	cmp    $0x43,%cx
  802d61:	76 1c                	jbe    802d7f <dhcp_option_byte+0x32>
  802d63:	c7 44 24 08 7c 14 81 	movl   $0x81147c,0x8(%esp)
  802d6a:	00 
  802d6b:	c7 44 24 04 65 04 00 	movl   $0x465,0x4(%esp)
  802d72:	00 
  802d73:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  802d7a:	e8 6d c4 00 00       	call   80f1ec <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802d7f:	8b 70 20             	mov    0x20(%eax),%esi
  802d82:	0f b7 d9             	movzwl %cx,%ebx
  802d85:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  802d8c:	83 c1 01             	add    $0x1,%ecx
  802d8f:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  802d93:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802d96:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802d99:	89 ec                	mov    %ebp,%esp
  802d9b:	5d                   	pop    %ebp
  802d9c:	c3                   	ret    

00802d9d <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  802d9d:	55                   	push   %ebp
  802d9e:	89 e5                	mov    %esp,%ebp
  802da0:	53                   	push   %ebx
  802da1:	83 ec 14             	sub    $0x14,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802da4:	85 c0                	test   %eax,%eax
  802da6:	75 1c                	jne    802dc4 <dhcp_option_trailer+0x27>
  802da8:	c7 44 24 08 b8 14 81 	movl   $0x8114b8,0x8(%esp)
  802daf:	00 
  802db0:	c7 44 24 04 80 05 00 	movl   $0x580,0x4(%esp)
  802db7:	00 
  802db8:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  802dbf:	e8 28 c4 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802dc4:	8b 48 20             	mov    0x20(%eax),%ecx
  802dc7:	85 c9                	test   %ecx,%ecx
  802dc9:	75 1c                	jne    802de7 <dhcp_option_trailer+0x4a>
  802dcb:	c7 44 24 08 dc 14 81 	movl   $0x8114dc,0x8(%esp)
  802dd2:	00 
  802dd3:	c7 44 24 04 81 05 00 	movl   $0x581,0x4(%esp)
  802dda:	00 
  802ddb:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  802de2:	e8 05 c4 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802de7:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802deb:	66 83 fa 43          	cmp    $0x43,%dx
  802def:	76 1c                	jbe    802e0d <dhcp_option_trailer+0x70>
  802df1:	c7 44 24 08 08 15 81 	movl   $0x811508,0x8(%esp)
  802df8:	00 
  802df9:	c7 44 24 04 82 05 00 	movl   $0x582,0x4(%esp)
  802e00:	00 
  802e01:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  802e08:	e8 df c3 00 00       	call   80f1ec <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802e0d:	0f b7 da             	movzwl %dx,%ebx
  802e10:	c6 84 19 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%ebx,1)
  802e17:	ff 
  802e18:	83 c2 01             	add    $0x1,%edx
  802e1b:	66 89 50 24          	mov    %dx,0x24(%eax)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802e1f:	eb 31                	jmp    802e52 <dhcp_option_trailer+0xb5>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802e21:	c7 44 24 08 08 15 81 	movl   $0x811508,0x8(%esp)
  802e28:	00 
  802e29:	c7 44 24 04 87 05 00 	movl   $0x587,0x4(%esp)
  802e30:	00 
  802e31:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  802e38:	e8 af c3 00 00       	call   80f1ec <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802e3d:	8b 58 20             	mov    0x20(%eax),%ebx
  802e40:	0f b7 ca             	movzwl %dx,%ecx
  802e43:	c6 84 0b f0 00 00 00 	movb   $0x0,0xf0(%ebx,%ecx,1)
  802e4a:	00 
  802e4b:	83 c2 01             	add    $0x1,%edx
  802e4e:	66 89 50 24          	mov    %dx,0x24(%eax)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802e52:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802e56:	66 83 fa 43          	cmp    $0x43,%dx
  802e5a:	76 e1                	jbe    802e3d <dhcp_option_trailer+0xa0>
  802e5c:	f6 c2 03             	test   $0x3,%dl
  802e5f:	75 c0                	jne    802e21 <dhcp_option_trailer+0x84>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  802e61:	83 c4 14             	add    $0x14,%esp
  802e64:	5b                   	pop    %ebx
  802e65:	5d                   	pop    %ebp
  802e66:	c3                   	ret    

00802e67 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  802e67:	55                   	push   %ebp
  802e68:	89 e5                	mov    %esp,%ebp
  802e6a:	83 ec 48             	sub    $0x48,%esp
  802e6d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  802e70:	89 75 f8             	mov    %esi,-0x8(%ebp)
  802e73:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802e76:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802e7a:	0f b7 d9             	movzwl %cx,%ebx
  802e7d:	83 c3 02             	add    $0x2,%ebx
  802e80:	83 fb 44             	cmp    $0x44,%ebx
  802e83:	76 1c                	jbe    802ea1 <dhcp_option_short+0x3a>
  802e85:	c7 44 24 08 48 15 81 	movl   $0x811548,0x8(%esp)
  802e8c:	00 
  802e8d:	c7 44 24 04 6c 04 00 	movl   $0x46c,0x4(%esp)
  802e94:	00 
  802e95:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  802e9c:	e8 4b c3 00 00       	call   80f1ec <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  802ea1:	0f b7 d9             	movzwl %cx,%ebx
  802ea4:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  802ea7:	89 d6                	mov    %edx,%esi
  802ea9:	66 c1 ee 08          	shr    $0x8,%si
  802ead:	66 89 75 d6          	mov    %si,-0x2a(%ebp)
  802eb1:	0f b6 5d d6          	movzbl -0x2a(%ebp),%ebx
  802eb5:	8b 78 20             	mov    0x20(%eax),%edi
  802eb8:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802ebb:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  802ec2:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802ec5:	8b 70 20             	mov    0x20(%eax),%esi
  802ec8:	0f b7 db             	movzwl %bx,%ebx
  802ecb:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  802ed2:	83 c1 02             	add    $0x2,%ecx
  802ed5:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  802ed9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  802edc:	8b 75 f8             	mov    -0x8(%ebp),%esi
  802edf:	8b 7d fc             	mov    -0x4(%ebp),%edi
  802ee2:	89 ec                	mov    %ebp,%esp
  802ee4:	5d                   	pop    %ebp
  802ee5:	c3                   	ret    

00802ee6 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  802ee6:	55                   	push   %ebp
  802ee7:	89 e5                	mov    %esp,%ebp
  802ee9:	83 ec 48             	sub    $0x48,%esp
  802eec:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  802eef:	89 75 f8             	mov    %esi,-0x8(%ebp)
  802ef2:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802ef5:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802ef9:	0f b7 d9             	movzwl %cx,%ebx
  802efc:	83 c3 04             	add    $0x4,%ebx
  802eff:	83 fb 44             	cmp    $0x44,%ebx
  802f02:	76 1c                	jbe    802f20 <dhcp_option_long+0x3a>
  802f04:	c7 44 24 08 8c 15 81 	movl   $0x81158c,0x8(%esp)
  802f0b:	00 
  802f0c:	c7 44 24 04 74 04 00 	movl   $0x474,0x4(%esp)
  802f13:	00 
  802f14:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  802f1b:	e8 cc c2 00 00       	call   80f1ec <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802f20:	0f b7 d9             	movzwl %cx,%ebx
  802f23:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  802f26:	89 d6                	mov    %edx,%esi
  802f28:	c1 ee 18             	shr    $0x18,%esi
  802f2b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  802f2e:	0f b6 5d d4          	movzbl -0x2c(%ebp),%ebx
  802f32:	8b 78 20             	mov    0x20(%eax),%edi
  802f35:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802f38:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  802f3f:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802f42:	0f b7 db             	movzwl %bx,%ebx
  802f45:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  802f48:	89 d3                	mov    %edx,%ebx
  802f4a:	c1 eb 10             	shr    $0x10,%ebx
  802f4d:	8b 78 20             	mov    0x20(%eax),%edi
  802f50:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802f53:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  802f5a:	8d 59 02             	lea    0x2(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802f5d:	0f b7 db             	movzwl %bx,%ebx
  802f60:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  802f63:	0f b6 de             	movzbl %dh,%ebx
  802f66:	8b 78 20             	mov    0x20(%eax),%edi
  802f69:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802f6c:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  802f73:	8d 59 03             	lea    0x3(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802f76:	8b 70 20             	mov    0x20(%eax),%esi
  802f79:	0f b7 db             	movzwl %bx,%ebx
  802f7c:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  802f83:	83 c1 04             	add    $0x4,%ecx
  802f86:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  802f8a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  802f8d:	8b 75 f8             	mov    -0x8(%ebp),%esi
  802f90:	8b 7d fc             	mov    -0x4(%ebp),%edi
  802f93:	89 ec                	mov    %ebp,%esp
  802f95:	5d                   	pop    %ebp
  802f96:	c3                   	ret    

00802f97 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  802f97:	55                   	push   %ebp
  802f98:	89 e5                	mov    %esp,%ebp
  802f9a:	53                   	push   %ebx
  802f9b:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802f9e:	85 c0                	test   %eax,%eax
  802fa0:	75 1c                	jne    802fbe <dhcp_delete_request+0x27>
  802fa2:	c7 44 24 08 cc 15 81 	movl   $0x8115cc,0x8(%esp)
  802fa9:	00 
  802faa:	c7 44 24 04 69 05 00 	movl   $0x569,0x4(%esp)
  802fb1:	00 
  802fb2:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  802fb9:	e8 2e c2 00 00       	call   80f1ec <_panic>
  dhcp = netif->dhcp;
  802fbe:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802fc1:	85 db                	test   %ebx,%ebx
  802fc3:	75 1c                	jne    802fe1 <dhcp_delete_request+0x4a>
  802fc5:	c7 44 24 08 f0 15 81 	movl   $0x8115f0,0x8(%esp)
  802fcc:	00 
  802fcd:	c7 44 24 04 6b 05 00 	movl   $0x56b,0x4(%esp)
  802fd4:	00 
  802fd5:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  802fdc:	e8 0b c2 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802fe1:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802fe4:	85 c0                	test   %eax,%eax
  802fe6:	75 1c                	jne    803004 <dhcp_delete_request+0x6d>
  802fe8:	c7 44 24 08 14 16 81 	movl   $0x811614,0x8(%esp)
  802fef:	00 
  802ff0:	c7 44 24 04 6c 05 00 	movl   $0x56c,0x4(%esp)
  802ff7:	00 
  802ff8:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  802fff:	e8 e8 c1 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  803004:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  803008:	75 1c                	jne    803026 <dhcp_delete_request+0x8f>
  80300a:	c7 44 24 08 40 16 81 	movl   $0x811640,0x8(%esp)
  803011:	00 
  803012:	c7 44 24 04 6d 05 00 	movl   $0x56d,0x4(%esp)
  803019:	00 
  80301a:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  803021:	e8 c6 c1 00 00       	call   80f1ec <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  803026:	89 04 24             	mov    %eax,(%esp)
  803029:	e8 f6 21 00 00       	call   805224 <pbuf_free>
  }
  dhcp->p_out = NULL;
  80302e:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  803035:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  80303c:	83 c4 14             	add    $0x14,%esp
  80303f:	5b                   	pop    %ebx
  803040:	5d                   	pop    %ebp
  803041:	c3                   	ret    

00803042 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  803042:	55                   	push   %ebp
  803043:	89 e5                	mov    %esp,%ebp
  803045:	53                   	push   %ebx
  803046:	83 ec 14             	sub    $0x14,%esp
  803049:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  80304b:	8b 40 10             	mov    0x10(%eax),%eax
  80304e:	85 c0                	test   %eax,%eax
  803050:	74 0f                	je     803061 <dhcp_free_reply+0x1f>
    mem_free((void *)dhcp->msg_in);
  803052:	89 04 24             	mov    %eax,(%esp)
  803055:	e8 0d 18 00 00       	call   804867 <mem_free>
    dhcp->msg_in = NULL;
  80305a:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  }
  if (dhcp->options_in) {
  803061:	8b 43 14             	mov    0x14(%ebx),%eax
  803064:	85 c0                	test   %eax,%eax
  803066:	74 15                	je     80307d <dhcp_free_reply+0x3b>
    mem_free((void *)dhcp->options_in);
  803068:	89 04 24             	mov    %eax,(%esp)
  80306b:	e8 f7 17 00 00       	call   804867 <mem_free>
    dhcp->options_in = NULL;
  803070:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  803077:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  80307d:	83 c4 14             	add    $0x14,%esp
  803080:	5b                   	pop    %ebx
  803081:	5d                   	pop    %ebp
  803082:	c3                   	ret    

00803083 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  803083:	55                   	push   %ebp
  803084:	89 e5                	mov    %esp,%ebp
  803086:	56                   	push   %esi
  803087:	53                   	push   %ebx
  803088:	83 ec 10             	sub    $0x10,%esp
  80308b:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  80308e:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  803091:	85 f6                	test   %esi,%esi
  803093:	75 1c                	jne    8030b1 <dhcp_stop+0x2e>
  803095:	c7 44 24 08 97 17 81 	movl   $0x811797,0x8(%esp)
  80309c:	00 
  80309d:	c7 44 24 04 2c 04 00 	movl   $0x42c,0x4(%esp)
  8030a4:	00 
  8030a5:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  8030ac:	e8 3b c1 00 00       	call   80f1ec <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  8030b1:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  8030b5:	85 db                	test   %ebx,%ebx
  8030b7:	74 42                	je     8030fb <dhcp_stop+0x78>
    if (dhcp->pcb != NULL) {
  8030b9:	8b 43 08             	mov    0x8(%ebx),%eax
  8030bc:	85 c0                	test   %eax,%eax
  8030be:	74 0f                	je     8030cf <dhcp_stop+0x4c>
      udp_remove(dhcp->pcb);
  8030c0:	89 04 24             	mov    %eax,(%esp)
  8030c3:	e8 44 61 00 00       	call   80920c <udp_remove>
      dhcp->pcb = NULL;
  8030c8:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    }
    if (dhcp->p != NULL) {
  8030cf:	8b 43 0c             	mov    0xc(%ebx),%eax
  8030d2:	85 c0                	test   %eax,%eax
  8030d4:	74 0f                	je     8030e5 <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  8030d6:	89 04 24             	mov    %eax,(%esp)
  8030d9:	e8 46 21 00 00       	call   805224 <pbuf_free>
      dhcp->p = NULL;
  8030de:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  8030e5:	89 d8                	mov    %ebx,%eax
  8030e7:	e8 56 ff ff ff       	call   803042 <dhcp_free_reply>
    mem_free((void *)dhcp);
  8030ec:	89 1c 24             	mov    %ebx,(%esp)
  8030ef:	e8 73 17 00 00       	call   804867 <mem_free>
    netif->dhcp = NULL;
  8030f4:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  }
}
  8030fb:	83 c4 10             	add    $0x10,%esp
  8030fe:	5b                   	pop    %ebx
  8030ff:	5e                   	pop    %esi
  803100:	5d                   	pop    %ebp
  803101:	c3                   	ret    

00803102 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  803102:	55                   	push   %ebp
  803103:	89 e5                	mov    %esp,%ebp
  803105:	57                   	push   %edi
  803106:	56                   	push   %esi
  803107:	53                   	push   %ebx
  803108:	83 ec 2c             	sub    $0x2c,%esp
  80310b:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  80310d:	85 c0                	test   %eax,%eax
  80310f:	75 1c                	jne    80312d <dhcp_create_request+0x2b>
  803111:	c7 44 24 08 6c 16 81 	movl   $0x81166c,0x8(%esp)
  803118:	00 
  803119:	c7 44 24 04 2d 05 00 	movl   $0x52d,0x4(%esp)
  803120:	00 
  803121:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  803128:	e8 bf c0 00 00       	call   80f1ec <_panic>
  dhcp = netif->dhcp;
  80312d:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  803130:	85 db                	test   %ebx,%ebx
  803132:	75 1c                	jne    803150 <dhcp_create_request+0x4e>
  803134:	c7 44 24 08 90 16 81 	movl   $0x811690,0x8(%esp)
  80313b:	00 
  80313c:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp)
  803143:	00 
  803144:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  80314b:	e8 9c c0 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  803150:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  803154:	74 1c                	je     803172 <dhcp_create_request+0x70>
  803156:	c7 44 24 08 b4 16 81 	movl   $0x8116b4,0x8(%esp)
  80315d:	00 
  80315e:	c7 44 24 04 30 05 00 	movl   $0x530,0x4(%esp)
  803165:	00 
  803166:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  80316d:	e8 7a c0 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  803172:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  803176:	74 1c                	je     803194 <dhcp_create_request+0x92>
  803178:	c7 44 24 08 e0 16 81 	movl   $0x8116e0,0x8(%esp)
  80317f:	00 
  803180:	c7 44 24 04 31 05 00 	movl   $0x531,0x4(%esp)
  803187:	00 
  803188:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  80318f:	e8 58 c0 00 00       	call   80f1ec <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  803194:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80319b:	00 
  80319c:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  8031a3:	00 
  8031a4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8031ab:	e8 2f 23 00 00       	call   8054df <pbuf_alloc>
  8031b0:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  8031b3:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8031b8:	85 c0                	test   %eax,%eax
  8031ba:	0f 84 2d 01 00 00    	je     8032ed <dhcp_create_request+0x1eb>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  8031c0:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  8031c6:	77 1c                	ja     8031e4 <dhcp_create_request+0xe2>
  8031c8:	c7 44 24 08 0c 17 81 	movl   $0x81170c,0x8(%esp)
  8031cf:	00 
  8031d0:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  8031d7:	00 
  8031d8:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  8031df:	e8 08 c0 00 00       	call   80f1ec <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  8031e4:	8b 15 04 40 81 00    	mov    0x814004,%edx
  8031ea:	89 53 04             	mov    %edx,0x4(%ebx)
  8031ed:	83 c2 01             	add    $0x1,%edx
  8031f0:	89 15 04 40 81 00    	mov    %edx,0x814004
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  8031f6:	8b 40 04             	mov    0x4(%eax),%eax
  8031f9:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  8031fc:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  8031ff:	8b 43 20             	mov    0x20(%ebx),%eax
  803202:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  803206:	8b 43 20             	mov    0x20(%ebx),%eax
  803209:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  80320d:	8b 43 20             	mov    0x20(%ebx),%eax
  803210:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  803214:	8b 73 20             	mov    0x20(%ebx),%esi
  803217:	8b 43 04             	mov    0x4(%ebx),%eax
  80321a:	89 04 24             	mov    %eax,(%esp)
  80321d:	e8 5e 4c 00 00       	call   807e80 <htonl>
  803222:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  803225:	8b 43 20             	mov    0x20(%ebx),%eax
  803228:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  80322e:	8b 43 20             	mov    0x20(%ebx),%eax
  803231:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  803237:	8b 43 20             	mov    0x20(%ebx),%eax
  80323a:	8b 57 04             	mov    0x4(%edi),%edx
  80323d:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  803240:	8b 43 20             	mov    0x20(%ebx),%eax
  803243:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  80324a:	8b 43 20             	mov    0x20(%ebx),%eax
  80324d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  803254:	8b 43 20             	mov    0x20(%ebx),%eax
  803257:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  80325e:	b8 00 00 00 00       	mov    $0x0,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  803263:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  803266:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  803269:	8b 5a 20             	mov    0x20(%edx),%ebx
  80326c:	89 c1                	mov    %eax,%ecx
  80326e:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  803272:	ba 00 00 00 00       	mov    $0x0,%edx
  803277:	66 39 c6             	cmp    %ax,%si
  80327a:	76 05                	jbe    803281 <dhcp_create_request+0x17f>
  80327c:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  803281:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  803285:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  803288:	83 f8 10             	cmp    $0x10,%eax
  80328b:	75 d9                	jne    803266 <dhcp_create_request+0x164>
  80328d:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  803290:	b0 00                	mov    $0x0,%al
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  803292:	8b 53 20             	mov    0x20(%ebx),%edx
  803295:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  80329a:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80329d:	83 f8 40             	cmp    $0x40,%eax
  8032a0:	75 f0                	jne    803292 <dhcp_create_request+0x190>
  8032a2:	b0 00                	mov    $0x0,%al
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  8032a4:	8b 53 20             	mov    0x20(%ebx),%edx
  8032a7:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  8032ac:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  8032af:	3d 80 00 00 00       	cmp    $0x80,%eax
  8032b4:	75 ee                	jne    8032a4 <dhcp_create_request+0x1a2>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  8032b6:	8b 73 20             	mov    0x20(%ebx),%esi
  8032b9:	c7 04 24 63 53 82 63 	movl   $0x63825363,(%esp)
  8032c0:	e8 bb 4b 00 00       	call   807e80 <htonl>
  8032c5:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  8032cb:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  8032d1:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  8032d6:	8b 53 20             	mov    0x20(%ebx),%edx
  8032d9:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  8032e0:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  8032e3:	83 f8 44             	cmp    $0x44,%eax
  8032e6:	75 ee                	jne    8032d6 <dhcp_create_request+0x1d4>
  8032e8:	ba 00 00 00 00       	mov    $0x0,%edx
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  8032ed:	89 d0                	mov    %edx,%eax
  8032ef:	83 c4 2c             	add    $0x2c,%esp
  8032f2:	5b                   	pop    %ebx
  8032f3:	5e                   	pop    %esi
  8032f4:	5f                   	pop    %edi
  8032f5:	5d                   	pop    %ebp
  8032f6:	c3                   	ret    

008032f7 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  8032f7:	55                   	push   %ebp
  8032f8:	89 e5                	mov    %esp,%ebp
  8032fa:	57                   	push   %edi
  8032fb:	56                   	push   %esi
  8032fc:	53                   	push   %ebx
  8032fd:	83 ec 3c             	sub    $0x3c,%esp
  803300:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803303:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  803306:	ba 0d 00 00 00       	mov    $0xd,%edx
  80330b:	89 d8                	mov    %ebx,%eax
  80330d:	e8 9e f8 ff ff       	call   802bb0 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  803312:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803319:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803320:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803327:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  80332e:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803335:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  80333c:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803343:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  80334a:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803351:	89 f0                	mov    %esi,%eax
  803353:	e8 aa fd ff ff       	call   803102 <dhcp_create_request>
  803358:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  80335a:	84 c0                	test   %al,%al
  80335c:	0f 85 87 00 00 00    	jne    8033e9 <dhcp_release+0xf2>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803362:	b9 01 00 00 00       	mov    $0x1,%ecx
  803367:	ba 35 00 00 00       	mov    $0x35,%edx
  80336c:	89 d8                	mov    %ebx,%eax
  80336e:	e8 6b f9 ff ff       	call   802cde <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803373:	ba 07 00 00 00       	mov    $0x7,%edx
  803378:	89 d8                	mov    %ebx,%eax
  80337a:	e8 ce f9 ff ff       	call   802d4d <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  80337f:	89 d8                	mov    %ebx,%eax
  803381:	e8 17 fa ff ff       	call   802d9d <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803386:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80338a:	66 05 f0 00          	add    $0xf0,%ax
  80338e:	0f b7 c0             	movzwl %ax,%eax
  803391:	89 44 24 04          	mov    %eax,0x4(%esp)
  803395:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803398:	89 04 24             	mov    %eax,(%esp)
  80339b:	e8 0d 20 00 00       	call   8053ad <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  8033a0:	8d 43 2c             	lea    0x2c(%ebx),%eax
  8033a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8033a6:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8033ad:	00 
  8033ae:	89 44 24 04          	mov    %eax,0x4(%esp)
  8033b2:	8b 43 08             	mov    0x8(%ebx),%eax
  8033b5:	89 04 24             	mov    %eax,(%esp)
  8033b8:	e8 54 5f 00 00       	call   809311 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  8033bd:	89 74 24 10          	mov    %esi,0x10(%esp)
  8033c1:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8033c8:	00 
  8033c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8033cc:	89 44 24 08          	mov    %eax,0x8(%esp)
  8033d0:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8033d3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8033d7:	8b 43 08             	mov    0x8(%ebx),%eax
  8033da:	89 04 24             	mov    %eax,(%esp)
  8033dd:	e8 a4 5f 00 00       	call   809386 <udp_sendto_if>
    dhcp_delete_request(netif);
  8033e2:	89 f0                	mov    %esi,%eax
  8033e4:	e8 ae fb ff ff       	call   802f97 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8033e9:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  8033ed:	83 c1 01             	add    $0x1,%ecx
  8033f0:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  8033f3:	ba 10 27 00 00       	mov    $0x2710,%edx
  8033f8:	80 f9 09             	cmp    $0x9,%cl
  8033fb:	77 08                	ja     803405 <dhcp_release+0x10e>
  8033fd:	0f b6 c9             	movzbl %cl,%ecx
  803400:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803405:	0f b7 d2             	movzwl %dx,%edx
  803408:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  80340e:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803413:	89 d0                	mov    %edx,%eax
  803415:	f7 e9                	imul   %ecx
  803417:	c1 fa 05             	sar    $0x5,%edx
  80341a:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  80341e:	89 34 24             	mov    %esi,(%esp)
  803421:	e8 12 18 00 00       	call   804c38 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803426:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  80342d:	00 
  80342e:	89 34 24             	mov    %esi,(%esp)
  803431:	e8 5e 18 00 00       	call   804c94 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803436:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  80343d:	00 
  80343e:	89 34 24             	mov    %esi,(%esp)
  803441:	e8 67 17 00 00       	call   804bad <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803446:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  80344d:	00 
  80344e:	89 34 24             	mov    %esi,(%esp)
  803451:	e8 70 17 00 00       	call   804bc6 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  803456:	89 f8                	mov    %edi,%eax
  803458:	83 c4 3c             	add    $0x3c,%esp
  80345b:	5b                   	pop    %ebx
  80345c:	5e                   	pop    %esi
  80345d:	5f                   	pop    %edi
  80345e:	5d                   	pop    %ebp
  80345f:	c3                   	ret    

00803460 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  803460:	55                   	push   %ebp
  803461:	89 e5                	mov    %esp,%ebp
  803463:	83 ec 48             	sub    $0x48,%esp
  803466:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  803469:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80346c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80346f:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  803472:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803475:	ba 05 00 00 00       	mov    $0x5,%edx
  80347a:	89 d8                	mov    %ebx,%eax
  80347c:	e8 2f f7 ff ff       	call   802bb0 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803481:	89 f8                	mov    %edi,%eax
  803483:	e8 7a fc ff ff       	call   803102 <dhcp_create_request>
  803488:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  80348a:	84 c0                	test   %al,%al
  80348c:	0f 85 a4 00 00 00    	jne    803536 <dhcp_renew+0xd6>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803492:	b9 01 00 00 00       	mov    $0x1,%ecx
  803497:	ba 35 00 00 00       	mov    $0x35,%edx
  80349c:	89 d8                	mov    %ebx,%eax
  80349e:	e8 3b f8 ff ff       	call   802cde <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8034a3:	ba 03 00 00 00       	mov    $0x3,%edx
  8034a8:	89 d8                	mov    %ebx,%eax
  8034aa:	e8 9e f8 ff ff       	call   802d4d <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8034af:	b9 02 00 00 00       	mov    $0x2,%ecx
  8034b4:	ba 39 00 00 00       	mov    $0x39,%edx
  8034b9:	89 d8                	mov    %ebx,%eax
  8034bb:	e8 1e f8 ff ff       	call   802cde <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  8034c0:	ba 40 02 00 00       	mov    $0x240,%edx
  8034c5:	89 d8                	mov    %ebx,%eax
  8034c7:	e8 9b f9 ff ff       	call   802e67 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  8034cc:	89 d8                	mov    %ebx,%eax
  8034ce:	e8 ca f8 ff ff       	call   802d9d <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8034d3:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8034d7:	66 05 f0 00          	add    $0xf0,%ax
  8034db:	0f b7 c0             	movzwl %ax,%eax
  8034de:	89 44 24 04          	mov    %eax,0x4(%esp)
  8034e2:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8034e5:	89 04 24             	mov    %eax,(%esp)
  8034e8:	e8 c0 1e 00 00       	call   8053ad <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  8034ed:	8d 43 2c             	lea    0x2c(%ebx),%eax
  8034f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8034f3:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8034fa:	00 
  8034fb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8034ff:	8b 43 08             	mov    0x8(%ebx),%eax
  803502:	89 04 24             	mov    %eax,(%esp)
  803505:	e8 07 5e 00 00       	call   809311 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80350a:	89 7c 24 10          	mov    %edi,0x10(%esp)
  80350e:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803515:	00 
  803516:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803519:	89 44 24 08          	mov    %eax,0x8(%esp)
  80351d:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803520:	89 44 24 04          	mov    %eax,0x4(%esp)
  803524:	8b 43 08             	mov    0x8(%ebx),%eax
  803527:	89 04 24             	mov    %eax,(%esp)
  80352a:	e8 57 5e 00 00       	call   809386 <udp_sendto_if>
    dhcp_delete_request(netif);
  80352f:	89 f8                	mov    %edi,%eax
  803531:	e8 61 fa ff ff       	call   802f97 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803536:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  80353a:	83 c1 01             	add    $0x1,%ecx
  80353d:	88 4b 01             	mov    %cl,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803540:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  803545:	80 f9 09             	cmp    $0x9,%cl
  803548:	77 08                	ja     803552 <dhcp_renew+0xf2>
  80354a:	0f b6 c9             	movzbl %cl,%ecx
  80354d:	66 69 d1 d0 07       	imul   $0x7d0,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803552:	0f b7 d2             	movzwl %dx,%edx
  803555:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  80355b:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803560:	89 d0                	mov    %edx,%eax
  803562:	f7 e9                	imul   %ecx
  803564:	c1 fa 05             	sar    $0x5,%edx
  803567:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  80356b:	89 f0                	mov    %esi,%eax
  80356d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  803570:	8b 75 f8             	mov    -0x8(%ebp),%esi
  803573:	8b 7d fc             	mov    -0x4(%ebp),%edi
  803576:	89 ec                	mov    %ebp,%esp
  803578:	5d                   	pop    %ebp
  803579:	c3                   	ret    

0080357a <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  80357a:	55                   	push   %ebp
  80357b:	89 e5                	mov    %esp,%ebp
  80357d:	57                   	push   %edi
  80357e:	56                   	push   %esi
  80357f:	53                   	push   %ebx
  803580:	83 ec 2c             	sub    $0x2c,%esp
  803583:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803585:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  803588:	a1 64 20 81 00       	mov    0x812064,%eax
  80358d:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803590:	89 f8                	mov    %edi,%eax
  803592:	e8 6b fb ff ff       	call   803102 <dhcp_create_request>
  803597:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803599:	84 c0                	test   %al,%al
  80359b:	0f 85 f0 00 00 00    	jne    803691 <dhcp_discover+0x117>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8035a1:	b9 01 00 00 00       	mov    $0x1,%ecx
  8035a6:	ba 35 00 00 00       	mov    $0x35,%edx
  8035ab:	89 d8                	mov    %ebx,%eax
  8035ad:	e8 2c f7 ff ff       	call   802cde <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  8035b2:	ba 01 00 00 00       	mov    $0x1,%edx
  8035b7:	89 d8                	mov    %ebx,%eax
  8035b9:	e8 8f f7 ff ff       	call   802d4d <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8035be:	b9 02 00 00 00       	mov    $0x2,%ecx
  8035c3:	ba 39 00 00 00       	mov    $0x39,%edx
  8035c8:	89 d8                	mov    %ebx,%eax
  8035ca:	e8 0f f7 ff ff       	call   802cde <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8035cf:	ba 40 02 00 00       	mov    $0x240,%edx
  8035d4:	89 d8                	mov    %ebx,%eax
  8035d6:	e8 8c f8 ff ff       	call   802e67 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8035db:	b9 04 00 00 00       	mov    $0x4,%ecx
  8035e0:	ba 37 00 00 00       	mov    $0x37,%edx
  8035e5:	89 d8                	mov    %ebx,%eax
  8035e7:	e8 f2 f6 ff ff       	call   802cde <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  8035ec:	ba 01 00 00 00       	mov    $0x1,%edx
  8035f1:	89 d8                	mov    %ebx,%eax
  8035f3:	e8 55 f7 ff ff       	call   802d4d <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  8035f8:	ba 03 00 00 00       	mov    $0x3,%edx
  8035fd:	89 d8                	mov    %ebx,%eax
  8035ff:	e8 49 f7 ff ff       	call   802d4d <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  803604:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803609:	89 d8                	mov    %ebx,%eax
  80360b:	e8 3d f7 ff ff       	call   802d4d <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803610:	ba 06 00 00 00       	mov    $0x6,%edx
  803615:	89 d8                	mov    %ebx,%eax
  803617:	e8 31 f7 ff ff       	call   802d4d <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  80361c:	89 d8                	mov    %ebx,%eax
  80361e:	e8 7a f7 ff ff       	call   802d9d <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803623:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803627:	66 05 f0 00          	add    $0xf0,%ax
  80362b:	0f b7 c0             	movzwl %ax,%eax
  80362e:	89 44 24 04          	mov    %eax,0x4(%esp)
  803632:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803635:	89 04 24             	mov    %eax,(%esp)
  803638:	e8 70 1d 00 00       	call   8053ad <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80363d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803644:	00 
  803645:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  80364c:	00 
  80364d:	8b 43 08             	mov    0x8(%ebx),%eax
  803650:	89 04 24             	mov    %eax,(%esp)
  803653:	e8 b9 5c 00 00       	call   809311 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803658:	89 7c 24 10          	mov    %edi,0x10(%esp)
  80365c:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803663:	00 
  803664:	c7 44 24 08 68 20 81 	movl   $0x812068,0x8(%esp)
  80366b:	00 
  80366c:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80366f:	89 44 24 04          	mov    %eax,0x4(%esp)
  803673:	8b 43 08             	mov    0x8(%ebx),%eax
  803676:	89 04 24             	mov    %eax,(%esp)
  803679:	e8 08 5d 00 00       	call   809386 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  80367e:	89 f8                	mov    %edi,%eax
  803680:	e8 12 f9 ff ff       	call   802f97 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  803685:	ba 06 00 00 00       	mov    $0x6,%edx
  80368a:	89 d8                	mov    %ebx,%eax
  80368c:	e8 1f f5 ff ff       	call   802bb0 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803691:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  803695:	83 c1 01             	add    $0x1,%ecx
  803698:	88 4b 01             	mov    %cl,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  80369b:	ba 10 27 00 00       	mov    $0x2710,%edx
  8036a0:	80 f9 03             	cmp    $0x3,%cl
  8036a3:	77 0b                	ja     8036b0 <dhcp_discover+0x136>
  8036a5:	0f b6 d1             	movzbl %cl,%edx
  8036a8:	83 c2 01             	add    $0x1,%edx
  8036ab:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8036b0:	0f b7 d2             	movzwl %dx,%edx
  8036b3:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8036b9:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8036be:	89 d0                	mov    %edx,%eax
  8036c0:	f7 e9                	imul   %ecx
  8036c2:	c1 fa 05             	sar    $0x5,%edx
  8036c5:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8036c9:	89 f0                	mov    %esi,%eax
  8036cb:	83 c4 2c             	add    $0x2c,%esp
  8036ce:	5b                   	pop    %ebx
  8036cf:	5e                   	pop    %esi
  8036d0:	5f                   	pop    %edi
  8036d1:	5d                   	pop    %ebp
  8036d2:	c3                   	ret    

008036d3 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  8036d3:	55                   	push   %ebp
  8036d4:	89 e5                	mov    %esp,%ebp
  8036d6:	83 ec 38             	sub    $0x38,%esp
  8036d9:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8036dc:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8036df:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8036e2:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8036e4:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  8036e7:	ba 04 00 00 00       	mov    $0x4,%edx
  8036ec:	89 d8                	mov    %ebx,%eax
  8036ee:	e8 bd f4 ff ff       	call   802bb0 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8036f3:	89 f8                	mov    %edi,%eax
  8036f5:	e8 08 fa ff ff       	call   803102 <dhcp_create_request>
  8036fa:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8036fc:	84 c0                	test   %al,%al
  8036fe:	0f 85 a3 00 00 00    	jne    8037a7 <dhcp_rebind+0xd4>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803704:	b9 01 00 00 00       	mov    $0x1,%ecx
  803709:	ba 35 00 00 00       	mov    $0x35,%edx
  80370e:	89 d8                	mov    %ebx,%eax
  803710:	e8 c9 f5 ff ff       	call   802cde <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803715:	ba 03 00 00 00       	mov    $0x3,%edx
  80371a:	89 d8                	mov    %ebx,%eax
  80371c:	e8 2c f6 ff ff       	call   802d4d <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803721:	b9 02 00 00 00       	mov    $0x2,%ecx
  803726:	ba 39 00 00 00       	mov    $0x39,%edx
  80372b:	89 d8                	mov    %ebx,%eax
  80372d:	e8 ac f5 ff ff       	call   802cde <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803732:	ba 40 02 00 00       	mov    $0x240,%edx
  803737:	89 d8                	mov    %ebx,%eax
  803739:	e8 29 f7 ff ff       	call   802e67 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  80373e:	89 d8                	mov    %ebx,%eax
  803740:	e8 58 f6 ff ff       	call   802d9d <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803745:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803749:	66 05 f0 00          	add    $0xf0,%ax
  80374d:	0f b7 c0             	movzwl %ax,%eax
  803750:	89 44 24 04          	mov    %eax,0x4(%esp)
  803754:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803757:	89 04 24             	mov    %eax,(%esp)
  80375a:	e8 4e 1c 00 00       	call   8053ad <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80375f:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803766:	00 
  803767:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  80376e:	00 
  80376f:	8b 43 08             	mov    0x8(%ebx),%eax
  803772:	89 04 24             	mov    %eax,(%esp)
  803775:	e8 97 5b 00 00       	call   809311 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80377a:	89 7c 24 10          	mov    %edi,0x10(%esp)
  80377e:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803785:	00 
  803786:	c7 44 24 08 68 20 81 	movl   $0x812068,0x8(%esp)
  80378d:	00 
  80378e:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803791:	89 44 24 04          	mov    %eax,0x4(%esp)
  803795:	8b 43 08             	mov    0x8(%ebx),%eax
  803798:	89 04 24             	mov    %eax,(%esp)
  80379b:	e8 e6 5b 00 00       	call   809386 <udp_sendto_if>
    dhcp_delete_request(netif);
  8037a0:	89 f8                	mov    %edi,%eax
  8037a2:	e8 f0 f7 ff ff       	call   802f97 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8037a7:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  8037ab:	83 c1 01             	add    $0x1,%ecx
  8037ae:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  8037b1:	ba 10 27 00 00       	mov    $0x2710,%edx
  8037b6:	80 f9 09             	cmp    $0x9,%cl
  8037b9:	77 08                	ja     8037c3 <dhcp_rebind+0xf0>
  8037bb:	0f b6 c9             	movzbl %cl,%ecx
  8037be:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8037c3:	0f b7 d2             	movzwl %dx,%edx
  8037c6:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8037cc:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8037d1:	89 d0                	mov    %edx,%eax
  8037d3:	f7 e9                	imul   %ecx
  8037d5:	c1 fa 05             	sar    $0x5,%edx
  8037d8:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8037dc:	89 f0                	mov    %esi,%eax
  8037de:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8037e1:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8037e4:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8037e7:	89 ec                	mov    %ebp,%esp
  8037e9:	5d                   	pop    %ebp
  8037ea:	c3                   	ret    

008037eb <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  8037eb:	55                   	push   %ebp
  8037ec:	89 e5                	mov    %esp,%ebp
  8037ee:	53                   	push   %ebx
  8037ef:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  8037f2:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  8037f8:	eb 63                	jmp    80385d <dhcp_coarse_tmr+0x72>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  8037fa:	8b 43 20             	mov    0x20(%ebx),%eax
  8037fd:	85 c0                	test   %eax,%eax
  8037ff:	74 5a                	je     80385b <dhcp_coarse_tmr+0x70>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  803801:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803805:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803808:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  80380c:	66 83 fa 01          	cmp    $0x1,%dx
  803810:	75 1b                	jne    80382d <dhcp_coarse_tmr+0x42>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803812:	8b 43 20             	mov    0x20(%ebx),%eax
  803815:	0f b6 00             	movzbl (%eax),%eax
  803818:	3c 01                	cmp    $0x1,%al
  80381a:	74 08                	je     803824 <dhcp_coarse_tmr+0x39>
  80381c:	3c 0a                	cmp    $0xa,%al
  80381e:	74 04                	je     803824 <dhcp_coarse_tmr+0x39>
  803820:	3c 05                	cmp    $0x5,%al
  803822:	75 37                	jne    80385b <dhcp_coarse_tmr+0x70>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  803824:	89 d8                	mov    %ebx,%eax
  803826:	e8 a8 fe ff ff       	call   8036d3 <dhcp_rebind>
  80382b:	eb 2e                	jmp    80385b <dhcp_coarse_tmr+0x70>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  80382d:	8b 53 20             	mov    0x20(%ebx),%edx
  803830:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803834:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803837:	66 89 4a 28          	mov    %cx,0x28(%edx)
  80383b:	66 83 f8 01          	cmp    $0x1,%ax
  80383f:	75 1a                	jne    80385b <dhcp_coarse_tmr+0x70>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803841:	8b 43 20             	mov    0x20(%ebx),%eax
  803844:	0f b6 00             	movzbl (%eax),%eax
  803847:	3c 01                	cmp    $0x1,%al
  803849:	74 08                	je     803853 <dhcp_coarse_tmr+0x68>
  80384b:	3c 0a                	cmp    $0xa,%al
  80384d:	74 04                	je     803853 <dhcp_coarse_tmr+0x68>
  80384f:	3c 05                	cmp    $0x5,%al
  803851:	75 08                	jne    80385b <dhcp_coarse_tmr+0x70>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  803853:	89 1c 24             	mov    %ebx,(%esp)
  803856:	e8 05 fc ff ff       	call   803460 <dhcp_renew>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  80385b:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  80385d:	85 db                	test   %ebx,%ebx
  80385f:	75 99                	jne    8037fa <dhcp_coarse_tmr+0xf>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  803861:	83 c4 14             	add    $0x14,%esp
  803864:	5b                   	pop    %ebx
  803865:	5d                   	pop    %ebp
  803866:	c3                   	ret    

00803867 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  803867:	55                   	push   %ebp
  803868:	89 e5                	mov    %esp,%ebp
  80386a:	83 ec 28             	sub    $0x28,%esp
  80386d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  803870:	89 75 fc             	mov    %esi,-0x4(%ebp)
  803873:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803876:	85 f6                	test   %esi,%esi
  803878:	75 1c                	jne    803896 <dhcp_arp_reply+0x2f>
  80387a:	c7 44 24 08 bb 17 81 	movl   $0x8117bb,0x8(%esp)
  803881:	00 
  803882:	c7 44 24 04 b5 02 00 	movl   $0x2b5,0x4(%esp)
  803889:	00 
  80388a:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  803891:	e8 56 b9 00 00       	call   80f1ec <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803896:	8b 5e 20             	mov    0x20(%esi),%ebx
  803899:	85 db                	test   %ebx,%ebx
  80389b:	0f 84 04 01 00 00    	je     8039a5 <dhcp_arp_reply+0x13e>
  8038a1:	80 3b 08             	cmpb   $0x8,(%ebx)
  8038a4:	0f 85 fb 00 00 00    	jne    8039a5 <dhcp_arp_reply+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  8038aa:	8b 45 0c             	mov    0xc(%ebp),%eax
  8038ad:	8b 00                	mov    (%eax),%eax
  8038af:	3b 43 30             	cmp    0x30(%ebx),%eax
  8038b2:	0f 85 ed 00 00 00    	jne    8039a5 <dhcp_arp_reply+0x13e>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8038b8:	ba 0c 00 00 00       	mov    $0xc,%edx
  8038bd:	89 d8                	mov    %ebx,%eax
  8038bf:	e8 ec f2 ff ff       	call   802bb0 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8038c4:	89 f0                	mov    %esi,%eax
  8038c6:	e8 37 f8 ff ff       	call   803102 <dhcp_create_request>
  if (result == ERR_OK) {
  8038cb:	84 c0                	test   %al,%al
  8038cd:	0f 85 c8 00 00 00    	jne    80399b <dhcp_arp_reply+0x134>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8038d3:	b9 01 00 00 00       	mov    $0x1,%ecx
  8038d8:	ba 35 00 00 00       	mov    $0x35,%edx
  8038dd:	89 d8                	mov    %ebx,%eax
  8038df:	e8 fa f3 ff ff       	call   802cde <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  8038e4:	ba 04 00 00 00       	mov    $0x4,%edx
  8038e9:	89 d8                	mov    %ebx,%eax
  8038eb:	e8 5d f4 ff ff       	call   802d4d <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8038f0:	b9 02 00 00 00       	mov    $0x2,%ecx
  8038f5:	ba 39 00 00 00       	mov    $0x39,%edx
  8038fa:	89 d8                	mov    %ebx,%eax
  8038fc:	e8 dd f3 ff ff       	call   802cde <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803901:	ba 40 02 00 00       	mov    $0x240,%edx
  803906:	89 d8                	mov    %ebx,%eax
  803908:	e8 5a f5 ff ff       	call   802e67 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  80390d:	b9 04 00 00 00       	mov    $0x4,%ecx
  803912:	ba 32 00 00 00       	mov    $0x32,%edx
  803917:	89 d8                	mov    %ebx,%eax
  803919:	e8 c0 f3 ff ff       	call   802cde <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80391e:	8b 43 30             	mov    0x30(%ebx),%eax
  803921:	89 04 24             	mov    %eax,(%esp)
  803924:	e8 63 47 00 00       	call   80808c <ntohl>
  803929:	89 c2                	mov    %eax,%edx
  80392b:	89 d8                	mov    %ebx,%eax
  80392d:	e8 b4 f5 ff ff       	call   802ee6 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  803932:	89 d8                	mov    %ebx,%eax
  803934:	e8 64 f4 ff ff       	call   802d9d <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803939:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80393d:	66 05 f0 00          	add    $0xf0,%ax
  803941:	0f b7 c0             	movzwl %ax,%eax
  803944:	89 44 24 04          	mov    %eax,0x4(%esp)
  803948:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80394b:	89 04 24             	mov    %eax,(%esp)
  80394e:	e8 5a 1a 00 00       	call   8053ad <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803953:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80395a:	00 
  80395b:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  803962:	00 
  803963:	8b 43 08             	mov    0x8(%ebx),%eax
  803966:	89 04 24             	mov    %eax,(%esp)
  803969:	e8 a3 59 00 00       	call   809311 <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80396e:	89 74 24 10          	mov    %esi,0x10(%esp)
  803972:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803979:	00 
  80397a:	c7 44 24 08 68 20 81 	movl   $0x812068,0x8(%esp)
  803981:	00 
  803982:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803985:	89 44 24 04          	mov    %eax,0x4(%esp)
  803989:	8b 43 08             	mov    0x8(%ebx),%eax
  80398c:	89 04 24             	mov    %eax,(%esp)
  80398f:	e8 f2 59 00 00       	call   809386 <udp_sendto_if>
    dhcp_delete_request(netif);
  803994:	89 f0                	mov    %esi,%eax
  803996:	e8 fc f5 ff ff       	call   802f97 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80399b:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80399f:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  8039a5:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8039a8:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8039ab:	89 ec                	mov    %ebp,%esp
  8039ad:	5d                   	pop    %ebp
  8039ae:	c3                   	ret    

008039af <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  8039af:	55                   	push   %ebp
  8039b0:	89 e5                	mov    %esp,%ebp
  8039b2:	57                   	push   %edi
  8039b3:	56                   	push   %esi
  8039b4:	53                   	push   %ebx
  8039b5:	83 ec 2c             	sub    $0x2c,%esp
  8039b8:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8039ba:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8039bd:	e8 40 f7 ff ff       	call   803102 <dhcp_create_request>
  8039c2:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8039c4:	84 c0                	test   %al,%al
  8039c6:	0f 85 3a 01 00 00    	jne    803b06 <dhcp_select+0x157>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8039cc:	b9 01 00 00 00       	mov    $0x1,%ecx
  8039d1:	ba 35 00 00 00       	mov    $0x35,%edx
  8039d6:	89 d8                	mov    %ebx,%eax
  8039d8:	e8 01 f3 ff ff       	call   802cde <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8039dd:	ba 03 00 00 00       	mov    $0x3,%edx
  8039e2:	89 d8                	mov    %ebx,%eax
  8039e4:	e8 64 f3 ff ff       	call   802d4d <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8039e9:	b9 02 00 00 00       	mov    $0x2,%ecx
  8039ee:	ba 39 00 00 00       	mov    $0x39,%edx
  8039f3:	89 d8                	mov    %ebx,%eax
  8039f5:	e8 e4 f2 ff ff       	call   802cde <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8039fa:	ba 40 02 00 00       	mov    $0x240,%edx
  8039ff:	89 d8                	mov    %ebx,%eax
  803a01:	e8 61 f4 ff ff       	call   802e67 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803a06:	b9 04 00 00 00       	mov    $0x4,%ecx
  803a0b:	ba 32 00 00 00       	mov    $0x32,%edx
  803a10:	89 d8                	mov    %ebx,%eax
  803a12:	e8 c7 f2 ff ff       	call   802cde <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803a17:	8b 43 30             	mov    0x30(%ebx),%eax
  803a1a:	89 04 24             	mov    %eax,(%esp)
  803a1d:	e8 6a 46 00 00       	call   80808c <ntohl>
  803a22:	89 c2                	mov    %eax,%edx
  803a24:	89 d8                	mov    %ebx,%eax
  803a26:	e8 bb f4 ff ff       	call   802ee6 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  803a2b:	b9 04 00 00 00       	mov    $0x4,%ecx
  803a30:	ba 36 00 00 00       	mov    $0x36,%edx
  803a35:	89 d8                	mov    %ebx,%eax
  803a37:	e8 a2 f2 ff ff       	call   802cde <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  803a3c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  803a3f:	89 04 24             	mov    %eax,(%esp)
  803a42:	e8 45 46 00 00       	call   80808c <ntohl>
  803a47:	89 c2                	mov    %eax,%edx
  803a49:	89 d8                	mov    %ebx,%eax
  803a4b:	e8 96 f4 ff ff       	call   802ee6 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  803a50:	b9 04 00 00 00       	mov    $0x4,%ecx
  803a55:	ba 37 00 00 00       	mov    $0x37,%edx
  803a5a:	89 d8                	mov    %ebx,%eax
  803a5c:	e8 7d f2 ff ff       	call   802cde <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  803a61:	ba 01 00 00 00       	mov    $0x1,%edx
  803a66:	89 d8                	mov    %ebx,%eax
  803a68:	e8 e0 f2 ff ff       	call   802d4d <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  803a6d:	ba 03 00 00 00       	mov    $0x3,%edx
  803a72:	89 d8                	mov    %ebx,%eax
  803a74:	e8 d4 f2 ff ff       	call   802d4d <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  803a79:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803a7e:	89 d8                	mov    %ebx,%eax
  803a80:	e8 c8 f2 ff ff       	call   802d4d <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803a85:	ba 06 00 00 00       	mov    $0x6,%edx
  803a8a:	89 d8                	mov    %ebx,%eax
  803a8c:	e8 bc f2 ff ff       	call   802d4d <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  803a91:	89 d8                	mov    %ebx,%eax
  803a93:	e8 05 f3 ff ff       	call   802d9d <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803a98:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803a9c:	66 05 f0 00          	add    $0xf0,%ax
  803aa0:	0f b7 c0             	movzwl %ax,%eax
  803aa3:	89 44 24 04          	mov    %eax,0x4(%esp)
  803aa7:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803aaa:	89 04 24             	mov    %eax,(%esp)
  803aad:	e8 fb 18 00 00       	call   8053ad <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803ab2:	89 7c 24 10          	mov    %edi,0x10(%esp)
  803ab6:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803abd:	00 
  803abe:	c7 44 24 08 68 20 81 	movl   $0x812068,0x8(%esp)
  803ac5:	00 
  803ac6:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803ac9:	89 44 24 04          	mov    %eax,0x4(%esp)
  803acd:	8b 43 08             	mov    0x8(%ebx),%eax
  803ad0:	89 04 24             	mov    %eax,(%esp)
  803ad3:	e8 ae 58 00 00       	call   809386 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803ad8:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803adf:	00 
  803ae0:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  803ae7:	00 
  803ae8:	8b 43 08             	mov    0x8(%ebx),%eax
  803aeb:	89 04 24             	mov    %eax,(%esp)
  803aee:	e8 1e 58 00 00       	call   809311 <udp_connect>
    dhcp_delete_request(netif);
  803af3:	89 f8                	mov    %edi,%eax
  803af5:	e8 9d f4 ff ff       	call   802f97 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  803afa:	ba 01 00 00 00       	mov    $0x1,%edx
  803aff:	89 d8                	mov    %ebx,%eax
  803b01:	e8 aa f0 ff ff       	call   802bb0 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803b06:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  803b0a:	83 c1 01             	add    $0x1,%ecx
  803b0d:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  803b10:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  803b15:	80 f9 03             	cmp    $0x3,%cl
  803b18:	77 08                	ja     803b22 <dhcp_select+0x173>
  803b1a:	0f b6 c9             	movzbl %cl,%ecx
  803b1d:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803b22:	0f b7 d2             	movzwl %dx,%edx
  803b25:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803b2b:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803b30:	89 d0                	mov    %edx,%eax
  803b32:	f7 e9                	imul   %ecx
  803b34:	c1 fa 05             	sar    $0x5,%edx
  803b37:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803b3b:	89 f0                	mov    %esi,%eax
  803b3d:	83 c4 2c             	add    $0x2c,%esp
  803b40:	5b                   	pop    %ebx
  803b41:	5e                   	pop    %esi
  803b42:	5f                   	pop    %edi
  803b43:	5d                   	pop    %ebp
  803b44:	c3                   	ret    

00803b45 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  803b45:	55                   	push   %ebp
  803b46:	89 e5                	mov    %esp,%ebp
  803b48:	83 ec 38             	sub    $0x38,%esp
  803b4b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  803b4e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803b51:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803b54:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803b57:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  803b5a:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  803b61:	e8 86 09 00 00       	call   8044ec <mem_malloc>
  803b66:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  803b68:	85 c0                	test   %eax,%eax
  803b6a:	0f 84 40 01 00 00    	je     803cb0 <dhcp_inform+0x16b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  803b70:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  803b73:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  803b7a:	00 
  803b7b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803b82:	00 
  803b83:	89 04 24             	mov    %eax,(%esp)
  803b86:	e8 c5 be 00 00       	call   80fa50 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  803b8b:	e8 3f 56 00 00       	call   8091cf <udp_new>
  803b90:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  803b93:	85 c0                	test   %eax,%eax
  803b95:	75 0d                	jne    803ba4 <dhcp_inform+0x5f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  803b97:	89 1c 24             	mov    %ebx,(%esp)
  803b9a:	e8 c8 0c 00 00       	call   804867 <mem_free>
    return;
  803b9f:	e9 0c 01 00 00       	jmp    803cb0 <dhcp_inform+0x16b>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803ba4:	89 f0                	mov    %esi,%eax
  803ba6:	e8 57 f5 ff ff       	call   803102 <dhcp_create_request>
  if (result == ERR_OK) {
  803bab:	84 c0                	test   %al,%al
  803bad:	8d 76 00             	lea    0x0(%esi),%esi
  803bb0:	0f 85 d9 00 00 00    	jne    803c8f <dhcp_inform+0x14a>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803bb6:	b9 01 00 00 00       	mov    $0x1,%ecx
  803bbb:	ba 35 00 00 00       	mov    $0x35,%edx
  803bc0:	89 d8                	mov    %ebx,%eax
  803bc2:	e8 17 f1 ff ff       	call   802cde <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803bc7:	ba 08 00 00 00       	mov    $0x8,%edx
  803bcc:	89 d8                	mov    %ebx,%eax
  803bce:	e8 7a f1 ff ff       	call   802d4d <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803bd3:	b9 02 00 00 00       	mov    $0x2,%ecx
  803bd8:	ba 39 00 00 00       	mov    $0x39,%edx
  803bdd:	89 d8                	mov    %ebx,%eax
  803bdf:	e8 fa f0 ff ff       	call   802cde <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  803be4:	ba 40 02 00 00       	mov    $0x240,%edx
  803be9:	89 d8                	mov    %ebx,%eax
  803beb:	e8 77 f2 ff ff       	call   802e67 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  803bf0:	89 d8                	mov    %ebx,%eax
  803bf2:	e8 a6 f1 ff ff       	call   802d9d <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803bf7:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803bfb:	66 05 f0 00          	add    $0xf0,%ax
  803bff:	0f b7 c0             	movzwl %ax,%eax
  803c02:	89 44 24 04          	mov    %eax,0x4(%esp)
  803c06:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803c09:	89 04 24             	mov    %eax,(%esp)
  803c0c:	e8 9c 17 00 00       	call   8053ad <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803c11:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  803c18:	00 
  803c19:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  803c20:	00 
  803c21:	8b 43 08             	mov    0x8(%ebx),%eax
  803c24:	89 04 24             	mov    %eax,(%esp)
  803c27:	e8 26 56 00 00       	call   809252 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803c2c:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803c33:	00 
  803c34:	c7 44 24 04 68 20 81 	movl   $0x812068,0x4(%esp)
  803c3b:	00 
  803c3c:	8b 43 08             	mov    0x8(%ebx),%eax
  803c3f:	89 04 24             	mov    %eax,(%esp)
  803c42:	e8 ca 56 00 00       	call   809311 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803c47:	89 74 24 10          	mov    %esi,0x10(%esp)
  803c4b:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803c52:	00 
  803c53:	c7 44 24 08 68 20 81 	movl   $0x812068,0x8(%esp)
  803c5a:	00 
  803c5b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803c5e:	89 44 24 04          	mov    %eax,0x4(%esp)
  803c62:	8b 43 08             	mov    0x8(%ebx),%eax
  803c65:	89 04 24             	mov    %eax,(%esp)
  803c68:	e8 19 57 00 00       	call   809386 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803c6d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803c74:	00 
  803c75:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  803c7c:	00 
  803c7d:	8b 43 08             	mov    0x8(%ebx),%eax
  803c80:	89 04 24             	mov    %eax,(%esp)
  803c83:	e8 89 56 00 00       	call   809311 <udp_connect>
    dhcp_delete_request(netif);
  803c88:	89 f0                	mov    %esi,%eax
  803c8a:	e8 08 f3 ff ff       	call   802f97 <dhcp_delete_request>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  803c8f:	8b 43 08             	mov    0x8(%ebx),%eax
  803c92:	85 c0                	test   %eax,%eax
  803c94:	74 08                	je     803c9e <dhcp_inform+0x159>
      udp_remove(dhcp->pcb);
  803c96:	89 04 24             	mov    %eax,(%esp)
  803c99:	e8 6e 55 00 00       	call   80920c <udp_remove>
    }
    dhcp->pcb = NULL;
  803c9e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  803ca5:	89 1c 24             	mov    %ebx,(%esp)
  803ca8:	e8 ba 0b 00 00       	call   804867 <mem_free>
    netif->dhcp = old_dhcp;
  803cad:	89 7e 20             	mov    %edi,0x20(%esi)
  }
}
  803cb0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  803cb3:	8b 75 f8             	mov    -0x8(%ebp),%esi
  803cb6:	8b 7d fc             	mov    -0x4(%ebp),%edi
  803cb9:	89 ec                	mov    %ebp,%esp
  803cbb:	5d                   	pop    %ebp
  803cbc:	c3                   	ret    

00803cbd <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  803cbd:	55                   	push   %ebp
  803cbe:	89 e5                	mov    %esp,%ebp
  803cc0:	56                   	push   %esi
  803cc1:	53                   	push   %ebx
  803cc2:	83 ec 10             	sub    $0x10,%esp
  803cc5:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803cc8:	85 f6                	test   %esi,%esi
  803cca:	75 1c                	jne    803ce8 <dhcp_start+0x2b>
  803ccc:	c7 44 24 08 bb 17 81 	movl   $0x8117bb,0x8(%esp)
  803cd3:	00 
  803cd4:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  803cdb:	00 
  803cdc:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  803ce3:	e8 04 b5 00 00       	call   80f1ec <_panic>
  dhcp = netif->dhcp;
  803ce8:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  803ceb:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  803cef:	85 db                	test   %ebx,%ebx
  803cf1:	75 1e                	jne    803d11 <dhcp_start+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  803cf3:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  803cfa:	e8 ed 07 00 00       	call   8044ec <mem_malloc>
  803cff:	89 c3                	mov    %eax,%ebx
    if (dhcp == NULL) {
  803d01:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803d06:	85 db                	test   %ebx,%ebx
  803d08:	0f 84 a5 00 00 00    	je     803db3 <dhcp_start+0xf6>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  803d0e:	89 5e 20             	mov    %ebx,0x20(%esi)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  803d11:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  803d18:	00 
  803d19:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803d20:	00 
  803d21:	89 1c 24             	mov    %ebx,(%esp)
  803d24:	e8 27 bd 00 00       	call   80fa50 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  803d29:	e8 a1 54 00 00       	call   8091cf <udp_new>
  803d2e:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  803d31:	85 c0                	test   %eax,%eax
  803d33:	75 16                	jne    803d4b <dhcp_start+0x8e>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  803d35:	89 1c 24             	mov    %ebx,(%esp)
  803d38:	e8 2a 0b 00 00       	call   804867 <mem_free>
    netif->dhcp = dhcp = NULL;
  803d3d:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803d44:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  803d49:	eb 68                	jmp    803db3 <dhcp_start+0xf6>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803d4b:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  803d52:	00 
  803d53:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  803d5a:	00 
  803d5b:	89 04 24             	mov    %eax,(%esp)
  803d5e:	e8 ef 54 00 00       	call   809252 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803d63:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803d6a:	00 
  803d6b:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  803d72:	00 
  803d73:	8b 43 08             	mov    0x8(%ebx),%eax
  803d76:	89 04 24             	mov    %eax,(%esp)
  803d79:	e8 93 55 00 00       	call   809311 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803d7e:	89 74 24 08          	mov    %esi,0x8(%esp)
  803d82:	c7 44 24 04 8f 3f 80 	movl   $0x803f8f,0x4(%esp)
  803d89:	00 
  803d8a:	8b 43 08             	mov    0x8(%ebx),%eax
  803d8d:	89 04 24             	mov    %eax,(%esp)
  803d90:	e8 26 54 00 00       	call   8091bb <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  803d95:	89 f0                	mov    %esi,%eax
  803d97:	e8 de f7 ff ff       	call   80357a <dhcp_discover>
  if (result != ERR_OK) {
  803d9c:	84 c0                	test   %al,%al
  803d9e:	74 0f                	je     803daf <dhcp_start+0xf2>
    /* free resources allocated above */
    dhcp_stop(netif);
  803da0:	89 34 24             	mov    %esi,(%esp)
  803da3:	e8 db f2 ff ff       	call   803083 <dhcp_stop>
  803da8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  803dad:	eb 04                	jmp    803db3 <dhcp_start+0xf6>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  803daf:	80 4e 2e 08          	orb    $0x8,0x2e(%esi)
  return result;
}
  803db3:	83 c4 10             	add    $0x10,%esp
  803db6:	5b                   	pop    %ebx
  803db7:	5e                   	pop    %esi
  803db8:	5d                   	pop    %ebp
  803db9:	c3                   	ret    

00803dba <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  803dba:	55                   	push   %ebp
  803dbb:	89 e5                	mov    %esp,%ebp
  803dbd:	53                   	push   %ebx
  803dbe:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  803dc1:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  803dc4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  803dcb:	00 
  803dcc:	8d 53 30             	lea    0x30(%ebx),%edx
  803dcf:	89 54 24 04          	mov    %edx,0x4(%esp)
  803dd3:	89 04 24             	mov    %eax,(%esp)
  803dd6:	e8 bf 5f 00 00       	call   809d9a <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  803ddb:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803ddf:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  803de5:	ba 08 00 00 00       	mov    $0x8,%edx
  803dea:	89 d8                	mov    %ebx,%eax
  803dec:	e8 bf ed ff ff       	call   802bb0 <dhcp_set_state>
}
  803df1:	83 c4 14             	add    $0x14,%esp
  803df4:	5b                   	pop    %ebx
  803df5:	5d                   	pop    %ebp
  803df6:	c3                   	ret    

00803df7 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  803df7:	55                   	push   %ebp
  803df8:	89 e5                	mov    %esp,%ebp
  803dfa:	57                   	push   %edi
  803dfb:	56                   	push   %esi
  803dfc:	53                   	push   %ebx
  803dfd:	83 ec 2c             	sub    $0x2c,%esp
  803e00:	89 c6                	mov    %eax,%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  803e02:	85 c0                	test   %eax,%eax
  803e04:	75 1c                	jne    803e22 <dhcp_bind+0x2b>
  803e06:	c7 44 24 08 b0 17 81 	movl   $0x8117b0,0x8(%esp)
  803e0d:	00 
  803e0e:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
  803e15:	00 
  803e16:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  803e1d:	e8 ca b3 00 00       	call   80f1ec <_panic>
  dhcp = netif->dhcp;
  803e22:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  803e25:	85 db                	test   %ebx,%ebx
  803e27:	75 1c                	jne    803e45 <dhcp_bind+0x4e>
  803e29:	c7 44 24 08 c9 17 81 	movl   $0x8117c9,0x8(%esp)
  803e30:	00 
  803e31:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
  803e38:	00 
  803e39:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  803e40:	e8 a7 b3 00 00       	call   80f1ec <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  803e45:	8b 53 50             	mov    0x50(%ebx),%edx
  803e48:	83 fa ff             	cmp    $0xffffffff,%edx
  803e4b:	74 2c                	je     803e79 <dhcp_bind+0x82>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803e4d:	83 c2 1e             	add    $0x1e,%edx
  803e50:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803e55:	89 d0                	mov    %edx,%eax
  803e57:	f7 e1                	mul    %ecx
  803e59:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  803e5c:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  803e62:	b8 ff ff 00 00       	mov    $0xffff,%eax
  803e67:	0f 47 d0             	cmova  %eax,%edx
    if (dhcp->t1_timeout == 0) {
      dhcp->t1_timeout = 1;
  803e6a:	66 85 d2             	test   %dx,%dx
  803e6d:	b8 01 00 00 00       	mov    $0x1,%eax
  803e72:	0f 44 d0             	cmove  %eax,%edx
  803e75:	66 89 53 28          	mov    %dx,0x28(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  803e79:	8b 53 54             	mov    0x54(%ebx),%edx
  803e7c:	83 fa ff             	cmp    $0xffffffff,%edx
  803e7f:	74 2c                	je     803ead <dhcp_bind+0xb6>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803e81:	83 c2 1e             	add    $0x1e,%edx
  803e84:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803e89:	89 d0                	mov    %edx,%eax
  803e8b:	f7 e1                	mul    %ecx
  803e8d:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  803e90:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  803e96:	b8 ff ff 00 00       	mov    $0xffff,%eax
  803e9b:	0f 47 d0             	cmova  %eax,%edx
    if (dhcp->t2_timeout == 0) {
      dhcp->t2_timeout = 1;
  803e9e:	66 85 d2             	test   %dx,%dx
  803ea1:	b8 01 00 00 00       	mov    $0x1,%eax
  803ea6:	0f 44 d0             	cmove  %eax,%edx
  803ea9:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  803ead:	83 fb cc             	cmp    $0xffffffcc,%ebx
  803eb0:	0f 84 c4 00 00 00    	je     803f7a <dhcp_bind+0x183>
  803eb6:	8b 43 34             	mov    0x34(%ebx),%eax
  803eb9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  803ebc:	85 c0                	test   %eax,%eax
  803ebe:	75 48                	jne    803f08 <dhcp_bind+0x111>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  803ec0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803ec7:	e8 c0 41 00 00       	call   80808c <ntohl>
  803ecc:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  803ecf:	84 c0                	test   %al,%al
  803ed1:	78 11                	js     803ee4 <dhcp_bind+0xed>
      sn_mask.addr = htonl(0xff000000);
  803ed3:	c7 04 24 00 00 00 ff 	movl   $0xff000000,(%esp)
  803eda:	e8 a1 3f 00 00       	call   807e80 <htonl>
  803edf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803ee2:	eb 24                	jmp    803f08 <dhcp_bind+0x111>
    } else if (first_octet >= 192) {
  803ee4:	3c bf                	cmp    $0xbf,%al
  803ee6:	76 11                	jbe    803ef9 <dhcp_bind+0x102>
      sn_mask.addr = htonl(0xffffff00);
  803ee8:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  803eef:	e8 8c 3f 00 00       	call   807e80 <htonl>
  803ef4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803ef7:	eb 0f                	jmp    803f08 <dhcp_bind+0x111>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  803ef9:	c7 04 24 00 00 ff ff 	movl   $0xffff0000,(%esp)
  803f00:	e8 7b 3f 00 00       	call   807e80 <htonl>
  803f05:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  803f08:	83 fb c8             	cmp    $0xffffffc8,%ebx
  803f0b:	74 79                	je     803f86 <dhcp_bind+0x18f>
  803f0d:	8b 43 38             	mov    0x38(%ebx),%eax
  803f10:	89 45 e0             	mov    %eax,-0x20(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  803f13:	85 c0                	test   %eax,%eax
  803f15:	75 1a                	jne    803f31 <dhcp_bind+0x13a>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  803f17:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  803f1a:	23 7b 30             	and    0x30(%ebx),%edi
  803f1d:	89 7d e0             	mov    %edi,-0x20(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  803f20:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803f27:	e8 54 3f 00 00       	call   807e80 <htonl>
  803f2c:	09 c7                	or     %eax,%edi
  803f2e:	89 7d e0             	mov    %edi,-0x20(%ebp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  803f31:	8d 43 30             	lea    0x30(%ebx),%eax
  803f34:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f38:	89 34 24             	mov    %esi,(%esp)
  803f3b:	e8 54 0d 00 00       	call   804c94 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  803f40:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803f43:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f47:	89 34 24             	mov    %esi,(%esp)
  803f4a:	e8 77 0c 00 00       	call   804bc6 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  803f4f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803f52:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f56:	89 34 24             	mov    %esi,(%esp)
  803f59:	e8 4f 0c 00 00       	call   804bad <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  803f5e:	89 34 24             	mov    %esi,(%esp)
  803f61:	e8 f8 0c 00 00       	call   804c5e <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  803f66:	ba 0a 00 00 00       	mov    $0xa,%edx
  803f6b:	89 d8                	mov    %ebx,%eax
  803f6d:	e8 3e ec ff ff       	call   802bb0 <dhcp_set_state>
}
  803f72:	83 c4 2c             	add    $0x2c,%esp
  803f75:	5b                   	pop    %ebx
  803f76:	5e                   	pop    %esi
  803f77:	5f                   	pop    %edi
  803f78:	5d                   	pop    %ebp
  803f79:	c3                   	ret    
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  803f7a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  803f81:	e9 3a ff ff ff       	jmp    803ec0 <dhcp_bind+0xc9>
    } else {
      sn_mask.addr = htonl(0xffff0000);
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  803f86:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  803f8d:	eb 88                	jmp    803f17 <dhcp_bind+0x120>

00803f8f <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  803f8f:	55                   	push   %ebp
  803f90:	89 e5                	mov    %esp,%ebp
  803f92:	57                   	push   %edi
  803f93:	56                   	push   %esi
  803f94:	53                   	push   %ebx
  803f95:	83 ec 2c             	sub    $0x2c,%esp
  struct netif *netif = (struct netif *)arg;
  803f98:	8b 45 08             	mov    0x8(%ebp),%eax
  803f9b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  struct dhcp *dhcp = netif->dhcp;
  803f9e:	8b 50 20             	mov    0x20(%eax),%edx
  803fa1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  803fa4:	8b 4d 10             	mov    0x10(%ebp),%ecx
  803fa7:	8b 71 04             	mov    0x4(%ecx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  803faa:	89 4a 0c             	mov    %ecx,0xc(%edx)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  803fad:	80 3e 02             	cmpb   $0x2,(%esi)
  803fb0:	0f 85 1e 04 00 00    	jne    8043d4 <dhcp_recv+0x445>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  803fb6:	0f b6 78 24          	movzbl 0x24(%eax),%edi
  803fba:	89 c2                	mov    %eax,%edx
  803fbc:	b8 00 00 00 00       	mov    $0x0,%eax
  803fc1:	eb 17                	jmp    803fda <dhcp_recv+0x4b>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  803fc3:	0f b6 5a 25          	movzbl 0x25(%edx),%ebx
  803fc7:	0f b6 4c 06 1c       	movzbl 0x1c(%esi,%eax,1),%ecx
  803fcc:	83 c0 01             	add    $0x1,%eax
  803fcf:	83 c2 01             	add    $0x1,%edx
  803fd2:	38 cb                	cmp    %cl,%bl
  803fd4:	0f 85 fa 03 00 00    	jne    8043d4 <dhcp_recv+0x445>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  803fda:	89 f9                	mov    %edi,%ecx
  803fdc:	38 c1                	cmp    %al,%cl
  803fde:	77 e3                	ja     803fc3 <dhcp_recv+0x34>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  803fe0:	8b 46 04             	mov    0x4(%esi),%eax
  803fe3:	89 04 24             	mov    %eax,(%esp)
  803fe6:	e8 a1 40 00 00       	call   80808c <ntohl>
  803feb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  803fee:	3b 42 04             	cmp    0x4(%edx),%eax
  803ff1:	0f 85 dd 03 00 00    	jne    8043d4 <dhcp_recv+0x445>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  803ff7:	85 d2                	test   %edx,%edx
  803ff9:	75 1c                	jne    804017 <dhcp_recv+0x88>
  803ffb:	c7 44 24 08 d4 17 81 	movl   $0x8117d4,0x8(%esp)
  804002:	00 
  804003:	c7 44 24 04 89 04 00 	movl   $0x489,0x4(%esp)
  80400a:	00 
  80400b:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  804012:	e8 d5 b1 00 00       	call   80f1ec <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  804017:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80401a:	83 79 0c 00          	cmpl   $0x0,0xc(%ecx)
  80401e:	75 1c                	jne    80403c <dhcp_recv+0xad>
  804020:	c7 44 24 08 e1 17 81 	movl   $0x8117e1,0x8(%esp)
  804027:	00 
  804028:	c7 44 24 04 8a 04 00 	movl   $0x48a,0x4(%esp)
  80402f:	00 
  804030:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  804037:	e8 b0 b1 00 00       	call   80f1ec <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80403c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80403f:	e8 fe ef ff ff       	call   803042 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  804044:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  804047:	8b 42 0c             	mov    0xc(%edx),%eax
  80404a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80404e:	66 3d f0 00          	cmp    $0xf0,%ax
  804052:	76 21                	jbe    804075 <dhcp_recv+0xe6>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  804054:	66 2d f0 00          	sub    $0xf0,%ax
  804058:	66 89 42 18          	mov    %ax,0x18(%edx)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80405c:	0f b7 c0             	movzwl %ax,%eax
  80405f:	89 04 24             	mov    %eax,(%esp)
  804062:	e8 85 04 00 00       	call   8044ec <mem_malloc>
  804067:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80406a:	89 41 14             	mov    %eax,0x14(%ecx)
    if (dhcp->options_in == NULL) {
  80406d:	85 c0                	test   %eax,%eax
  80406f:	0f 84 5f 03 00 00    	je     8043d4 <dhcp_recv+0x445>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  804075:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  80407c:	e8 6b 04 00 00       	call   8044ec <mem_malloc>
  804081:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  804084:	89 42 10             	mov    %eax,0x10(%edx)
  if (dhcp->msg_in == NULL) {
  804087:	85 c0                	test   %eax,%eax
  804089:	75 1a                	jne    8040a5 <dhcp_recv+0x116>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  80408b:	8b 42 14             	mov    0x14(%edx),%eax
  80408e:	89 04 24             	mov    %eax,(%esp)
  804091:	e8 d1 07 00 00       	call   804867 <mem_free>
    dhcp->options_in = NULL;
  804096:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  804099:	c7 41 14 00 00 00 00 	movl   $0x0,0x14(%ecx)
  8040a0:	e9 2f 03 00 00       	jmp    8043d4 <dhcp_recv+0x445>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8040a5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8040ac:	00 
  8040ad:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  8040b4:	00 
  8040b5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8040b9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8040bc:	8b 42 0c             	mov    0xc(%edx),%eax
  8040bf:	89 04 24             	mov    %eax,(%esp)
  8040c2:	e8 f3 0e 00 00       	call   804fba <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8040c7:	66 3d f0 00          	cmp    $0xf0,%ax
  8040cb:	74 1c                	je     8040e9 <dhcp_recv+0x15a>
  8040cd:	c7 44 24 08 50 17 81 	movl   $0x811750,0x8(%esp)
  8040d4:	00 
  8040d5:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
  8040dc:	00 
  8040dd:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  8040e4:	e8 03 b1 00 00       	call   80f1ec <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  8040e9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8040ec:	8b 41 14             	mov    0x14(%ecx),%eax
  8040ef:	85 c0                	test   %eax,%eax
  8040f1:	0f 84 fa 02 00 00    	je     8043f1 <dhcp_recv+0x462>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8040f7:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  8040fe:	00 
  8040ff:	0f b7 51 18          	movzwl 0x18(%ecx),%edx
  804103:	89 54 24 08          	mov    %edx,0x8(%esp)
  804107:	89 44 24 04          	mov    %eax,0x4(%esp)
  80410b:	8b 41 0c             	mov    0xc(%ecx),%eax
  80410e:	89 04 24             	mov    %eax,(%esp)
  804111:	e8 a4 0e 00 00       	call   804fba <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  804116:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  804119:	66 3b 42 18          	cmp    0x18(%edx),%ax
  80411d:	0f 84 ce 02 00 00    	je     8043f1 <dhcp_recv+0x462>
  804123:	c7 44 24 08 f1 17 81 	movl   $0x8117f1,0x8(%esp)
  80412a:	00 
  80412b:	c7 44 24 04 a7 04 00 	movl   $0x4a7,0x4(%esp)
  804132:	00 
  804133:	c7 04 24 82 17 81 00 	movl   $0x811782,(%esp)
  80413a:	e8 ad b0 00 00       	call   80f1ec <_panic>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  80413f:	83 c0 02             	add    $0x2,%eax
  804142:	e8 66 eb ff ff       	call   802cad <dhcp_get_option_byte>
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  804147:	3c 05                	cmp    $0x5,%al
  804149:	0f 85 a5 01 00 00    	jne    8042f4 <dhcp_recv+0x365>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  80414f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  804152:	0f b6 01             	movzbl (%ecx),%eax
  804155:	3c 01                	cmp    $0x1,%al
  804157:	0f 85 76 01 00 00    	jne    8042d3 <dhcp_recv+0x344>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  80415d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  804160:	8b 58 20             	mov    0x20(%eax),%ebx
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  804163:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  dhcp->offered_gw_addr.addr = 0;
  80416a:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_bc_addr.addr = 0;
  804171:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  804178:	ba 33 00 00 00       	mov    $0x33,%edx
  80417d:	89 d8                	mov    %ebx,%eax
  80417f:	e8 3b ea ff ff       	call   802bbf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  804184:	85 c0                	test   %eax,%eax
  804186:	74 0b                	je     804193 <dhcp_recv+0x204>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  804188:	83 c0 02             	add    $0x2,%eax
  80418b:	e8 25 eb ff ff       	call   802cb5 <dhcp_get_option_long>
  804190:	89 43 4c             	mov    %eax,0x4c(%ebx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  804193:	ba 3a 00 00 00       	mov    $0x3a,%edx
  804198:	89 d8                	mov    %ebx,%eax
  80419a:	e8 20 ea ff ff       	call   802bbf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80419f:	85 c0                	test   %eax,%eax
  8041a1:	74 0d                	je     8041b0 <dhcp_recv+0x221>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  8041a3:	83 c0 02             	add    $0x2,%eax
  8041a6:	e8 0a eb ff ff       	call   802cb5 <dhcp_get_option_long>
  8041ab:	89 43 50             	mov    %eax,0x50(%ebx)
  8041ae:	eb 08                	jmp    8041b8 <dhcp_recv+0x229>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  8041b0:	8b 43 4c             	mov    0x4c(%ebx),%eax
  8041b3:	d1 e8                	shr    %eax
  8041b5:	89 43 50             	mov    %eax,0x50(%ebx)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  8041b8:	ba 3b 00 00 00       	mov    $0x3b,%edx
  8041bd:	89 d8                	mov    %ebx,%eax
  8041bf:	e8 fb e9 ff ff       	call   802bbf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8041c4:	85 c0                	test   %eax,%eax
  8041c6:	74 0d                	je     8041d5 <dhcp_recv+0x246>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  8041c8:	83 c0 02             	add    $0x2,%eax
  8041cb:	e8 e5 ea ff ff       	call   802cb5 <dhcp_get_option_long>
  8041d0:	89 43 54             	mov    %eax,0x54(%ebx)
  8041d3:	eb 06                	jmp    8041db <dhcp_recv+0x24c>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  8041d5:	8b 43 4c             	mov    0x4c(%ebx),%eax
  8041d8:	89 43 54             	mov    %eax,0x54(%ebx)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8041db:	8b 53 10             	mov    0x10(%ebx),%edx
  8041de:	b8 00 00 00 00       	mov    $0x0,%eax
  8041e3:	83 fa f0             	cmp    $0xfffffff0,%edx
  8041e6:	74 03                	je     8041eb <dhcp_recv+0x25c>
  8041e8:	8b 42 10             	mov    0x10(%edx),%eax
  8041eb:	89 43 30             	mov    %eax,0x30(%ebx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8041ee:	ba 01 00 00 00       	mov    $0x1,%edx
  8041f3:	89 d8                	mov    %ebx,%eax
  8041f5:	e8 c5 e9 ff ff       	call   802bbf <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  8041fa:	85 c0                	test   %eax,%eax
  8041fc:	74 13                	je     804211 <dhcp_recv+0x282>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8041fe:	83 c0 02             	add    $0x2,%eax
  804201:	e8 af ea ff ff       	call   802cb5 <dhcp_get_option_long>
  804206:	89 04 24             	mov    %eax,(%esp)
  804209:	e8 72 3c 00 00       	call   807e80 <htonl>
  80420e:	89 43 34             	mov    %eax,0x34(%ebx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  804211:	ba 03 00 00 00       	mov    $0x3,%edx
  804216:	89 d8                	mov    %ebx,%eax
  804218:	e8 a2 e9 ff ff       	call   802bbf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80421d:	85 c0                	test   %eax,%eax
  80421f:	74 13                	je     804234 <dhcp_recv+0x2a5>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  804221:	83 c0 02             	add    $0x2,%eax
  804224:	e8 8c ea ff ff       	call   802cb5 <dhcp_get_option_long>
  804229:	89 04 24             	mov    %eax,(%esp)
  80422c:	e8 4f 3c 00 00       	call   807e80 <htonl>
  804231:	89 43 38             	mov    %eax,0x38(%ebx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  804234:	ba 1c 00 00 00       	mov    $0x1c,%edx
  804239:	89 d8                	mov    %ebx,%eax
  80423b:	e8 7f e9 ff ff       	call   802bbf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  804240:	85 c0                	test   %eax,%eax
  804242:	74 13                	je     804257 <dhcp_recv+0x2c8>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  804244:	83 c0 02             	add    $0x2,%eax
  804247:	e8 69 ea ff ff       	call   802cb5 <dhcp_get_option_long>
  80424c:	89 04 24             	mov    %eax,(%esp)
  80424f:	e8 2c 3c 00 00       	call   807e80 <htonl>
  804254:	89 43 3c             	mov    %eax,0x3c(%ebx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  804257:	ba 06 00 00 00       	mov    $0x6,%edx
  80425c:	89 d8                	mov    %ebx,%eax
  80425e:	e8 5c e9 ff ff       	call   802bbf <dhcp_get_option_ptr>
  804263:	89 c6                	mov    %eax,%esi
  if (option_ptr != NULL) {
  804265:	85 c0                	test   %eax,%eax
  804267:	74 54                	je     8042bd <dhcp_recv+0x32e>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  804269:	8d 40 01             	lea    0x1(%eax),%eax
  80426c:	e8 3c ea ff ff       	call   802cad <dhcp_get_option_byte>
  804271:	c0 e8 02             	shr    $0x2,%al
  804274:	0f b6 c0             	movzbl %al,%eax
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  804277:	83 f8 03             	cmp    $0x3,%eax
  80427a:	ba 02 00 00 00       	mov    $0x2,%edx
  80427f:	0f 43 c2             	cmovae %edx,%eax
  804282:	89 43 40             	mov    %eax,0x40(%ebx)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  if (option_ptr != NULL) {
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  804285:	bf 00 00 00 00       	mov    $0x0,%edi
  80428a:	89 f8                	mov    %edi,%eax
  80428c:	89 f7                	mov    %esi,%edi
  80428e:	89 de                	mov    %ebx,%esi
  804290:	89 c3                	mov    %eax,%ebx
  804292:	eb 21                	jmp    8042b5 <dhcp_recv+0x326>
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  804294:	0f b6 d3             	movzbl %bl,%edx
  804297:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80429a:	8d 44 97 02          	lea    0x2(%edi,%edx,4),%eax
  80429e:	e8 12 ea ff ff       	call   802cb5 <dhcp_get_option_long>
  8042a3:	89 04 24             	mov    %eax,(%esp)
  8042a6:	e8 d5 3b 00 00       	call   807e80 <htonl>
  8042ab:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  8042ae:	89 44 8e 44          	mov    %eax,0x44(%esi,%ecx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  8042b2:	83 c3 01             	add    $0x1,%ebx
  8042b5:	0f b6 c3             	movzbl %bl,%eax
  8042b8:	3b 46 40             	cmp    0x40(%esi),%eax
  8042bb:	72 d7                	jb     804294 <dhcp_recv+0x305>
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  8042bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8042c0:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  8042c6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8042c9:	e8 ec fa ff ff       	call   803dba <dhcp_check>
  8042ce:	e9 01 01 00 00       	jmp    8043d4 <dhcp_recv+0x445>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  8042d3:	83 e8 03             	sub    $0x3,%eax
  8042d6:	3c 02                	cmp    $0x2,%al
  8042d8:	0f 87 f6 00 00 00    	ja     8043d4 <dhcp_recv+0x445>
      dhcp->request_timeout = 0;
  8042de:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8042e1:	66 c7 42 26 00 00    	movw   $0x0,0x26(%edx)
      dhcp_bind(netif);
  8042e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8042ea:	e8 08 fb ff ff       	call   803df7 <dhcp_bind>
  8042ef:	e9 e0 00 00 00       	jmp    8043d4 <dhcp_recv+0x445>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  8042f4:	3c 06                	cmp    $0x6,%al
  8042f6:	0f 85 80 00 00 00    	jne    80437c <dhcp_recv+0x3ed>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8042fc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8042ff:	0f b6 01             	movzbl (%ecx),%eax
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  804302:	3c 03                	cmp    $0x3,%al
  804304:	74 10                	je     804316 <dhcp_recv+0x387>
  804306:	3c 01                	cmp    $0x1,%al
  804308:	74 0c                	je     804316 <dhcp_recv+0x387>
  80430a:	3c 04                	cmp    $0x4,%al
  80430c:	74 08                	je     804316 <dhcp_recv+0x387>
  80430e:	3c 05                	cmp    $0x5,%al
  804310:	0f 85 be 00 00 00    	jne    8043d4 <dhcp_recv+0x445>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  804316:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804319:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  80431f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  804322:	8b 5a 20             	mov    0x20(%edx),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  804325:	89 14 24             	mov    %edx,(%esp)
  804328:	e8 0b 09 00 00       	call   804c38 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  80432d:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  804334:	00 
  804335:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  804338:	89 0c 24             	mov    %ecx,(%esp)
  80433b:	e8 54 09 00 00       	call   804c94 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  804340:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  804347:	00 
  804348:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80434b:	89 04 24             	mov    %eax,(%esp)
  80434e:	e8 5a 08 00 00       	call   804bad <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  804353:	c7 44 24 04 64 20 81 	movl   $0x812064,0x4(%esp)
  80435a:	00 
  80435b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80435e:	89 14 24             	mov    %edx,(%esp)
  804361:	e8 60 08 00 00       	call   804bc6 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  804366:	ba 0c 00 00 00       	mov    $0xc,%edx
  80436b:	89 d8                	mov    %ebx,%eax
  80436d:	e8 3e e8 ff ff       	call   802bb0 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  804372:	8b 45 e0             	mov    -0x20(%ebp),%eax
  804375:	e8 00 f2 ff ff       	call   80357a <dhcp_discover>
  80437a:	eb 58                	jmp    8043d4 <dhcp_recv+0x445>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80437c:	3c 02                	cmp    $0x2,%al
  80437e:	66 90                	xchg   %ax,%ax
  804380:	75 52                	jne    8043d4 <dhcp_recv+0x445>
  804382:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  804385:	80 39 06             	cmpb   $0x6,(%ecx)
  804388:	75 4a                	jne    8043d4 <dhcp_recv+0x445>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  80438a:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  804390:	8b 45 e0             	mov    -0x20(%ebp),%eax
  804393:	8b 58 20             	mov    0x20(%eax),%ebx
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  804396:	ba 36 00 00 00       	mov    $0x36,%edx
  80439b:	89 d8                	mov    %ebx,%eax
  80439d:	e8 1d e8 ff ff       	call   802bbf <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  8043a2:	85 c0                	test   %eax,%eax
  8043a4:	74 2e                	je     8043d4 <dhcp_recv+0x445>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8043a6:	83 c0 02             	add    $0x2,%eax
  8043a9:	e8 07 e9 ff ff       	call   802cb5 <dhcp_get_option_long>
  8043ae:	89 04 24             	mov    %eax,(%esp)
  8043b1:	e8 ca 3a 00 00       	call   807e80 <htonl>
  8043b6:	89 43 2c             	mov    %eax,0x2c(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8043b9:	8b 53 10             	mov    0x10(%ebx),%edx
  8043bc:	b8 00 00 00 00       	mov    $0x0,%eax
  8043c1:	83 fa f0             	cmp    $0xfffffff0,%edx
  8043c4:	74 03                	je     8043c9 <dhcp_recv+0x43a>
  8043c6:	8b 42 10             	mov    0x10(%edx),%eax
  8043c9:	89 43 30             	mov    %eax,0x30(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  8043cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8043cf:	e8 db f5 ff ff       	call   8039af <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  8043d4:	8b 55 10             	mov    0x10(%ebp),%edx
  8043d7:	89 14 24             	mov    %edx,(%esp)
  8043da:	e8 45 0e 00 00       	call   805224 <pbuf_free>
  dhcp->p = NULL;
  8043df:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8043e2:	c7 41 0c 00 00 00 00 	movl   $0x0,0xc(%ecx)
}
  8043e9:	83 c4 2c             	add    $0x2c,%esp
  8043ec:	5b                   	pop    %ebx
  8043ed:	5e                   	pop    %esi
  8043ee:	5f                   	pop    %edi
  8043ef:	5d                   	pop    %ebp
  8043f0:	c3                   	ret    
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  8043f1:	ba 35 00 00 00       	mov    $0x35,%edx
  8043f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8043f9:	e8 c1 e7 ff ff       	call   802bbf <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  8043fe:	85 c0                	test   %eax,%eax
  804400:	0f 85 39 fd ff ff    	jne    80413f <dhcp_recv+0x1b0>
  804406:	eb cc                	jmp    8043d4 <dhcp_recv+0x445>

00804408 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  804408:	55                   	push   %ebp
  804409:	89 e5                	mov    %esp,%ebp
  80440b:	53                   	push   %ebx
  80440c:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  80440f:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  804415:	e9 c2 00 00 00       	jmp    8044dc <dhcp_fine_tmr+0xd4>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  80441a:	8b 43 20             	mov    0x20(%ebx),%eax
  80441d:	85 c0                	test   %eax,%eax
  80441f:	0f 84 b5 00 00 00    	je     8044da <dhcp_fine_tmr+0xd2>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  804425:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  804429:	66 83 fa 01          	cmp    $0x1,%dx
  80442d:	76 0c                	jbe    80443b <dhcp_fine_tmr+0x33>
        netif->dhcp->request_timeout--;
  80442f:	83 ea 01             	sub    $0x1,%edx
  804432:	66 89 50 26          	mov    %dx,0x26(%eax)
  804436:	e9 9f 00 00 00       	jmp    8044da <dhcp_fine_tmr+0xd2>
      }
      else if (netif->dhcp->request_timeout == 1) {
  80443b:	66 83 fa 01          	cmp    $0x1,%dx
  80443f:	0f 85 95 00 00 00    	jne    8044da <dhcp_fine_tmr+0xd2>
        netif->dhcp->request_timeout--;
  804445:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  80444b:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  80444e:	0f b6 02             	movzbl (%edx),%eax
  804451:	3c 0c                	cmp    $0xc,%al
  804453:	74 04                	je     804459 <dhcp_fine_tmr+0x51>
  804455:	3c 06                	cmp    $0x6,%al
  804457:	75 09                	jne    804462 <dhcp_fine_tmr+0x5a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  804459:	89 d8                	mov    %ebx,%eax
  80445b:	e8 1a f1 ff ff       	call   80357a <dhcp_discover>
  804460:	eb 78                	jmp    8044da <dhcp_fine_tmr+0xd2>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  804462:	3c 01                	cmp    $0x1,%al
  804464:	75 20                	jne    804486 <dhcp_fine_tmr+0x7e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  804466:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  80446a:	77 09                	ja     804475 <dhcp_fine_tmr+0x6d>
      dhcp_select(netif);
  80446c:	89 d8                	mov    %ebx,%eax
  80446e:	e8 3c f5 ff ff       	call   8039af <dhcp_select>
  804473:	eb 65                	jmp    8044da <dhcp_fine_tmr+0xd2>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  804475:	89 1c 24             	mov    %ebx,(%esp)
  804478:	e8 7a ee ff ff       	call   8032f7 <dhcp_release>
      dhcp_discover(netif);
  80447d:	89 d8                	mov    %ebx,%eax
  80447f:	e8 f6 f0 ff ff       	call   80357a <dhcp_discover>
  804484:	eb 54                	jmp    8044da <dhcp_fine_tmr+0xd2>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  804486:	3c 08                	cmp    $0x8,%al
  804488:	75 1a                	jne    8044a4 <dhcp_fine_tmr+0x9c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  80448a:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  80448e:	66 90                	xchg   %ax,%ax
  804490:	77 09                	ja     80449b <dhcp_fine_tmr+0x93>
      dhcp_check(netif);
  804492:	89 d8                	mov    %ebx,%eax
  804494:	e8 21 f9 ff ff       	call   803dba <dhcp_check>
  804499:	eb 3f                	jmp    8044da <dhcp_fine_tmr+0xd2>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  80449b:	89 d8                	mov    %ebx,%eax
  80449d:	e8 55 f9 ff ff       	call   803df7 <dhcp_bind>
  8044a2:	eb 36                	jmp    8044da <dhcp_fine_tmr+0xd2>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  8044a4:	3c 05                	cmp    $0x5,%al
  8044a6:	75 0f                	jne    8044b7 <dhcp_fine_tmr+0xaf>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  8044a8:	89 1c 24             	mov    %ebx,(%esp)
  8044ab:	90                   	nop
  8044ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8044b0:	e8 ab ef ff ff       	call   803460 <dhcp_renew>
  8044b5:	eb 23                	jmp    8044da <dhcp_fine_tmr+0xd2>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  8044b7:	3c 04                	cmp    $0x4,%al
  8044b9:	75 1f                	jne    8044da <dhcp_fine_tmr+0xd2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  8044bb:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  8044bf:	90                   	nop
  8044c0:	77 09                	ja     8044cb <dhcp_fine_tmr+0xc3>
      dhcp_rebind(netif);
  8044c2:	89 d8                	mov    %ebx,%eax
  8044c4:	e8 0a f2 ff ff       	call   8036d3 <dhcp_rebind>
  8044c9:	eb 0f                	jmp    8044da <dhcp_fine_tmr+0xd2>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  8044cb:	89 1c 24             	mov    %ebx,(%esp)
  8044ce:	e8 24 ee ff ff       	call   8032f7 <dhcp_release>
      dhcp_discover(netif);
  8044d3:	89 d8                	mov    %ebx,%eax
  8044d5:	e8 a0 f0 ff ff       	call   80357a <dhcp_discover>
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  8044da:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  8044dc:	85 db                	test   %ebx,%ebx
  8044de:	0f 85 36 ff ff ff    	jne    80441a <dhcp_fine_tmr+0x12>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  8044e4:	83 c4 14             	add    $0x14,%esp
  8044e7:	5b                   	pop    %ebx
  8044e8:	5d                   	pop    %ebp
  8044e9:	c3                   	ret    
	...

008044ec <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  8044ec:	55                   	push   %ebp
  8044ed:	89 e5                	mov    %esp,%ebp
  8044ef:	83 ec 38             	sub    $0x38,%esp
  8044f2:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8044f5:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8044f8:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8044fb:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  8044fe:	85 c0                	test   %eax,%eax
  804500:	0f 84 a5 01 00 00    	je     8046ab <mem_malloc+0x1bf>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  804506:	83 c0 03             	add    $0x3,%eax
  804509:	83 e0 fc             	and    $0xfffffffc,%eax
  80450c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(size < MIN_SIZE_ALIGNED) {
  80450f:	83 f8 0b             	cmp    $0xb,%eax
  804512:	77 09                	ja     80451d <mem_malloc+0x31>
  804514:	c7 45 e4 0c 00 00 00 	movl   $0xc,-0x1c(%ebp)
  80451b:	eb 0d                	jmp    80452a <mem_malloc+0x3e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  80451d:	81 7d e4 00 00 22 00 	cmpl   $0x220000,-0x1c(%ebp)
  804524:	0f 87 81 01 00 00    	ja     8046ab <mem_malloc+0x1bf>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80452a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804531:	00 
  804532:	a1 28 53 a3 00       	mov    0xa35328,%eax
  804537:	89 04 24             	mov    %eax,(%esp)
  80453a:	e8 6e 64 00 00       	call   80a9ad <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80453f:	a1 24 53 a3 00       	mov    0xa35324,%eax
  804544:	89 45 dc             	mov    %eax,-0x24(%ebp)
  804547:	8b 15 1c 53 a3 00    	mov    0xa3531c,%edx
  80454d:	29 d0                	sub    %edx,%eax
  80454f:	b9 00 00 22 00       	mov    $0x220000,%ecx
  804554:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  804557:	89 55 e0             	mov    %edx,-0x20(%ebp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80455a:	e9 30 01 00 00       	jmp    80468f <mem_malloc+0x1a3>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  80455f:	8b 75 e0             	mov    -0x20(%ebp),%esi
  804562:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  804565:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804569:	0f 85 1e 01 00 00    	jne    80468d <mem_malloc+0x1a1>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80456f:	8b 3b                	mov    (%ebx),%edi
  804571:	83 ef 0c             	sub    $0xc,%edi
  804574:	29 c7                	sub    %eax,%edi
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  804576:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
  804579:	0f 82 0e 01 00 00    	jb     80468d <mem_malloc+0x1a1>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80457f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  804582:	83 c2 18             	add    $0x18,%edx
  804585:	39 fa                	cmp    %edi,%edx
  804587:	77 2a                	ja     8045b3 <mem_malloc+0xc7>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  804589:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80458c:	8d 4c 02 0c          	lea    0xc(%edx,%eax,1),%ecx
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  804590:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  804593:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  804597:	8b 3b                	mov    (%ebx),%edi
  804599:	89 3a                	mov    %edi,(%edx)
          mem2->prev = ptr;
  80459b:	89 42 04             	mov    %eax,0x4(%edx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  80459e:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  8045a0:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  8045a4:	8b 02                	mov    (%edx),%eax
  8045a6:	3d 00 00 22 00       	cmp    $0x220000,%eax
  8045ab:	74 0a                	je     8045b7 <mem_malloc+0xcb>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8045ad:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  8045b1:	eb 04                	jmp    8045b7 <mem_malloc+0xcb>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  8045b3:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  8045b7:	39 5d dc             	cmp    %ebx,-0x24(%ebp)
  8045ba:	75 51                	jne    80460d <mem_malloc+0x121>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8045bc:	8b 15 20 53 a3 00    	mov    0xa35320,%edx
  8045c2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  8045c5:	eb 05                	jmp    8045cc <mem_malloc+0xe0>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  8045c7:	8b 09                	mov    (%ecx),%ecx
  8045c9:	8d 0c 0e             	lea    (%esi,%ecx,1),%ecx
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8045cc:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
  8045d0:	84 c0                	test   %al,%al
  8045d2:	74 06                	je     8045da <mem_malloc+0xee>
  8045d4:	39 ca                	cmp    %ecx,%edx
  8045d6:	75 ef                	jne    8045c7 <mem_malloc+0xdb>
  8045d8:	eb 2a                	jmp    804604 <mem_malloc+0x118>
  8045da:	89 0d 24 53 a3 00    	mov    %ecx,0xa35324
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  8045e0:	39 ca                	cmp    %ecx,%edx
  8045e2:	74 29                	je     80460d <mem_malloc+0x121>
  8045e4:	84 c0                	test   %al,%al
  8045e6:	74 25                	je     80460d <mem_malloc+0x121>
  8045e8:	c7 44 24 08 0d 18 81 	movl   $0x81180d,0x8(%esp)
  8045ef:	00 
  8045f0:	c7 44 24 04 46 02 00 	movl   $0x246,0x4(%esp)
  8045f7:	00 
  8045f8:	c7 04 24 26 18 81 00 	movl   $0x811826,(%esp)
  8045ff:	e8 e8 ab 00 00       	call   80f1ec <_panic>
  804604:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  804607:	89 0d 24 53 a3 00    	mov    %ecx,0xa35324
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80460d:	a1 28 53 a3 00       	mov    0xa35328,%eax
  804612:	89 04 24             	mov    %eax,(%esp)
  804615:	e8 57 66 00 00       	call   80ac71 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80461a:	89 d8                	mov    %ebx,%eax
  80461c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80461f:	8d 54 0b 0c          	lea    0xc(%ebx,%ecx,1),%edx
  804623:	39 15 20 53 a3 00    	cmp    %edx,0xa35320
  804629:	73 1c                	jae    804647 <mem_malloc+0x15b>
  80462b:	c7 44 24 08 b0 18 81 	movl   $0x8118b0,0x8(%esp)
  804632:	00 
  804633:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  80463a:	00 
  80463b:	c7 04 24 26 18 81 00 	movl   $0x811826,(%esp)
  804642:	e8 a5 ab 00 00       	call   80f1ec <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804647:	f6 c3 03             	test   $0x3,%bl
  80464a:	74 1c                	je     804668 <mem_malloc+0x17c>
  80464c:	c7 44 24 08 e0 18 81 	movl   $0x8118e0,0x8(%esp)
  804653:	00 
  804654:	c7 44 24 04 4d 02 00 	movl   $0x24d,0x4(%esp)
  80465b:	00 
  80465c:	c7 04 24 26 18 81 00 	movl   $0x811826,(%esp)
  804663:	e8 84 ab 00 00       	call   80f1ec <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  804668:	a8 03                	test   $0x3,%al
  80466a:	74 1c                	je     804688 <mem_malloc+0x19c>
  80466c:	c7 44 24 08 10 19 81 	movl   $0x811910,0x8(%esp)
  804673:	00 
  804674:	c7 44 24 04 4f 02 00 	movl   $0x24f,0x4(%esp)
  80467b:	00 
  80467c:	c7 04 24 26 18 81 00 	movl   $0x811826,(%esp)
  804683:	e8 64 ab 00 00       	call   80f1ec <_panic>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  804688:	8d 43 0c             	lea    0xc(%ebx),%eax
  80468b:	eb 23                	jmp    8046b0 <mem_malloc+0x1c4>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  80468d:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80468f:	39 c8                	cmp    %ecx,%eax
  804691:	0f 82 c8 fe ff ff    	jb     80455f <mem_malloc+0x73>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  804697:	a1 28 53 a3 00       	mov    0xa35328,%eax
  80469c:	89 04 24             	mov    %eax,(%esp)
  80469f:	e8 cd 65 00 00       	call   80ac71 <sys_sem_signal>
  8046a4:	b8 00 00 00 00       	mov    $0x0,%eax
  return NULL;
  8046a9:	eb 05                	jmp    8046b0 <mem_malloc+0x1c4>
  8046ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8046b0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8046b3:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8046b6:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8046b9:	89 ec                	mov    %ebp,%esp
  8046bb:	5d                   	pop    %ebp
  8046bc:	c3                   	ret    

008046bd <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8046bd:	55                   	push   %ebp
  8046be:	89 e5                	mov    %esp,%ebp
  8046c0:	83 ec 18             	sub    $0x18,%esp
  8046c3:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8046c6:	89 75 fc             	mov    %esi,-0x4(%ebp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8046c9:	8b 75 0c             	mov    0xc(%ebp),%esi
  8046cc:	0f af 75 08          	imul   0x8(%ebp),%esi
  8046d0:	89 34 24             	mov    %esi,(%esp)
  8046d3:	e8 14 fe ff ff       	call   8044ec <mem_malloc>
  8046d8:	89 c3                	mov    %eax,%ebx
  if (p) {
  8046da:	85 c0                	test   %eax,%eax
  8046dc:	74 14                	je     8046f2 <mem_calloc+0x35>
    /* zero the memory */
    memset(p, 0, count * size);
  8046de:	89 74 24 08          	mov    %esi,0x8(%esp)
  8046e2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8046e9:	00 
  8046ea:	89 04 24             	mov    %eax,(%esp)
  8046ed:	e8 5e b3 00 00       	call   80fa50 <memset>
  }
  return p;
}
  8046f2:	89 d8                	mov    %ebx,%eax
  8046f4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8046f7:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8046fa:	89 ec                	mov    %ebp,%esp
  8046fc:	5d                   	pop    %ebp
  8046fd:	c3                   	ret    

008046fe <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  8046fe:	55                   	push   %ebp
  8046ff:	89 e5                	mov    %esp,%ebp
  804701:	83 ec 38             	sub    $0x38,%esp
  804704:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  804707:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80470a:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80470d:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  804710:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  804713:	83 c3 03             	add    $0x3,%ebx
  804716:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  804719:	83 fb 0b             	cmp    $0xb,%ebx
  80471c:	77 07                	ja     804725 <mem_realloc+0x27>
  80471e:	bb 0c 00 00 00       	mov    $0xc,%ebx
  804723:	eb 12                	jmp    804737 <mem_realloc+0x39>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  804725:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  80472b:	76 0a                	jbe    804737 <mem_realloc+0x39>
  80472d:	be 00 00 00 00       	mov    $0x0,%esi
  804732:	e9 21 01 00 00       	jmp    804858 <mem_realloc+0x15a>
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804737:	a1 1c 53 a3 00       	mov    0xa3531c,%eax
  80473c:	39 c6                	cmp    %eax,%esi
  80473e:	72 08                	jb     804748 <mem_realloc+0x4a>
  804740:	3b 35 20 53 a3 00    	cmp    0xa35320,%esi
  804746:	72 1c                	jb     804764 <mem_realloc+0x66>
  804748:	c7 44 24 08 3a 18 81 	movl   $0x81183a,0x8(%esp)
  80474f:	00 
  804750:	c7 44 24 04 79 01 00 	movl   $0x179,0x4(%esp)
  804757:	00 
  804758:	c7 04 24 26 18 81 00 	movl   $0x811826,(%esp)
  80475f:	e8 88 aa 00 00       	call   80f1ec <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  804764:	8d 7e f4             	lea    -0xc(%esi),%edi
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  804767:	89 fa                	mov    %edi,%edx
  804769:	29 c2                	sub    %eax,%edx
  80476b:	89 55 e0             	mov    %edx,-0x20(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80476e:	8b 07                	mov    (%edi),%eax
  804770:	83 e8 0c             	sub    $0xc,%eax
  804773:	29 d0                	sub    %edx,%eax
  804775:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804778:	39 d8                	cmp    %ebx,%eax
  80477a:	73 1c                	jae    804798 <mem_realloc+0x9a>
  80477c:	c7 44 24 08 34 19 81 	movl   $0x811934,0x8(%esp)
  804783:	00 
  804784:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80478b:	00 
  80478c:	c7 04 24 26 18 81 00 	movl   $0x811826,(%esp)
  804793:	e8 54 aa 00 00       	call   80f1ec <_panic>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  804798:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
  80479b:	0f 84 b7 00 00 00    	je     804858 <mem_realloc+0x15a>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8047a1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8047a8:	00 
  8047a9:	a1 28 53 a3 00       	mov    0xa35328,%eax
  8047ae:	89 04 24             	mov    %eax,(%esp)
  8047b1:	e8 f7 61 00 00       	call   80a9ad <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  8047b6:	a1 1c 53 a3 00       	mov    0xa3531c,%eax
  8047bb:	89 c2                	mov    %eax,%edx
  8047bd:	03 17                	add    (%edi),%edx
  if(mem2->used == 0) {
  8047bf:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8047c3:	75 41                	jne    804806 <mem_realloc+0x108>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  8047c5:	8b 0a                	mov    (%edx),%ecx
  8047c7:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8047ca:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8047cd:	8d 5c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ebx
    if (lfree == mem2) {
  8047d1:	39 15 24 53 a3 00    	cmp    %edx,0xa35324
  8047d7:	75 09                	jne    8047e2 <mem_realloc+0xe4>
      lfree = (struct mem *)&ram[ptr2];
  8047d9:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  8047dc:	89 15 24 53 a3 00    	mov    %edx,0xa35324
    }
    mem2 = (struct mem *)&ram[ptr2];
  8047e2:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  8047e5:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  8047e9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8047ec:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  8047ee:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8047f1:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  8047f4:	89 1f                	mov    %ebx,(%edi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8047f6:	8b 12                	mov    (%edx),%edx
  8047f8:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8047fe:	74 4b                	je     80484b <mem_realloc+0x14d>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804800:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
  804804:	eb 45                	jmp    80484b <mem_realloc+0x14d>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  804806:	8d 53 18             	lea    0x18(%ebx),%edx
  804809:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80480c:	72 3d                	jb     80484b <mem_realloc+0x14d>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80480e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  804811:	8d 5c 13 0c          	lea    0xc(%ebx,%edx,1),%ebx
    mem2 = (struct mem *)&ram[ptr2];
  804815:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    if (mem2 < lfree) {
      lfree = mem2;
  804818:	3b 15 24 53 a3 00    	cmp    0xa35324,%edx
  80481e:	8b 0d 24 53 a3 00    	mov    0xa35324,%ecx
  804824:	0f 42 ca             	cmovb  %edx,%ecx
  804827:	89 0d 24 53 a3 00    	mov    %ecx,0xa35324
    }
    mem2->used = 0;
  80482d:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  804831:	8b 0f                	mov    (%edi),%ecx
  804833:	89 0a                	mov    %ecx,(%edx)
    mem2->prev = ptr;
  804835:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  804838:	89 4a 04             	mov    %ecx,0x4(%edx)
    mem->next = ptr2;
  80483b:	89 1f                	mov    %ebx,(%edi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80483d:	8b 12                	mov    (%edx),%edx
  80483f:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804845:	74 04                	je     80484b <mem_realloc+0x14d>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804847:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80484b:	a1 28 53 a3 00       	mov    0xa35328,%eax
  804850:	89 04 24             	mov    %eax,(%esp)
  804853:	e8 19 64 00 00       	call   80ac71 <sys_sem_signal>
  return rmem;
}
  804858:	89 f0                	mov    %esi,%eax
  80485a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80485d:	8b 75 f8             	mov    -0x8(%ebp),%esi
  804860:	8b 7d fc             	mov    -0x4(%ebp),%edi
  804863:	89 ec                	mov    %ebp,%esp
  804865:	5d                   	pop    %ebp
  804866:	c3                   	ret    

00804867 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  804867:	55                   	push   %ebp
  804868:	89 e5                	mov    %esp,%ebp
  80486a:	83 ec 18             	sub    $0x18,%esp
  80486d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  804870:	89 75 fc             	mov    %esi,-0x4(%ebp)
  804873:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  804876:	85 db                	test   %ebx,%ebx
  804878:	0f 84 7d 01 00 00    	je     8049fb <mem_free+0x194>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80487e:	f6 c3 03             	test   $0x3,%bl
  804881:	74 1c                	je     80489f <mem_free+0x38>
  804883:	c7 44 24 08 58 19 81 	movl   $0x811958,0x8(%esp)
  80488a:	00 
  80488b:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  804892:	00 
  804893:	c7 04 24 26 18 81 00 	movl   $0x811826,(%esp)
  80489a:	e8 4d a9 00 00       	call   80f1ec <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80489f:	3b 1d 1c 53 a3 00    	cmp    0xa3531c,%ebx
  8048a5:	72 08                	jb     8048af <mem_free+0x48>
  8048a7:	3b 1d 20 53 a3 00    	cmp    0xa35320,%ebx
  8048ad:	72 1c                	jb     8048cb <mem_free+0x64>
  8048af:	c7 44 24 08 54 18 81 	movl   $0x811854,0x8(%esp)
  8048b6:	00 
  8048b7:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  8048be:	00 
  8048bf:	c7 04 24 26 18 81 00 	movl   $0x811826,(%esp)
  8048c6:	e8 21 a9 00 00       	call   80f1ec <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8048cb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8048d2:	00 
  8048d3:	a1 28 53 a3 00       	mov    0xa35328,%eax
  8048d8:	89 04 24             	mov    %eax,(%esp)
  8048db:	e8 cd 60 00 00       	call   80a9ad <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8048e0:	83 eb 0c             	sub    $0xc,%ebx
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  8048e3:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  8048e7:	75 1c                	jne    804905 <mem_free+0x9e>
  8048e9:	c7 44 24 08 6b 18 81 	movl   $0x81186b,0x8(%esp)
  8048f0:	00 
  8048f1:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  8048f8:	00 
  8048f9:	c7 04 24 26 18 81 00 	movl   $0x811826,(%esp)
  804900:	e8 e7 a8 00 00       	call   80f1ec <_panic>
  /* ... and is now unused. */
  mem->used = 0;
  804905:	c6 43 08 00          	movb   $0x0,0x8(%ebx)

  if (mem < lfree) {
  804909:	3b 1d 24 53 a3 00    	cmp    0xa35324,%ebx
  80490f:	73 06                	jae    804917 <mem_free+0xb0>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  804911:	89 1d 24 53 a3 00    	mov    %ebx,0xa35324
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  804917:	a1 1c 53 a3 00       	mov    0xa3531c,%eax
  80491c:	39 c3                	cmp    %eax,%ebx
  80491e:	73 1c                	jae    80493c <mem_free+0xd5>
  804920:	c7 44 24 08 7f 18 81 	movl   $0x81187f,0x8(%esp)
  804927:	00 
  804928:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  80492f:	00 
  804930:	c7 04 24 26 18 81 00 	movl   $0x811826,(%esp)
  804937:	e8 b0 a8 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80493c:	8b 35 20 53 a3 00    	mov    0xa35320,%esi
  804942:	39 f3                	cmp    %esi,%ebx
  804944:	72 1c                	jb     804962 <mem_free+0xfb>
  804946:	c7 44 24 08 96 18 81 	movl   $0x811896,0x8(%esp)
  80494d:	00 
  80494e:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
  804955:	00 
  804956:	c7 04 24 26 18 81 00 	movl   $0x811826,(%esp)
  80495d:	e8 8a a8 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  804962:	8b 13                	mov    (%ebx),%edx
  804964:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80496a:	76 1c                	jbe    804988 <mem_free+0x121>
  80496c:	c7 44 24 08 7c 19 81 	movl   $0x81197c,0x8(%esp)
  804973:	00 
  804974:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
  80497b:	00 
  80497c:	c7 04 24 26 18 81 00 	movl   $0x811826,(%esp)
  804983:	e8 64 a8 00 00       	call   80f1ec <_panic>

  nmem = (struct mem *)&ram[mem->next];
  804988:	89 c1                	mov    %eax,%ecx
  80498a:	8d 14 10             	lea    (%eax,%edx,1),%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80498d:	39 d3                	cmp    %edx,%ebx
  80498f:	74 2d                	je     8049be <mem_free+0x157>
  804991:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804995:	75 27                	jne    8049be <mem_free+0x157>
  804997:	39 d6                	cmp    %edx,%esi
  804999:	74 23                	je     8049be <mem_free+0x157>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
      lfree = mem;
  80499b:	3b 15 24 53 a3 00    	cmp    0xa35324,%edx
  8049a1:	8b 35 24 53 a3 00    	mov    0xa35324,%esi
  8049a7:	0f 44 f3             	cmove  %ebx,%esi
  8049aa:	89 35 24 53 a3 00    	mov    %esi,0xa35324
    }
    mem->next = nmem->next;
  8049b0:	8b 32                	mov    (%edx),%esi
  8049b2:	89 33                	mov    %esi,(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  8049b4:	8b 12                	mov    (%edx),%edx
  8049b6:	89 de                	mov    %ebx,%esi
  8049b8:	29 c6                	sub    %eax,%esi
  8049ba:	89 74 10 04          	mov    %esi,0x4(%eax,%edx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  8049be:	89 ca                	mov    %ecx,%edx
  8049c0:	03 53 04             	add    0x4(%ebx),%edx
  if (pmem != mem && pmem->used == 0) {
  8049c3:	39 d3                	cmp    %edx,%ebx
  8049c5:	74 27                	je     8049ee <mem_free+0x187>
  8049c7:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8049cb:	75 21                	jne    8049ee <mem_free+0x187>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
      lfree = pmem;
  8049cd:	3b 1d 24 53 a3 00    	cmp    0xa35324,%ebx
  8049d3:	8b 35 24 53 a3 00    	mov    0xa35324,%esi
  8049d9:	0f 44 f2             	cmove  %edx,%esi
  8049dc:	89 35 24 53 a3 00    	mov    %esi,0xa35324
    }
    pmem->next = mem->next;
  8049e2:	8b 33                	mov    (%ebx),%esi
  8049e4:	89 32                	mov    %esi,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8049e6:	8b 1b                	mov    (%ebx),%ebx
  8049e8:	29 c2                	sub    %eax,%edx
  8049ea:	89 54 19 04          	mov    %edx,0x4(%ecx,%ebx,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8049ee:	a1 28 53 a3 00       	mov    0xa35328,%eax
  8049f3:	89 04 24             	mov    %eax,(%esp)
  8049f6:	e8 76 62 00 00       	call   80ac71 <sys_sem_signal>
}
  8049fb:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8049fe:	8b 75 fc             	mov    -0x4(%ebp),%esi
  804a01:	89 ec                	mov    %ebp,%esp
  804a03:	5d                   	pop    %ebp
  804a04:	c3                   	ret    

00804a05 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  804a05:	55                   	push   %ebp
  804a06:	89 e5                	mov    %esp,%ebp
  804a08:	83 ec 18             	sub    $0x18,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  804a0b:	b8 03 53 81 00       	mov    $0x815303,%eax
  804a10:	83 e0 fc             	and    $0xfffffffc,%eax
  804a13:	a3 1c 53 a3 00       	mov    %eax,0xa3531c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  804a18:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  804a1e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  804a25:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  804a29:	05 00 00 22 00       	add    $0x220000,%eax
  804a2e:	a3 20 53 a3 00       	mov    %eax,0xa35320
  ram_end->used = 1;
  804a33:	c6 40 08 01          	movb   $0x1,0x8(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  804a37:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  804a3d:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%eax)

  mem_sem = sys_sem_new(1);
  804a44:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  804a4b:	e8 7f 60 00 00       	call   80aacf <sys_sem_new>
  804a50:	a3 28 53 a3 00       	mov    %eax,0xa35328

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  804a55:	a1 1c 53 a3 00       	mov    0xa3531c,%eax
  804a5a:	a3 24 53 a3 00       	mov    %eax,0xa35324

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  804a5f:	c9                   	leave  
  804a60:	c3                   	ret    
  804a61:	00 00                	add    %al,(%eax)
	...

00804a64 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  804a64:	55                   	push   %ebp
  804a65:	89 e5                	mov    %esp,%ebp
  804a67:	57                   	push   %edi
  804a68:	56                   	push   %esi
  804a69:	53                   	push   %ebx
  804a6a:	83 ec 04             	sub    $0x4,%esp
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  804a6d:	b8 83 53 a3 00       	mov    $0xa35383,%eax
  804a72:	83 e0 fc             	and    $0xfffffffc,%eax
  804a75:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  804a7a:	bb 40 53 a3 00       	mov    $0xa35340,%ebx
  804a7f:	c7 04 53 00 00 00 00 	movl   $0x0,(%ebx,%edx,2)
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804a86:	0f b7 8a 3a 1a 81 00 	movzwl 0x811a3a(%edx),%ecx
  804a8d:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
  804a91:	b9 00 00 00 00       	mov    $0x0,%ecx
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  804a96:	bf 1e 1a 81 00       	mov    $0x811a1e,%edi
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804a9b:	eb 11                	jmp    804aae <memp_init+0x4a>
      memp->next = memp_tab[i];
  804a9d:	8b 34 53             	mov    (%ebx,%edx,2),%esi
  804aa0:	89 30                	mov    %esi,(%eax)
      memp_tab[i] = memp;
  804aa2:	89 04 53             	mov    %eax,(%ebx,%edx,2)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  804aa5:	0f b7 34 17          	movzwl (%edi,%edx,1),%esi
  804aa9:	01 f0                	add    %esi,%eax
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804aab:	83 c1 01             	add    $0x1,%ecx
  804aae:	66 3b 4d f2          	cmp    -0xe(%ebp),%cx
  804ab2:	72 e9                	jb     804a9d <memp_init+0x39>
  804ab4:	83 c2 02             	add    $0x2,%edx
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  804ab7:	83 fa 1c             	cmp    $0x1c,%edx
  804aba:	75 c3                	jne    804a7f <memp_init+0x1b>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  804abc:	83 c4 04             	add    $0x4,%esp
  804abf:	5b                   	pop    %ebx
  804ac0:	5e                   	pop    %esi
  804ac1:	5f                   	pop    %edi
  804ac2:	5d                   	pop    %ebp
  804ac3:	c3                   	ret    

00804ac4 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  804ac4:	55                   	push   %ebp
  804ac5:	89 e5                	mov    %esp,%ebp
  804ac7:	53                   	push   %ebx
  804ac8:	83 ec 14             	sub    $0x14,%esp
  804acb:	8b 55 08             	mov    0x8(%ebp),%edx
  804ace:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  804ad1:	85 c0                	test   %eax,%eax
  804ad3:	74 2d                	je     804b02 <memp_free+0x3e>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  804ad5:	a8 03                	test   $0x3,%al
  804ad7:	74 1c                	je     804af5 <memp_free+0x31>
  804ad9:	c7 44 24 08 a8 19 81 	movl   $0x8119a8,0x8(%esp)
  804ae0:	00 
  804ae1:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
  804ae8:	00 
  804ae9:	c7 04 24 eb 19 81 00 	movl   $0x8119eb,(%esp)
  804af0:	e8 f7 a6 00 00       	call   80f1ec <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  804af5:	b9 40 53 a3 00       	mov    $0xa35340,%ecx
  804afa:	8b 1c 91             	mov    (%ecx,%edx,4),%ebx
  804afd:	89 18                	mov    %ebx,(%eax)
  memp_tab[type] = memp;
  804aff:	89 04 91             	mov    %eax,(%ecx,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  804b02:	83 c4 14             	add    $0x14,%esp
  804b05:	5b                   	pop    %ebx
  804b06:	5d                   	pop    %ebp
  804b07:	c3                   	ret    

00804b08 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  804b08:	55                   	push   %ebp
  804b09:	89 e5                	mov    %esp,%ebp
  804b0b:	83 ec 18             	sub    $0x18,%esp
  804b0e:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804b11:	83 fa 0d             	cmp    $0xd,%edx
  804b14:	76 1c                	jbe    804b32 <memp_malloc+0x2a>
  804b16:	c7 44 24 08 00 1a 81 	movl   $0x811a00,0x8(%esp)
  804b1d:	00 
  804b1e:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  804b25:	00 
  804b26:	c7 04 24 eb 19 81 00 	movl   $0x8119eb,(%esp)
  804b2d:	e8 ba a6 00 00       	call   80f1ec <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  804b32:	8b 04 95 40 53 a3 00 	mov    0xa35340(,%edx,4),%eax
  
  if (memp != NULL) {    
  804b39:	85 c0                	test   %eax,%eax
  804b3b:	74 29                	je     804b66 <memp_malloc+0x5e>
    memp_tab[type] = memp->next;    
  804b3d:	8b 08                	mov    (%eax),%ecx
  804b3f:	89 0c 95 40 53 a3 00 	mov    %ecx,0xa35340(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804b46:	a8 03                	test   $0x3,%al
  804b48:	74 1c                	je     804b66 <memp_malloc+0x5e>
  804b4a:	c7 44 24 08 c8 19 81 	movl   $0x8119c8,0x8(%esp)
  804b51:	00 
  804b52:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
  804b59:	00 
  804b5a:	c7 04 24 eb 19 81 00 	movl   $0x8119eb,(%esp)
  804b61:	e8 86 a6 00 00       	call   80f1ec <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  804b66:	c9                   	leave  
  804b67:	c3                   	ret    
	...

00804b70 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  804b70:	55                   	push   %ebp
  804b71:	89 e5                	mov    %esp,%ebp
  804b73:	53                   	push   %ebx
  804b74:	8b 55 08             	mov    0x8(%ebp),%edx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  804b77:	b8 00 00 00 00       	mov    $0x0,%eax
  804b7c:	85 d2                	test   %edx,%edx
  804b7e:	74 2a                	je     804baa <netif_find+0x3a>
    return NULL;
  }

  num = name[2] - '0';
  804b80:	0f b6 5a 02          	movzbl 0x2(%edx),%ebx
  804b84:	83 eb 30             	sub    $0x30,%ebx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804b87:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804b8c:	eb 18                	jmp    804ba6 <netif_find+0x36>
    if (num == netif->num &&
  804b8e:	38 58 31             	cmp    %bl,0x31(%eax)
  804b91:	75 11                	jne    804ba4 <netif_find+0x34>
  804b93:	0f b6 0a             	movzbl (%edx),%ecx
  804b96:	3a 48 2f             	cmp    0x2f(%eax),%cl
  804b99:	75 09                	jne    804ba4 <netif_find+0x34>
  804b9b:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
  804b9f:	3a 48 30             	cmp    0x30(%eax),%cl
  804ba2:	74 06                	je     804baa <netif_find+0x3a>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804ba4:	8b 00                	mov    (%eax),%eax
  804ba6:	85 c0                	test   %eax,%eax
  804ba8:	75 e4                	jne    804b8e <netif_find+0x1e>
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  804baa:	5b                   	pop    %ebx
  804bab:	5d                   	pop    %ebp
  804bac:	c3                   	ret    

00804bad <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  804bad:	55                   	push   %ebp
  804bae:	89 e5                	mov    %esp,%ebp
  804bb0:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  804bb3:	b8 00 00 00 00       	mov    $0x0,%eax
  804bb8:	85 d2                	test   %edx,%edx
  804bba:	74 02                	je     804bbe <netif_set_gw+0x11>
  804bbc:	8b 02                	mov    (%edx),%eax
  804bbe:	8b 55 08             	mov    0x8(%ebp),%edx
  804bc1:	89 42 0c             	mov    %eax,0xc(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  804bc4:	5d                   	pop    %ebp
  804bc5:	c3                   	ret    

00804bc6 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  804bc6:	55                   	push   %ebp
  804bc7:	89 e5                	mov    %esp,%ebp
  804bc9:	8b 55 0c             	mov    0xc(%ebp),%edx
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  804bcc:	b8 00 00 00 00       	mov    $0x0,%eax
  804bd1:	85 d2                	test   %edx,%edx
  804bd3:	74 02                	je     804bd7 <netif_set_netmask+0x11>
  804bd5:	8b 02                	mov    (%edx),%eax
  804bd7:	8b 55 08             	mov    0x8(%ebp),%edx
  804bda:	89 42 08             	mov    %eax,0x8(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  804bdd:	5d                   	pop    %ebp
  804bde:	c3                   	ret    

00804bdf <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  804bdf:	55                   	push   %ebp
  804be0:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804be2:	8b 45 08             	mov    0x8(%ebp),%eax
  804be5:	a3 38 b2 b3 00       	mov    %eax,0xb3b238
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  804bea:	5d                   	pop    %ebp
  804beb:	c3                   	ret    

00804bec <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  804bec:	55                   	push   %ebp
  804bed:	89 e5                	mov    %esp,%ebp
  804bef:	83 ec 04             	sub    $0x4,%esp
  804bf2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  804bf5:	85 c9                	test   %ecx,%ecx
  804bf7:	74 3d                	je     804c36 <netif_remove+0x4a>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  804bf9:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804bfe:	39 c8                	cmp    %ecx,%eax
  804c00:	75 17                	jne    804c19 <netif_remove+0x2d>
    netif_list = netif->next;
  804c02:	8b 00                	mov    (%eax),%eax
  804c04:	a3 34 b2 b3 00       	mov    %eax,0xb3b234
  804c09:	eb 17                	jmp    804c22 <netif_remove+0x36>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  804c0b:	8b 10                	mov    (%eax),%edx
  804c0d:	39 ca                	cmp    %ecx,%edx
  804c0f:	75 06                	jne    804c17 <netif_remove+0x2b>
        tmpNetif->next = netif->next;
  804c11:	8b 11                	mov    (%ecx),%edx
  804c13:	89 10                	mov    %edx,(%eax)
  804c15:	eb 0b                	jmp    804c22 <netif_remove+0x36>
  804c17:	89 d0                	mov    %edx,%eax
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804c19:	85 c0                	test   %eax,%eax
  804c1b:	75 ee                	jne    804c0b <netif_remove+0x1f>
  804c1d:	8d 76 00             	lea    0x0(%esi),%esi
  804c20:	eb 14                	jmp    804c36 <netif_remove+0x4a>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804c22:	39 0d 38 b2 b3 00    	cmp    %ecx,0xb3b238
  804c28:	75 0c                	jne    804c36 <netif_remove+0x4a>
    /* reset default netif */
    netif_set_default(NULL);
  804c2a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804c31:	e8 a9 ff ff ff       	call   804bdf <netif_set_default>
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804c36:	c9                   	leave  
  804c37:	c3                   	ret    

00804c38 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804c38:	55                   	push   %ebp
  804c39:	89 e5                	mov    %esp,%ebp
  804c3b:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( netif->flags & NETIF_FLAG_UP )
  804c3e:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  804c42:	f6 c2 01             	test   $0x1,%dl
  804c45:	74 06                	je     804c4d <netif_set_down+0x15>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  804c47:	83 e2 fe             	and    $0xfffffffe,%edx
  804c4a:	88 50 2e             	mov    %dl,0x2e(%eax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804c4d:	5d                   	pop    %ebp
  804c4e:	c3                   	ret    

00804c4f <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804c4f:	55                   	push   %ebp
  804c50:	89 e5                	mov    %esp,%ebp
  804c52:	8b 45 08             	mov    0x8(%ebp),%eax
  804c55:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804c59:	83 e0 01             	and    $0x1,%eax
  return (netif->flags & NETIF_FLAG_UP)?1:0;
}
  804c5c:	5d                   	pop    %ebp
  804c5d:	c3                   	ret    

00804c5e <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  804c5e:	55                   	push   %ebp
  804c5f:	89 e5                	mov    %esp,%ebp
  804c61:	83 ec 18             	sub    $0x18,%esp
  804c64:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  804c67:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  804c6b:	f6 c2 01             	test   $0x1,%dl
  804c6e:	75 22                	jne    804c92 <netif_set_up+0x34>
    netif->flags |= NETIF_FLAG_UP;
  804c70:	83 ca 01             	or     $0x1,%edx
  804c73:	88 50 2e             	mov    %dl,0x2e(%eax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  804c76:	f6 c2 20             	test   $0x20,%dl
  804c79:	74 17                	je     804c92 <netif_set_up+0x34>
      etharp_query(netif, &(netif->ip_addr), NULL);
  804c7b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804c82:	00 
  804c83:	8d 50 04             	lea    0x4(%eax),%edx
  804c86:	89 54 24 04          	mov    %edx,0x4(%esp)
  804c8a:	89 04 24             	mov    %eax,(%esp)
  804c8d:	e8 08 51 00 00       	call   809d9a <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
  804c92:	c9                   	leave  
  804c93:	c3                   	ret    

00804c94 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  804c94:	55                   	push   %ebp
  804c95:	89 e5                	mov    %esp,%ebp
  804c97:	57                   	push   %edi
  804c98:	56                   	push   %esi
  804c99:	53                   	push   %ebx
  804c9a:	83 ec 1c             	sub    $0x1c,%esp
  804c9d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804ca0:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804ca3:	8b 06                	mov    (%esi),%eax
  804ca5:	3b 43 04             	cmp    0x4(%ebx),%eax
  804ca8:	74 50                	je     804cfa <netif_set_ipaddr+0x66>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  804caa:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    while (pcb != NULL) {
  804caf:	eb 19                	jmp    804cca <netif_set_ipaddr+0x36>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  804cb1:	8b 10                	mov    (%eax),%edx
  804cb3:	3b 53 04             	cmp    0x4(%ebx),%edx
  804cb6:	75 0f                	jne    804cc7 <netif_set_ipaddr+0x33>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  804cb8:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  804cbb:	89 04 24             	mov    %eax,(%esp)
  804cbe:	e8 eb 15 00 00       	call   8062ae <tcp_abort>
  804cc3:	89 f8                	mov    %edi,%eax
  804cc5:	eb 03                	jmp    804cca <netif_set_ipaddr+0x36>
        pcb = next;
      } else {
        pcb = pcb->next;
  804cc7:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  804cca:	85 c0                	test   %eax,%eax
  804ccc:	75 e3                	jne    804cb1 <netif_set_ipaddr+0x1d>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804cce:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  804cd3:	b9 00 00 00 00       	mov    $0x0,%ecx
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804cd8:	eb 1c                	jmp    804cf6 <netif_set_ipaddr+0x62>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  804cda:	85 c0                	test   %eax,%eax
  804cdc:	74 15                	je     804cf3 <netif_set_ipaddr+0x5f>
  804cde:	8b 10                	mov    (%eax),%edx
  804ce0:	85 d2                	test   %edx,%edx
  804ce2:	74 0f                	je     804cf3 <netif_set_ipaddr+0x5f>
  804ce4:	3b 53 04             	cmp    0x4(%ebx),%edx
  804ce7:	75 0a                	jne    804cf3 <netif_set_ipaddr+0x5f>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  804ce9:	89 ca                	mov    %ecx,%edx
  804ceb:	85 f6                	test   %esi,%esi
  804ced:	74 02                	je     804cf1 <netif_set_ipaddr+0x5d>
  804cef:	8b 16                	mov    (%esi),%edx
  804cf1:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804cf3:	8b 40 0c             	mov    0xc(%eax),%eax
  804cf6:	85 c0                	test   %eax,%eax
  804cf8:	75 e0                	jne    804cda <netif_set_ipaddr+0x46>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  804cfa:	b8 00 00 00 00       	mov    $0x0,%eax
  804cff:	85 f6                	test   %esi,%esi
  804d01:	74 02                	je     804d05 <netif_set_ipaddr+0x71>
  804d03:	8b 06                	mov    (%esi),%eax
  804d05:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  804d08:	83 c4 1c             	add    $0x1c,%esp
  804d0b:	5b                   	pop    %ebx
  804d0c:	5e                   	pop    %esi
  804d0d:	5f                   	pop    %edi
  804d0e:	5d                   	pop    %ebp
  804d0f:	c3                   	ret    

00804d10 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  804d10:	55                   	push   %ebp
  804d11:	89 e5                	mov    %esp,%ebp
  804d13:	53                   	push   %ebx
  804d14:	83 ec 14             	sub    $0x14,%esp
  804d17:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif_set_ipaddr(netif, ipaddr);
  804d1a:	8b 45 0c             	mov    0xc(%ebp),%eax
  804d1d:	89 44 24 04          	mov    %eax,0x4(%esp)
  804d21:	89 1c 24             	mov    %ebx,(%esp)
  804d24:	e8 6b ff ff ff       	call   804c94 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
  804d29:	8b 45 10             	mov    0x10(%ebp),%eax
  804d2c:	89 44 24 04          	mov    %eax,0x4(%esp)
  804d30:	89 1c 24             	mov    %ebx,(%esp)
  804d33:	e8 8e fe ff ff       	call   804bc6 <netif_set_netmask>
  netif_set_gw(netif, gw);
  804d38:	8b 45 14             	mov    0x14(%ebp),%eax
  804d3b:	89 44 24 04          	mov    %eax,0x4(%esp)
  804d3f:	89 1c 24             	mov    %ebx,(%esp)
  804d42:	e8 66 fe ff ff       	call   804bad <netif_set_gw>
}
  804d47:	83 c4 14             	add    $0x14,%esp
  804d4a:	5b                   	pop    %ebx
  804d4b:	5d                   	pop    %ebp
  804d4c:	c3                   	ret    

00804d4d <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  804d4d:	55                   	push   %ebp
  804d4e:	89 e5                	mov    %esp,%ebp
  804d50:	53                   	push   %ebx
  804d51:	83 ec 14             	sub    $0x14,%esp
  804d54:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  804d57:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804d5e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804d65:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  804d6c:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  804d70:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  804d77:	8b 45 18             	mov    0x18(%ebp),%eax
  804d7a:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804d7d:	0f b6 05 e4 43 b3 00 	movzbl 0xb343e4,%eax
  804d84:	88 43 31             	mov    %al,0x31(%ebx)
  804d87:	83 c0 01             	add    $0x1,%eax
  804d8a:	a2 e4 43 b3 00       	mov    %al,0xb343e4
  netif->input = input;
  804d8f:	8b 45 20             	mov    0x20(%ebp),%eax
  804d92:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  804d95:	8b 45 14             	mov    0x14(%ebp),%eax
  804d98:	89 44 24 0c          	mov    %eax,0xc(%esp)
  804d9c:	8b 45 10             	mov    0x10(%ebp),%eax
  804d9f:	89 44 24 08          	mov    %eax,0x8(%esp)
  804da3:	8b 45 0c             	mov    0xc(%ebp),%eax
  804da6:	89 44 24 04          	mov    %eax,0x4(%esp)
  804daa:	89 1c 24             	mov    %ebx,(%esp)
  804dad:	e8 5e ff ff ff       	call   804d10 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  804db2:	89 1c 24             	mov    %ebx,(%esp)
  804db5:	ff 55 1c             	call   *0x1c(%ebp)
  804db8:	84 c0                	test   %al,%al
  804dba:	74 07                	je     804dc3 <netif_add+0x76>
  804dbc:	bb 00 00 00 00       	mov    $0x0,%ebx
  804dc1:	eb 0d                	jmp    804dd0 <netif_add+0x83>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  804dc3:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804dc8:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  804dca:	89 1d 34 b2 b3 00    	mov    %ebx,0xb3b234
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  804dd0:	89 d8                	mov    %ebx,%eax
  804dd2:	83 c4 14             	add    $0x14,%esp
  804dd5:	5b                   	pop    %ebx
  804dd6:	5d                   	pop    %ebp
  804dd7:	c3                   	ret    
	...

00804de0 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804de0:	55                   	push   %ebp
  804de1:	89 e5                	mov    %esp,%ebp
  804de3:	8b 55 08             	mov    0x8(%ebp),%edx
  804de6:	b8 00 00 00 00       	mov    $0x0,%eax
  u8_t len;

  len = 0;
  while (p != NULL) {
  804deb:	eb 05                	jmp    804df2 <pbuf_clen+0x12>
    ++len;
  804ded:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  804df0:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  804df2:	85 d2                	test   %edx,%edx
  804df4:	75 f7                	jne    804ded <pbuf_clen+0xd>
    ++len;
    p = p->next;
  }
  return len;
}
  804df6:	5d                   	pop    %ebp
  804df7:	c3                   	ret    

00804df8 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804df8:	55                   	push   %ebp
  804df9:	89 e5                	mov    %esp,%ebp
  804dfb:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804dfe:	85 c0                	test   %eax,%eax
  804e00:	74 05                	je     804e07 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804e02:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804e07:	5d                   	pop    %ebp
  804e08:	c3                   	ret    

00804e09 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804e09:	55                   	push   %ebp
  804e0a:	89 e5                	mov    %esp,%ebp
  804e0c:	53                   	push   %ebx
  804e0d:	83 ec 14             	sub    $0x14,%esp
  804e10:	8b 45 08             	mov    0x8(%ebp),%eax
  804e13:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804e16:	85 c0                	test   %eax,%eax
  804e18:	74 04                	je     804e1e <pbuf_cat+0x15>
  804e1a:	85 c9                	test   %ecx,%ecx
  804e1c:	75 26                	jne    804e44 <pbuf_cat+0x3b>
  804e1e:	c7 44 24 08 58 1a 81 	movl   $0x811a58,0x8(%esp)
  804e25:	00 
  804e26:	c7 44 24 04 42 02 00 	movl   $0x242,0x4(%esp)
  804e2d:	00 
  804e2e:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  804e35:	e8 b2 a3 00 00       	call   80f1ec <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804e3a:	0f b7 51 08          	movzwl 0x8(%ecx),%edx
  804e3e:	66 01 50 08          	add    %dx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  804e42:	8b 00                	mov    (%eax),%eax
  804e44:	8b 10                	mov    (%eax),%edx
  804e46:	85 d2                	test   %edx,%edx
  804e48:	75 f0                	jne    804e3a <pbuf_cat+0x31>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804e4a:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  804e4e:	66 3b 58 0a          	cmp    0xa(%eax),%bx
  804e52:	74 1c                	je     804e70 <pbuf_cat+0x67>
  804e54:	c7 44 24 08 90 1a 81 	movl   $0x811a90,0x8(%esp)
  804e5b:	00 
  804e5c:	c7 44 24 04 4a 02 00 	movl   $0x24a,0x4(%esp)
  804e63:	00 
  804e64:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  804e6b:	e8 7c a3 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  804e70:	85 d2                	test   %edx,%edx
  804e72:	74 1c                	je     804e90 <pbuf_cat+0x87>
  804e74:	c7 44 24 08 02 1c 81 	movl   $0x811c02,0x8(%esp)
  804e7b:	00 
  804e7c:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  804e83:	00 
  804e84:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  804e8b:	e8 5c a3 00 00       	call   80f1ec <_panic>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804e90:	66 03 59 08          	add    0x8(%ecx),%bx
  804e94:	66 89 58 08          	mov    %bx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804e98:	89 08                	mov    %ecx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804e9a:	83 c4 14             	add    $0x14,%esp
  804e9d:	5b                   	pop    %ebx
  804e9e:	5d                   	pop    %ebp
  804e9f:	c3                   	ret    

00804ea0 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804ea0:	55                   	push   %ebp
  804ea1:	89 e5                	mov    %esp,%ebp
  804ea3:	53                   	push   %ebx
  804ea4:	83 ec 14             	sub    $0x14,%esp
  804ea7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804eaa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  804eae:	8b 45 08             	mov    0x8(%ebp),%eax
  804eb1:	89 04 24             	mov    %eax,(%esp)
  804eb4:	e8 50 ff ff ff       	call   804e09 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804eb9:	89 1c 24             	mov    %ebx,(%esp)
  804ebc:	e8 37 ff ff ff       	call   804df8 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804ec1:	83 c4 14             	add    $0x14,%esp
  804ec4:	5b                   	pop    %ebx
  804ec5:	5d                   	pop    %ebp
  804ec6:	c3                   	ret    

00804ec7 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804ec7:	55                   	push   %ebp
  804ec8:	89 e5                	mov    %esp,%ebp
  804eca:	83 ec 18             	sub    $0x18,%esp
  804ecd:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  804ed0:	89 75 fc             	mov    %esi,-0x4(%ebp)
  804ed3:	8b 55 08             	mov    0x8(%ebp),%edx
  804ed6:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804eda:	85 d2                	test   %edx,%edx
  804edc:	75 1c                	jne    804efa <pbuf_header+0x33>
  804ede:	c7 44 24 08 cb 1c 81 	movl   $0x811ccb,0x8(%esp)
  804ee5:	00 
  804ee6:	c7 44 24 04 64 01 00 	movl   $0x164,0x4(%esp)
  804eed:	00 
  804eee:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  804ef5:	e8 f2 a2 00 00       	call   80f1ec <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  804efa:	b8 00 00 00 00       	mov    $0x0,%eax
  804eff:	66 85 c9             	test   %cx,%cx
  804f02:	0f 84 a8 00 00 00    	je     804fb0 <pbuf_header+0xe9>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  804f08:	89 ce                	mov    %ecx,%esi

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  804f0a:	66 85 c9             	test   %cx,%cx
  804f0d:	79 24                	jns    804f33 <pbuf_header+0x6c>
    increment_magnitude = -header_size_increment;
  804f0f:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  804f11:	66 3b 72 0a          	cmp    0xa(%edx),%si
  804f15:	76 1c                	jbe    804f33 <pbuf_header+0x6c>
  804f17:	c7 44 24 08 12 1c 81 	movl   $0x811c12,0x8(%esp)
  804f1e:	00 
  804f1f:	c7 44 24 04 6b 01 00 	movl   $0x16b,0x4(%esp)
  804f26:	00 
  804f27:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  804f2e:	e8 b9 a2 00 00       	call   80f1ec <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804f33:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  804f37:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  804f3a:	66 85 c0             	test   %ax,%ax
  804f3d:	74 06                	je     804f45 <pbuf_header+0x7e>
  804f3f:	66 83 f8 03          	cmp    $0x3,%ax
  804f43:	75 1d                	jne    804f62 <pbuf_header+0x9b>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  804f45:	0f bf c1             	movswl %cx,%eax
  804f48:	89 de                	mov    %ebx,%esi
  804f4a:	29 c6                	sub    %eax,%esi
  804f4c:	89 f0                	mov    %esi,%eax
  804f4e:	89 72 04             	mov    %esi,0x4(%edx)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804f51:	8d 72 10             	lea    0x10(%edx),%esi
  804f54:	39 f0                	cmp    %esi,%eax
  804f56:	73 44                	jae    804f9c <pbuf_header+0xd5>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  804f58:	89 5a 04             	mov    %ebx,0x4(%edx)
  804f5b:	b8 01 00 00 00       	mov    $0x1,%eax
      /* bail out unsuccesfully */
      return 1;
  804f60:	eb 4e                	jmp    804fb0 <pbuf_header+0xe9>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  804f62:	83 e8 01             	sub    $0x1,%eax
  804f65:	66 83 f8 01          	cmp    $0x1,%ax
  804f69:	77 15                	ja     804f80 <pbuf_header+0xb9>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  804f6b:	66 85 c9             	test   %cx,%cx
  804f6e:	79 3b                	jns    804fab <pbuf_header+0xe4>
  804f70:	66 3b 72 0a          	cmp    0xa(%edx),%si
  804f74:	77 35                	ja     804fab <pbuf_header+0xe4>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  804f76:	0f bf c1             	movswl %cx,%eax
  804f79:	29 c3                	sub    %eax,%ebx
  804f7b:	89 5a 04             	mov    %ebx,0x4(%edx)
  804f7e:	eb 1c                	jmp    804f9c <pbuf_header+0xd5>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  804f80:	c7 44 24 08 30 1c 81 	movl   $0x811c30,0x8(%esp)
  804f87:	00 
  804f88:	c7 44 24 04 9a 01 00 	movl   $0x19a,0x4(%esp)
  804f8f:	00 
  804f90:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  804f97:	e8 50 a2 00 00       	call   80f1ec <_panic>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  804f9c:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  804fa0:	66 01 4a 08          	add    %cx,0x8(%edx)
  804fa4:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  804fa9:	eb 05                	jmp    804fb0 <pbuf_header+0xe9>
  804fab:	b8 01 00 00 00       	mov    $0x1,%eax
}
  804fb0:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  804fb3:	8b 75 fc             	mov    -0x4(%ebp),%esi
  804fb6:	89 ec                	mov    %ebp,%esp
  804fb8:	5d                   	pop    %ebp
  804fb9:	c3                   	ret    

00804fba <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  804fba:	55                   	push   %ebp
  804fbb:	89 e5                	mov    %esp,%ebp
  804fbd:	57                   	push   %edi
  804fbe:	56                   	push   %esi
  804fbf:	53                   	push   %ebx
  804fc0:	83 ec 2c             	sub    $0x2c,%esp
  804fc3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804fc6:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  804fca:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804fce:	85 db                	test   %ebx,%ebx
  804fd0:	75 1c                	jne    804fee <pbuf_copy_partial+0x34>
  804fd2:	c7 44 24 08 c0 1a 81 	movl   $0x811ac0,0x8(%esp)
  804fd9:	00 
  804fda:	c7 44 24 04 ef 02 00 	movl   $0x2ef,0x4(%esp)
  804fe1:	00 
  804fe2:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  804fe9:	e8 fe a1 00 00       	call   80f1ec <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  804fee:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  804ff2:	74 0e                	je     805002 <pbuf_copy_partial+0x48>
  804ff4:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804ffa:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  805000:	eb 6e                	jmp    805070 <pbuf_copy_partial+0xb6>
  805002:	c7 44 24 08 e4 1a 81 	movl   $0x811ae4,0x8(%esp)
  805009:	00 
  80500a:	c7 44 24 04 f0 02 00 	movl   $0x2f0,0x4(%esp)
  805011:	00 
  805012:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  805019:	e8 ce a1 00 00       	call   80f1ec <_panic>
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  80501e:	66 85 c0             	test   %ax,%ax
  805021:	74 0e                	je     805031 <pbuf_copy_partial+0x77>
  805023:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  805027:	66 39 d0             	cmp    %dx,%ax
  80502a:	72 05                	jb     805031 <pbuf_copy_partial+0x77>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  80502c:	66 29 d0             	sub    %dx,%ax
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  80502f:	eb 3d                	jmp    80506e <pbuf_copy_partial+0xb4>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  805031:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  805035:	66 29 c7             	sub    %ax,%di
  805038:	66 39 f7             	cmp    %si,%di
  80503b:	0f 47 fe             	cmova  %esi,%edi
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80503e:	0f b7 d7             	movzwl %di,%edx
  805041:	89 54 24 08          	mov    %edx,0x8(%esp)
  805045:	0f b7 c0             	movzwl %ax,%eax
  805048:	03 43 04             	add    0x4(%ebx),%eax
  80504b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80504f:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805053:	03 45 0c             	add    0xc(%ebp),%eax
  805056:	89 04 24             	mov    %eax,(%esp)
  805059:	e8 cd aa 00 00       	call   80fb2b <memcpy>
      copied_total += buf_copy_len;
  80505e:	66 01 7d e4          	add    %di,-0x1c(%ebp)
      left += buf_copy_len;
  805062:	66 01 7d e6          	add    %di,-0x1a(%ebp)
      len -= buf_copy_len;
  805066:	66 29 fe             	sub    %di,%si
  805069:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80506e:	8b 1b                	mov    (%ebx),%ebx
  805070:	66 85 f6             	test   %si,%si
  805073:	74 04                	je     805079 <pbuf_copy_partial+0xbf>
  805075:	85 db                	test   %ebx,%ebx
  805077:	75 a5                	jne    80501e <pbuf_copy_partial+0x64>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  805079:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80507d:	83 c4 2c             	add    $0x2c,%esp
  805080:	5b                   	pop    %ebx
  805081:	5e                   	pop    %esi
  805082:	5f                   	pop    %edi
  805083:	5d                   	pop    %ebp
  805084:	c3                   	ret    

00805085 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  805085:	55                   	push   %ebp
  805086:	89 e5                	mov    %esp,%ebp
  805088:	57                   	push   %edi
  805089:	56                   	push   %esi
  80508a:	53                   	push   %ebx
  80508b:	83 ec 3c             	sub    $0x3c,%esp
  80508e:	8b 75 08             	mov    0x8(%ebp),%esi
  805091:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  805094:	85 f6                	test   %esi,%esi
  805096:	74 0e                	je     8050a6 <pbuf_copy+0x21>
  805098:	85 db                	test   %ebx,%ebx
  80509a:	74 0a                	je     8050a6 <pbuf_copy+0x21>
  80509c:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8050a0:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  8050a4:	73 1c                	jae    8050c2 <pbuf_copy+0x3d>
  8050a6:	c7 44 24 08 0c 1b 81 	movl   $0x811b0c,0x8(%esp)
  8050ad:	00 
  8050ae:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
  8050b5:	00 
  8050b6:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  8050bd:	e8 2a a1 00 00       	call   80f1ec <_panic>
  8050c2:	bf 00 00 00 00       	mov    $0x0,%edi
  8050c7:	66 c7 45 d6 00 00    	movw   $0x0,-0x2a(%ebp)
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  8050cd:	85 f6                	test   %esi,%esi
  8050cf:	75 1c                	jne    8050ed <pbuf_copy+0x68>
  8050d1:	c7 44 24 08 3e 1c 81 	movl   $0x811c3e,0x8(%esp)
  8050d8:	00 
  8050d9:	c7 44 24 04 b6 02 00 	movl   $0x2b6,0x4(%esp)
  8050e0:	00 
  8050e1:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  8050e8:	e8 ff a0 00 00       	call   80f1ec <_panic>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  8050ed:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  8050f1:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
  8050f5:	29 d0                	sub    %edx,%eax
  8050f7:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  8050fb:	0f b7 d7             	movzwl %di,%edx
  8050fe:	29 d1                	sub    %edx,%ecx
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  805100:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  805104:	66 29 fa             	sub    %di,%dx
  805107:	66 89 55 d8          	mov    %dx,-0x28(%ebp)
  80510b:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  80510f:	66 2b 55 d6          	sub    -0x2a(%ebp),%dx
  805113:	39 c8                	cmp    %ecx,%eax
  805115:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  805119:	0f 4c c2             	cmovl  %edx,%eax
  80511c:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  805120:	0f b7 c0             	movzwl %ax,%eax
  805123:	89 44 24 08          	mov    %eax,0x8(%esp)
  805127:	0f b7 c7             	movzwl %di,%eax
  80512a:	03 43 04             	add    0x4(%ebx),%eax
  80512d:	89 44 24 04          	mov    %eax,0x4(%esp)
  805131:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  805135:	03 46 04             	add    0x4(%esi),%eax
  805138:	89 04 24             	mov    %eax,(%esp)
  80513b:	e8 eb a9 00 00       	call   80fb2b <memcpy>
    offset_to += len;
  805140:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  805144:	66 01 55 d6          	add    %dx,-0x2a(%ebp)
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  805148:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80514c:	66 39 45 d6          	cmp    %ax,-0x2a(%ebp)
  805150:	76 1c                	jbe    80516e <pbuf_copy+0xe9>
  805152:	c7 44 24 08 4b 1c 81 	movl   $0x811c4b,0x8(%esp)
  805159:	00 
  80515a:	c7 44 24 04 c2 02 00 	movl   $0x2c2,0x4(%esp)
  805161:	00 
  805162:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  805169:	e8 7e a0 00 00       	call   80f1ec <_panic>
    if (offset_to == p_to->len) {
  80516e:	66 39 45 d6          	cmp    %ax,-0x2a(%ebp)
  805172:	75 08                	jne    80517c <pbuf_copy+0xf7>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  805174:	8b 36                	mov    (%esi),%esi
  805176:	66 c7 45 d6 00 00    	movw   $0x0,-0x2a(%ebp)
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
  80517c:	66 03 7d d8          	add    -0x28(%ebp),%di
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  805180:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  805184:	66 39 c7             	cmp    %ax,%di
  805187:	76 1c                	jbe    8051a5 <pbuf_copy+0x120>
  805189:	c7 44 24 08 62 1c 81 	movl   $0x811c62,0x8(%esp)
  805190:	00 
  805191:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
  805198:	00 
  805199:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  8051a0:	e8 47 a0 00 00       	call   80f1ec <_panic>
    if (offset_from >= p_from->len) {
  8051a5:	66 39 c7             	cmp    %ax,%di
  8051a8:	72 07                	jb     8051b1 <pbuf_copy+0x12c>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  8051aa:	8b 1b                	mov    (%ebx),%ebx
  8051ac:	bf 00 00 00 00       	mov    $0x0,%edi
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  8051b1:	85 db                	test   %ebx,%ebx
  8051b3:	74 2b                	je     8051e0 <pbuf_copy+0x15b>
  8051b5:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8051b9:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  8051bd:	75 21                	jne    8051e0 <pbuf_copy+0x15b>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  8051bf:	83 3b 00             	cmpl   $0x0,(%ebx)
  8051c2:	74 1c                	je     8051e0 <pbuf_copy+0x15b>
  8051c4:	c7 44 24 08 3c 1b 81 	movl   $0x811b3c,0x8(%esp)
  8051cb:	00 
  8051cc:	c7 44 24 04 d2 02 00 	movl   $0x2d2,0x4(%esp)
  8051d3:	00 
  8051d4:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  8051db:	e8 0c a0 00 00       	call   80f1ec <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  8051e0:	85 f6                	test   %esi,%esi
  8051e2:	74 2b                	je     80520f <pbuf_copy+0x18a>
  8051e4:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  8051e8:	66 3b 46 08          	cmp    0x8(%esi),%ax
  8051ec:	75 21                	jne    80520f <pbuf_copy+0x18a>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  8051ee:	83 3e 00             	cmpl   $0x0,(%esi)
  8051f1:	74 1c                	je     80520f <pbuf_copy+0x18a>
  8051f3:	c7 44 24 08 3c 1b 81 	movl   $0x811b3c,0x8(%esp)
  8051fa:	00 
  8051fb:	c7 44 24 04 d7 02 00 	movl   $0x2d7,0x4(%esp)
  805202:	00 
  805203:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  80520a:	e8 dd 9f 00 00       	call   80f1ec <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  80520f:	85 db                	test   %ebx,%ebx
  805211:	0f 85 b6 fe ff ff    	jne    8050cd <pbuf_copy+0x48>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  805217:	b8 00 00 00 00       	mov    $0x0,%eax
  80521c:	83 c4 3c             	add    $0x3c,%esp
  80521f:	5b                   	pop    %ebx
  805220:	5e                   	pop    %esi
  805221:	5f                   	pop    %edi
  805222:	5d                   	pop    %ebp
  805223:	c3                   	ret    

00805224 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  805224:	55                   	push   %ebp
  805225:	89 e5                	mov    %esp,%ebp
  805227:	56                   	push   %esi
  805228:	53                   	push   %ebx
  805229:	83 ec 10             	sub    $0x10,%esp
  80522c:	8b 55 08             	mov    0x8(%ebp),%edx
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80522f:	85 d2                	test   %edx,%edx
  805231:	75 1c                	jne    80524f <pbuf_free+0x2b>
    LWIP_ASSERT("p != NULL", p != NULL);
  805233:	c7 44 24 08 cb 1c 81 	movl   $0x811ccb,0x8(%esp)
  80523a:	00 
  80523b:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp)
  805242:	00 
  805243:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  80524a:	e8 9d 9f 00 00       	call   80f1ec <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  80524f:	80 7a 0c 03          	cmpb   $0x3,0xc(%edx)
  805253:	77 07                	ja     80525c <pbuf_free+0x38>
  805255:	be 00 00 00 00       	mov    $0x0,%esi
  80525a:	eb 1e                	jmp    80527a <pbuf_free+0x56>
  80525c:	c7 44 24 08 7d 1c 81 	movl   $0x811c7d,0x8(%esp)
  805263:	00 
  805264:	c7 44 24 04 db 01 00 	movl   $0x1db,0x4(%esp)
  80526b:	00 
  80526c:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  805273:	e8 74 9f 00 00       	call   80f1ec <_panic>
  805278:	89 da                	mov    %ebx,%edx
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80527a:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
  80527e:	66 85 c0             	test   %ax,%ax
  805281:	75 1c                	jne    80529f <pbuf_free+0x7b>
  805283:	c7 44 24 08 92 1c 81 	movl   $0x811c92,0x8(%esp)
  80528a:	00 
  80528b:	c7 44 24 04 e8 01 00 	movl   $0x1e8,0x4(%esp)
  805292:	00 
  805293:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  80529a:	e8 4d 9f 00 00       	call   80f1ec <_panic>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  80529f:	83 e8 01             	sub    $0x1,%eax
  8052a2:	66 89 42 0e          	mov    %ax,0xe(%edx)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  8052a6:	66 85 c0             	test   %ax,%ax
  8052a9:	75 48                	jne    8052f3 <pbuf_free+0xcf>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  8052ab:	8b 1a                	mov    (%edx),%ebx
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  8052ad:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  8052b1:	66 83 f8 03          	cmp    $0x3,%ax
  8052b5:	75 12                	jne    8052c9 <pbuf_free+0xa5>
        memp_free(MEMP_PBUF_POOL, p);
  8052b7:	89 54 24 04          	mov    %edx,0x4(%esp)
  8052bb:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  8052c2:	e8 fd f7 ff ff       	call   804ac4 <memp_free>
  8052c7:	eb 23                	jmp    8052ec <pbuf_free+0xc8>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  8052c9:	83 e8 01             	sub    $0x1,%eax
  8052cc:	66 83 f8 01          	cmp    $0x1,%ax
  8052d0:	77 12                	ja     8052e4 <pbuf_free+0xc0>
        memp_free(MEMP_PBUF, p);
  8052d2:	89 54 24 04          	mov    %edx,0x4(%esp)
  8052d6:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  8052dd:	e8 e2 f7 ff ff       	call   804ac4 <memp_free>
  8052e2:	eb 08                	jmp    8052ec <pbuf_free+0xc8>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  8052e4:	89 14 24             	mov    %edx,(%esp)
  8052e7:	e8 7b f5 ff ff       	call   804867 <mem_free>
      }
      count++;
  8052ec:	83 c6 01             	add    $0x1,%esi
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  8052ef:	85 db                	test   %ebx,%ebx
  8052f1:	75 85                	jne    805278 <pbuf_free+0x54>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  8052f3:	89 f0                	mov    %esi,%eax
  8052f5:	83 c4 10             	add    $0x10,%esp
  8052f8:	5b                   	pop    %ebx
  8052f9:	5e                   	pop    %esi
  8052fa:	5d                   	pop    %ebp
  8052fb:	c3                   	ret    

008052fc <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  8052fc:	55                   	push   %ebp
  8052fd:	89 e5                	mov    %esp,%ebp
  8052ff:	83 ec 38             	sub    $0x38,%esp
  805302:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805305:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805308:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80530b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  80530e:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  805310:	b8 01 00 00 00       	mov    $0x1,%eax
  805315:	85 f6                	test   %esi,%esi
  805317:	74 55                	je     80536e <pbuf_dechain+0x72>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  805319:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  80531d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  805321:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  805325:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  805328:	0f b7 fa             	movzwl %dx,%edi
  80532b:	0f b7 c8             	movzwl %ax,%ecx
  80532e:	29 cf                	sub    %ecx,%edi
  805330:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  805333:	74 1c                	je     805351 <pbuf_dechain+0x55>
  805335:	c7 44 24 08 68 1b 81 	movl   $0x811b68,0x8(%esp)
  80533c:	00 
  80533d:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
  805344:	00 
  805345:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  80534c:	e8 9b 9e 00 00       	call   80f1ec <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  805351:	66 29 c2             	sub    %ax,%dx
  805354:	66 89 56 08          	mov    %dx,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  805358:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  80535e:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  805362:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  805366:	89 34 24             	mov    %esi,(%esp)
  805369:	e8 b6 fe ff ff       	call   805224 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  80536e:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  805372:	66 3b 53 0a          	cmp    0xa(%ebx),%dx
  805376:	74 1c                	je     805394 <pbuf_dechain+0x98>
  805378:	c7 44 24 08 a8 1c 81 	movl   $0x811ca8,0x8(%esp)
  80537f:	00 
  805380:	c7 44 24 04 91 02 00 	movl   $0x291,0x4(%esp)
  805387:	00 
  805388:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  80538f:	e8 58 9e 00 00       	call   80f1ec <_panic>
  return ((tail_gone > 0) ? NULL : q);
  805394:	84 c0                	test   %al,%al
  805396:	b8 00 00 00 00       	mov    $0x0,%eax
  80539b:	0f 45 f0             	cmovne %eax,%esi
}
  80539e:	89 f0                	mov    %esi,%eax
  8053a0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8053a3:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8053a6:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8053a9:	89 ec                	mov    %ebp,%esp
  8053ab:	5d                   	pop    %ebp
  8053ac:	c3                   	ret    

008053ad <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  8053ad:	55                   	push   %ebp
  8053ae:	89 e5                	mov    %esp,%ebp
  8053b0:	56                   	push   %esi
  8053b1:	53                   	push   %ebx
  8053b2:	83 ec 10             	sub    $0x10,%esp
  8053b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8053b8:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  8053bc:	85 db                	test   %ebx,%ebx
  8053be:	75 1c                	jne    8053dc <pbuf_realloc+0x2f>
  8053c0:	c7 44 24 08 bd 1c 81 	movl   $0x811cbd,0x8(%esp)
  8053c7:	00 
  8053c8:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp)
  8053cf:	00 
  8053d0:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  8053d7:	e8 10 9e 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  8053dc:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  8053e0:	3c 03                	cmp    $0x3,%al
  8053e2:	74 2a                	je     80540e <pbuf_realloc+0x61>
  8053e4:	3c 01                	cmp    $0x1,%al
  8053e6:	74 26                	je     80540e <pbuf_realloc+0x61>
  8053e8:	84 c0                	test   %al,%al
  8053ea:	74 22                	je     80540e <pbuf_realloc+0x61>
  8053ec:	3c 02                	cmp    $0x2,%al
  8053ee:	66 90                	xchg   %ax,%ax
  8053f0:	74 1c                	je     80540e <pbuf_realloc+0x61>
  8053f2:	c7 44 24 08 d5 1c 81 	movl   $0x811cd5,0x8(%esp)
  8053f9:	00 
  8053fa:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
  805401:	00 
  805402:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  805409:	e8 de 9d 00 00       	call   80f1ec <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  80540e:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805412:	66 39 f0             	cmp    %si,%ax
  805415:	0f 86 bd 00 00 00    	jbe    8054d8 <pbuf_realloc+0x12b>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  80541b:	0f b7 d6             	movzwl %si,%edx
  80541e:	0f b7 c0             	movzwl %ax,%eax
  805421:	29 c2                	sub    %eax,%edx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  805423:	eb 4d                	jmp    805472 <pbuf_realloc+0xc5>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  805425:	81 fa fe ff 00 00    	cmp    $0xfffe,%edx
  80542b:	7e 1c                	jle    805449 <pbuf_realloc+0x9c>
  80542d:	c7 44 24 08 f0 1c 81 	movl   $0x811cf0,0x8(%esp)
  805434:	00 
  805435:	c7 44 24 04 2b 01 00 	movl   $0x12b,0x4(%esp)
  80543c:	00 
  80543d:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  805444:	e8 a3 9d 00 00       	call   80f1ec <_panic>
    q->tot_len += (u16_t)grow;
  805449:	66 01 53 08          	add    %dx,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  80544d:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  80544f:	85 db                	test   %ebx,%ebx
  805451:	75 1c                	jne    80546f <pbuf_realloc+0xc2>
  805453:	c7 44 24 08 01 1d 81 	movl   $0x811d01,0x8(%esp)
  80545a:	00 
  80545b:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  805462:	00 
  805463:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  80546a:	e8 7d 9d 00 00       	call   80f1ec <_panic>
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  80546f:	66 29 c6             	sub    %ax,%si

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  805472:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  805476:	66 39 c6             	cmp    %ax,%si
  805479:	77 aa                	ja     805425 <pbuf_realloc+0x78>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  80547b:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80547f:	75 3b                	jne    8054bc <pbuf_realloc+0x10f>
  805481:	66 39 f0             	cmp    %si,%ax
  805484:	74 36                	je     8054bc <pbuf_realloc+0x10f>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  805486:	0f b7 c6             	movzwl %si,%eax
  805489:	03 43 04             	add    0x4(%ebx),%eax
  80548c:	29 d8                	sub    %ebx,%eax
  80548e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805492:	89 1c 24             	mov    %ebx,(%esp)
  805495:	e8 64 f2 ff ff       	call   8046fe <mem_realloc>
  80549a:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  80549c:	85 c0                	test   %eax,%eax
  80549e:	75 1c                	jne    8054bc <pbuf_realloc+0x10f>
  8054a0:	c7 44 24 08 19 1d 81 	movl   $0x811d19,0x8(%esp)
  8054a7:	00 
  8054a8:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
  8054af:	00 
  8054b0:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  8054b7:	e8 30 9d 00 00       	call   80f1ec <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  8054bc:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  8054c0:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  8054c4:	8b 03                	mov    (%ebx),%eax
  8054c6:	85 c0                	test   %eax,%eax
  8054c8:	74 08                	je     8054d2 <pbuf_realloc+0x125>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  8054ca:	89 04 24             	mov    %eax,(%esp)
  8054cd:	e8 52 fd ff ff       	call   805224 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  8054d2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  8054d8:	83 c4 10             	add    $0x10,%esp
  8054db:	5b                   	pop    %ebx
  8054dc:	5e                   	pop    %esi
  8054dd:	5d                   	pop    %ebp
  8054de:	c3                   	ret    

008054df <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  8054df:	55                   	push   %ebp
  8054e0:	89 e5                	mov    %esp,%ebp
  8054e2:	57                   	push   %edi
  8054e3:	56                   	push   %esi
  8054e4:	53                   	push   %ebx
  8054e5:	83 ec 2c             	sub    $0x2c,%esp
  8054e8:	8b 45 08             	mov    0x8(%ebp),%eax
  8054eb:	8b 7d 10             	mov    0x10(%ebp),%edi
  8054ee:	0f b7 5d 0c          	movzwl 0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  8054f2:	83 f8 01             	cmp    $0x1,%eax
  8054f5:	74 22                	je     805519 <pbuf_alloc+0x3a>
  8054f7:	ba 14 00 00 00       	mov    $0x14,%edx
  8054fc:	83 f8 01             	cmp    $0x1,%eax
  8054ff:	72 1d                	jb     80551e <pbuf_alloc+0x3f>
  805501:	83 f8 02             	cmp    $0x2,%eax
  805504:	74 0c                	je     805512 <pbuf_alloc+0x33>
  805506:	83 f8 03             	cmp    $0x3,%eax
  805509:	75 1f                	jne    80552a <pbuf_alloc+0x4b>
  80550b:	90                   	nop
  80550c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  805510:	eb 34                	jmp    805546 <pbuf_alloc+0x67>
  805512:	ba 00 00 00 00       	mov    $0x0,%edx
  805517:	eb 08                	jmp    805521 <pbuf_alloc+0x42>
  805519:	ba 00 00 00 00       	mov    $0x0,%edx
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  80551e:	83 c2 14             	add    $0x14,%edx
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  805521:	83 c2 0e             	add    $0xe,%edx
  805524:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    break;
  805528:	eb 22                	jmp    80554c <pbuf_alloc+0x6d>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  80552a:	c7 44 24 08 34 1d 81 	movl   $0x811d34,0x8(%esp)
  805531:	00 
  805532:	c7 44 24 04 8a 00 00 	movl   $0x8a,0x4(%esp)
  805539:	00 
  80553a:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  805541:	e8 a6 9c 00 00       	call   80f1ec <_panic>
  805546:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
    return NULL;
  }

  switch (type) {
  80554c:	83 ff 02             	cmp    $0x2,%edi
  80554f:	77 0e                	ja     80555f <pbuf_alloc+0x80>
  805551:	83 ff 01             	cmp    $0x1,%edi
  805554:	0f 83 b4 01 00 00    	jae    80570e <pbuf_alloc+0x22f>
  80555a:	e9 6d 01 00 00       	jmp    8056cc <pbuf_alloc+0x1ed>
  80555f:	83 ff 03             	cmp    $0x3,%edi
  805562:	0f 85 d4 01 00 00    	jne    80573c <pbuf_alloc+0x25d>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  805568:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  80556f:	e8 94 f5 ff ff       	call   804b08 <memp_malloc>
  805574:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  805576:	85 c0                	test   %eax,%eax
  805578:	0f 84 e4 01 00 00    	je     805762 <pbuf_alloc+0x283>
      return NULL;
    }
    p->type = type;
  80557e:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  805582:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  805588:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80558c:	8d 54 06 13          	lea    0x13(%esi,%eax,1),%edx
  805590:	83 e2 fc             	and    $0xfffffffc,%edx
  805593:	89 56 04             	mov    %edx,0x4(%esi)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  805596:	66 89 5e 08          	mov    %bx,0x8(%esi)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  80559a:	0f b7 db             	movzwl %bx,%ebx
  80559d:	83 c0 03             	add    $0x3,%eax
  8055a0:	89 c1                	mov    %eax,%ecx
  8055a2:	83 e1 fc             	and    $0xfffffffc,%ecx
  8055a5:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  8055aa:	29 c8                	sub    %ecx,%eax
  8055ac:	39 d8                	cmp    %ebx,%eax
  8055ae:	0f 4f c3             	cmovg  %ebx,%eax
  8055b1:	89 c1                	mov    %eax,%ecx
  8055b3:	66 89 46 0a          	mov    %ax,0xa(%esi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  8055b7:	8d 86 e0 07 00 00    	lea    0x7e0(%esi),%eax
  8055bd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8055c0:	0f b7 c1             	movzwl %cx,%eax
  8055c3:	01 c2                	add    %eax,%edx
  8055c5:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8055c8:	73 1c                	jae    8055e6 <pbuf_alloc+0x107>
  8055ca:	c7 44 24 08 8c 1b 81 	movl   $0x811b8c,0x8(%esp)
  8055d1:	00 
  8055d2:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  8055d9:	00 
  8055da:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  8055e1:	e8 06 9c 00 00       	call   80f1ec <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  8055e6:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  8055ec:	0f b7 c9             	movzwl %cx,%ecx
  8055ef:	29 cb                	sub    %ecx,%ebx
  8055f1:	89 f7                	mov    %esi,%edi
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  8055f3:	e9 c7 00 00 00       	jmp    8056bf <pbuf_alloc+0x1e0>
      q = memp_malloc(MEMP_PBUF_POOL);
  8055f8:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  8055ff:	e8 04 f5 ff ff       	call   804b08 <memp_malloc>
      if (q == NULL) {
  805604:	85 c0                	test   %eax,%eax
  805606:	75 12                	jne    80561a <pbuf_alloc+0x13b>
        /* free chain so far allocated */
        pbuf_free(p);
  805608:	89 34 24             	mov    %esi,(%esp)
  80560b:	e8 14 fc ff ff       	call   805224 <pbuf_free>
  805610:	be 00 00 00 00       	mov    $0x0,%esi
        /* bail out unsuccesfully */
        return NULL;
  805615:	e9 48 01 00 00       	jmp    805762 <pbuf_alloc+0x283>
      }
      q->type = type;
  80561a:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  80561e:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  805622:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  805628:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80562a:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  805630:	7e 1c                	jle    80564e <pbuf_alloc+0x16f>
  805632:	c7 44 24 08 4f 1d 81 	movl   $0x811d4f,0x8(%esp)
  805639:	00 
  80563a:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  805641:	00 
  805642:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  805649:	e8 9e 9b 00 00       	call   80f1ec <_panic>
      q->tot_len = (u16_t)rem_len;
  80564e:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  805652:	66 81 fb cf 07       	cmp    $0x7cf,%bx
  805657:	b9 d0 07 00 00       	mov    $0x7d0,%ecx
  80565c:	0f 46 cb             	cmovbe %ebx,%ecx
  80565f:	66 89 48 0a          	mov    %cx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  805663:	8d 50 10             	lea    0x10(%eax),%edx
  805666:	89 50 04             	mov    %edx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  805669:	f6 c2 03             	test   $0x3,%dl
  80566c:	74 1c                	je     80568a <pbuf_alloc+0x1ab>
  80566e:	c7 44 24 08 c0 1b 81 	movl   $0x811bc0,0x8(%esp)
  805675:	00 
  805676:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80567d:	00 
  80567e:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  805685:	e8 62 9b 00 00       	call   80f1ec <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80568a:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  80568e:	03 56 04             	add    0x4(%esi),%edx
  805691:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805694:	73 1c                	jae    8056b2 <pbuf_alloc+0x1d3>
  805696:	c7 44 24 08 8c 1b 81 	movl   $0x811b8c,0x8(%esp)
  80569d:	00 
  80569e:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
  8056a5:	00 
  8056a6:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  8056ad:	e8 3a 9b 00 00       	call   80f1ec <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  8056b2:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  8056b8:	0f b7 c9             	movzwl %cx,%ecx
  8056bb:	29 cb                	sub    %ecx,%ebx
  8056bd:	89 c7                	mov    %eax,%edi
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  8056bf:	85 db                	test   %ebx,%ebx
  8056c1:	0f 8f 31 ff ff ff    	jg     8055f8 <pbuf_alloc+0x119>
  8056c7:	e9 8c 00 00 00       	jmp    805758 <pbuf_alloc+0x279>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  8056cc:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  8056d0:	8d 57 13             	lea    0x13(%edi),%edx
  8056d3:	83 e2 fc             	and    $0xfffffffc,%edx
  8056d6:	0f b7 c3             	movzwl %bx,%eax
  8056d9:	83 c0 03             	add    $0x3,%eax
  8056dc:	83 e0 fc             	and    $0xfffffffc,%eax
  8056df:	8d 04 02             	lea    (%edx,%eax,1),%eax
  8056e2:	89 04 24             	mov    %eax,(%esp)
  8056e5:	e8 02 ee ff ff       	call   8044ec <mem_malloc>
  8056ea:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8056ec:	85 c0                	test   %eax,%eax
  8056ee:	74 72                	je     805762 <pbuf_alloc+0x283>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  8056f0:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  8056f4:	83 e0 fc             	and    $0xfffffffc,%eax
  8056f7:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  8056fa:	66 89 5e 08          	mov    %bx,0x8(%esi)
  8056fe:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  805702:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  805708:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80570c:	eb 4a                	jmp    805758 <pbuf_alloc+0x279>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  80570e:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  805715:	e8 ee f3 ff ff       	call   804b08 <memp_malloc>
  80571a:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  80571c:	85 c0                	test   %eax,%eax
  80571e:	74 42                	je     805762 <pbuf_alloc+0x283>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  805720:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  805727:	66 89 58 08          	mov    %bx,0x8(%eax)
  80572b:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  80572f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  805735:	89 f8                	mov    %edi,%eax
  805737:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  80573a:	eb 1c                	jmp    805758 <pbuf_alloc+0x279>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  80573c:	c7 44 24 08 63 1d 81 	movl   $0x811d63,0x8(%esp)
  805743:	00 
  805744:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
  80574b:	00 
  80574c:	c7 04 24 ed 1b 81 00 	movl   $0x811bed,(%esp)
  805753:	e8 94 9a 00 00       	call   80f1ec <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  805758:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  80575e:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  805762:	89 f0                	mov    %esi,%eax
  805764:	83 c4 2c             	add    $0x2c,%esp
  805767:	5b                   	pop    %ebx
  805768:	5e                   	pop    %esi
  805769:	5f                   	pop    %edi
  80576a:	5d                   	pop    %ebp
  80576b:	c3                   	ret    
  80576c:	00 00                	add    %al,(%eax)
	...

00805770 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805770:	55                   	push   %ebp
  805771:	89 e5                	mov    %esp,%ebp
  805773:	83 ec 18             	sub    $0x18,%esp
  805776:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  805779:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  80577e:	8b 40 04             	mov    0x4(%eax),%eax
  805781:	8b 00                	mov    (%eax),%eax
  805783:	89 04 24             	mov    %eax,(%esp)
  805786:	e8 e6 54 00 00       	call   80ac71 <sys_sem_signal>
}
  80578b:	c9                   	leave  
  80578c:	c3                   	ret    

0080578d <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80578d:	55                   	push   %ebp
  80578e:	89 e5                	mov    %esp,%ebp
  805790:	57                   	push   %edi
  805791:	56                   	push   %esi
  805792:	53                   	push   %ebx
  805793:	83 ec 1c             	sub    $0x1c,%esp
  805796:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805799:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80579c:	e8 f2 4f 00 00       	call   80a793 <sys_arch_timeouts>

  if (timeouts == NULL) {
  8057a1:	85 c0                	test   %eax,%eax
  8057a3:	75 1c                	jne    8057c1 <sys_untimeout+0x34>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  8057a5:	c7 44 24 08 80 1d 81 	movl   $0x811d80,0x8(%esp)
  8057ac:	00 
  8057ad:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  8057b4:	00 
  8057b5:	c7 04 24 a0 1d 81 00 	movl   $0x811da0,(%esp)
  8057bc:	e8 2b 9a 00 00       	call   80f1ec <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  8057c1:	8b 10                	mov    (%eax),%edx
  8057c3:	85 d2                	test   %edx,%edx
  8057c5:	74 4b                	je     805812 <sys_untimeout+0x85>
  8057c7:	bf 00 00 00 00       	mov    $0x0,%edi
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == h) && (t->arg == arg)) {
  8057cc:	39 5a 08             	cmp    %ebx,0x8(%edx)
  8057cf:	75 33                	jne    805804 <sys_untimeout+0x77>
  8057d1:	39 72 0c             	cmp    %esi,0xc(%edx)
  8057d4:	75 2e                	jne    805804 <sys_untimeout+0x77>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  8057d6:	85 ff                	test   %edi,%edi
  8057d8:	75 08                	jne    8057e2 <sys_untimeout+0x55>
        timeouts->next = t->next;
  8057da:	8b 0a                	mov    (%edx),%ecx
  8057dc:	89 08                	mov    %ecx,(%eax)
  8057de:	66 90                	xchg   %ax,%ax
  8057e0:	eb 04                	jmp    8057e6 <sys_untimeout+0x59>
      else
        prev_t->next = t->next;
  8057e2:	8b 02                	mov    (%edx),%eax
  8057e4:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  8057e6:	8b 02                	mov    (%edx),%eax
  8057e8:	85 c0                	test   %eax,%eax
  8057ea:	74 06                	je     8057f2 <sys_untimeout+0x65>
        t->next->time += t->time;
  8057ec:	8b 4a 04             	mov    0x4(%edx),%ecx
  8057ef:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  8057f2:	89 54 24 04          	mov    %edx,0x4(%esp)
  8057f6:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8057fd:	e8 c2 f2 ff ff       	call   804ac4 <memp_free>
      return;
  805802:	eb 0e                	jmp    805812 <sys_untimeout+0x85>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805804:	8b 0a                	mov    (%edx),%ecx
  805806:	85 c9                	test   %ecx,%ecx
  805808:	74 08                	je     805812 <sys_untimeout+0x85>
  80580a:	89 d7                	mov    %edx,%edi
  80580c:	89 ca                	mov    %ecx,%edx
  80580e:	66 90                	xchg   %ax,%ax
  805810:	eb ba                	jmp    8057cc <sys_untimeout+0x3f>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  805812:	83 c4 1c             	add    $0x1c,%esp
  805815:	5b                   	pop    %ebx
  805816:	5e                   	pop    %esi
  805817:	5f                   	pop    %edi
  805818:	5d                   	pop    %ebp
  805819:	c3                   	ret    

0080581a <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80581a:	55                   	push   %ebp
  80581b:	89 e5                	mov    %esp,%ebp
  80581d:	56                   	push   %esi
  80581e:	53                   	push   %ebx
  80581f:	83 ec 10             	sub    $0x10,%esp
  805822:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  805825:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  80582c:	e8 d7 f2 ff ff       	call   804b08 <memp_malloc>
  805831:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  805833:	85 c0                	test   %eax,%eax
  805835:	75 1c                	jne    805853 <sys_timeout+0x39>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  805837:	c7 44 24 08 b4 1d 81 	movl   $0x811db4,0x8(%esp)
  80583e:	00 
  80583f:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
  805846:	00 
  805847:	c7 04 24 a0 1d 81 00 	movl   $0x811da0,(%esp)
  80584e:	e8 99 99 00 00       	call   80f1ec <_panic>
    return;
  }
  timeout->next = NULL;
  805853:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  805859:	8b 45 0c             	mov    0xc(%ebp),%eax
  80585c:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  80585f:	8b 45 10             	mov    0x10(%ebp),%eax
  805862:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  805865:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  805868:	e8 26 4f 00 00       	call   80a793 <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  80586d:	85 c0                	test   %eax,%eax
  80586f:	75 1c                	jne    80588d <sys_timeout+0x73>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  805871:	c7 44 24 08 d1 1d 81 	movl   $0x811dd1,0x8(%esp)
  805878:	00 
  805879:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
  805880:	00 
  805881:	c7 04 24 a0 1d 81 00 	movl   $0x811da0,(%esp)
  805888:	e8 5f 99 00 00       	call   80f1ec <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  80588d:	8b 10                	mov    (%eax),%edx
  80588f:	85 d2                	test   %edx,%edx
  805891:	75 04                	jne    805897 <sys_timeout+0x7d>
    timeouts->next = timeout;
  805893:	89 18                	mov    %ebx,(%eax)
    return;
  805895:	eb 3b                	jmp    8058d2 <sys_timeout+0xb8>
  }

  if (timeouts->next->time > msecs) {
  805897:	8b 4a 04             	mov    0x4(%edx),%ecx
  80589a:	39 ce                	cmp    %ecx,%esi
  80589c:	73 0f                	jae    8058ad <sys_timeout+0x93>
    timeouts->next->time -= msecs;
  80589e:	29 f1                	sub    %esi,%ecx
  8058a0:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  8058a3:	8b 10                	mov    (%eax),%edx
  8058a5:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  8058a7:	89 18                	mov    %ebx,(%eax)
  8058a9:	eb 27                	jmp    8058d2 <sys_timeout+0xb8>
  8058ab:	89 c2                	mov    %eax,%edx
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  8058ad:	8b 4b 04             	mov    0x4(%ebx),%ecx
  8058b0:	2b 4a 04             	sub    0x4(%edx),%ecx
  8058b3:	89 4b 04             	mov    %ecx,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  8058b6:	8b 02                	mov    (%edx),%eax
  8058b8:	85 c0                	test   %eax,%eax
  8058ba:	74 07                	je     8058c3 <sys_timeout+0xa9>
  8058bc:	3b 48 04             	cmp    0x4(%eax),%ecx
  8058bf:	73 ea                	jae    8058ab <sys_timeout+0x91>
  8058c1:	eb 08                	jmp    8058cb <sys_timeout+0xb1>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
        }
        timeout->next = t->next;
  8058c3:	8b 02                	mov    (%edx),%eax
  8058c5:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  8058c7:	89 1a                	mov    %ebx,(%edx)
  8058c9:	eb 07                	jmp    8058d2 <sys_timeout+0xb8>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  8058cb:	29 48 04             	sub    %ecx,0x4(%eax)
  8058ce:	66 90                	xchg   %ax,%ax
  8058d0:	eb f1                	jmp    8058c3 <sys_timeout+0xa9>
        t->next = timeout;
        break;
      }
    }
  }
}
  8058d2:	83 c4 10             	add    $0x10,%esp
  8058d5:	5b                   	pop    %ebx
  8058d6:	5e                   	pop    %esi
  8058d7:	5d                   	pop    %ebp
  8058d8:	c3                   	ret    

008058d9 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  8058d9:	55                   	push   %ebp
  8058da:	89 e5                	mov    %esp,%ebp
  8058dc:	57                   	push   %edi
  8058dd:	56                   	push   %esi
  8058de:	53                   	push   %ebx
  8058df:	83 ec 1c             	sub    $0x1c,%esp
  8058e2:	8b 7d 08             	mov    0x8(%ebp),%edi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  8058e5:	e8 a9 4e 00 00       	call   80a793 <sys_arch_timeouts>
  8058ea:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  8058ec:	85 c0                	test   %eax,%eax
  8058ee:	74 06                	je     8058f6 <sys_sem_wait+0x1d>
  8058f0:	8b 00                	mov    (%eax),%eax
  8058f2:	85 c0                	test   %eax,%eax
  8058f4:	75 12                	jne    805908 <sys_sem_wait+0x2f>
    sys_arch_sem_wait(sem, 0);
  8058f6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8058fd:	00 
  8058fe:	89 3c 24             	mov    %edi,(%esp)
  805901:	e8 a7 50 00 00       	call   80a9ad <sys_arch_sem_wait>

 again:

  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
  805906:	eb 56                	jmp    80595e <sys_sem_wait+0x85>
    sys_arch_sem_wait(sem, 0);
  } else {
    if (timeouts->next->time > 0) {
  805908:	8b 40 04             	mov    0x4(%eax),%eax
  80590b:	85 c0                	test   %eax,%eax
  80590d:	74 11                	je     805920 <sys_sem_wait+0x47>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80590f:	89 44 24 04          	mov    %eax,0x4(%esp)
  805913:	89 3c 24             	mov    %edi,(%esp)
  805916:	e8 92 50 00 00       	call   80a9ad <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80591b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80591e:	75 27                	jne    805947 <sys_sem_wait+0x6e>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  805920:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805922:	8b 10                	mov    (%eax),%edx
  805924:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  805926:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805929:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80592c:	89 44 24 04          	mov    %eax,0x4(%esp)
  805930:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  805937:	e8 88 f1 ff ff       	call   804ac4 <memp_free>
      if (h != NULL) {
  80593c:	85 db                	test   %ebx,%ebx
  80593e:	74 a5                	je     8058e5 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  805940:	89 34 24             	mov    %esi,(%esp)
  805943:	ff d3                	call   *%ebx
  805945:	eb 9e                	jmp    8058e5 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805947:	8b 13                	mov    (%ebx),%edx
  805949:	8b 4a 04             	mov    0x4(%edx),%ecx
  80594c:	39 c8                	cmp    %ecx,%eax
  80594e:	73 07                	jae    805957 <sys_sem_wait+0x7e>
        timeouts->next->time -= time_needed;
  805950:	29 c1                	sub    %eax,%ecx
  805952:	89 4a 04             	mov    %ecx,0x4(%edx)
  805955:	eb 07                	jmp    80595e <sys_sem_wait+0x85>
      } else {
        timeouts->next->time = 0;
  805957:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  80595e:	83 c4 1c             	add    $0x1c,%esp
  805961:	5b                   	pop    %ebx
  805962:	5e                   	pop    %esi
  805963:	5f                   	pop    %edi
  805964:	5d                   	pop    %ebp
  805965:	c3                   	ret    

00805966 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  805966:	55                   	push   %ebp
  805967:	89 e5                	mov    %esp,%ebp
  805969:	83 ec 28             	sub    $0x28,%esp
  80596c:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80596f:	8d 55 08             	lea    0x8(%ebp),%edx
  805972:	89 55 f4             	mov    %edx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  805975:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80597b:	85 c0                	test   %eax,%eax
  80597d:	74 17                	je     805996 <sys_sem_wait_timeout+0x30>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  80597f:	8d 55 f0             	lea    -0x10(%ebp),%edx
  805982:	89 54 24 08          	mov    %edx,0x8(%esp)
  805986:	c7 44 24 04 70 57 80 	movl   $0x805770,0x4(%esp)
  80598d:	00 
  80598e:	89 04 24             	mov    %eax,(%esp)
  805991:	e8 84 fe ff ff       	call   80581a <sys_timeout>
  }
  sys_sem_wait(sem);
  805996:	8b 45 08             	mov    0x8(%ebp),%eax
  805999:	89 04 24             	mov    %eax,(%esp)
  80599c:	e8 38 ff ff ff       	call   8058d9 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8059a1:	b8 00 00 00 00       	mov    $0x0,%eax
  8059a6:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  8059ab:	75 18                	jne    8059c5 <sys_sem_wait_timeout+0x5f>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  8059ad:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8059b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8059b4:	c7 04 24 70 57 80 00 	movl   $0x805770,(%esp)
  8059bb:	e8 cd fd ff ff       	call   80578d <sys_untimeout>
  8059c0:	b8 01 00 00 00       	mov    $0x1,%eax
    return 1;
  }
}
  8059c5:	c9                   	leave  
  8059c6:	c3                   	ret    

008059c7 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  8059c7:	55                   	push   %ebp
  8059c8:	89 e5                	mov    %esp,%ebp
  8059ca:	53                   	push   %ebx
  8059cb:	83 ec 14             	sub    $0x14,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  8059ce:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8059d5:	e8 f5 50 00 00       	call   80aacf <sys_sem_new>
  8059da:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  8059dc:	8b 45 08             	mov    0x8(%ebp),%eax
  8059df:	89 44 24 04          	mov    %eax,0x4(%esp)
  8059e3:	89 1c 24             	mov    %ebx,(%esp)
  8059e6:	e8 7b ff ff ff       	call   805966 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  8059eb:	89 1c 24             	mov    %ebx,(%esp)
  8059ee:	e8 76 4c 00 00       	call   80a669 <sys_sem_free>
}
  8059f3:	83 c4 14             	add    $0x14,%esp
  8059f6:	5b                   	pop    %ebx
  8059f7:	5d                   	pop    %ebp
  8059f8:	c3                   	ret    

008059f9 <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  8059f9:	55                   	push   %ebp
  8059fa:	89 e5                	mov    %esp,%ebp
  8059fc:	57                   	push   %edi
  8059fd:	56                   	push   %esi
  8059fe:	53                   	push   %ebx
  8059ff:	83 ec 1c             	sub    $0x1c,%esp
  805a02:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  805a05:	e8 89 4d 00 00       	call   80a793 <sys_arch_timeouts>
  805a0a:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  805a0c:	85 c0                	test   %eax,%eax
  805a0e:	74 06                	je     805a16 <sys_mbox_fetch+0x1d>
  805a10:	8b 00                	mov    (%eax),%eax
  805a12:	85 c0                	test   %eax,%eax
  805a14:	75 19                	jne    805a2f <sys_mbox_fetch+0x36>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  805a16:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805a1d:	00 
  805a1e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  805a22:	8b 45 08             	mov    0x8(%ebp),%eax
  805a25:	89 04 24             	mov    %eax,(%esp)
  805a28:	e8 bb 52 00 00       	call   80ace8 <sys_arch_mbox_fetch>
  void *arg;

 again:
  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
  805a2d:	eb 5d                	jmp    805a8c <sys_mbox_fetch+0x93>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  805a2f:	8b 40 04             	mov    0x4(%eax),%eax
  805a32:	85 c0                	test   %eax,%eax
  805a34:	74 18                	je     805a4e <sys_mbox_fetch+0x55>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  805a36:	89 44 24 08          	mov    %eax,0x8(%esp)
  805a3a:	89 7c 24 04          	mov    %edi,0x4(%esp)
  805a3e:	8b 45 08             	mov    0x8(%ebp),%eax
  805a41:	89 04 24             	mov    %eax,(%esp)
  805a44:	e8 9f 52 00 00       	call   80ace8 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  805a49:	83 f8 ff             	cmp    $0xffffffff,%eax
  805a4c:	75 27                	jne    805a75 <sys_mbox_fetch+0x7c>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  805a4e:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805a50:	8b 10                	mov    (%eax),%edx
  805a52:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  805a54:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805a57:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805a5a:	89 44 24 04          	mov    %eax,0x4(%esp)
  805a5e:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  805a65:	e8 5a f0 ff ff       	call   804ac4 <memp_free>
      if (h != NULL) {
  805a6a:	85 db                	test   %ebx,%ebx
  805a6c:	74 97                	je     805a05 <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  805a6e:	89 34 24             	mov    %esi,(%esp)
  805a71:	ff d3                	call   *%ebx
  805a73:	eb 90                	jmp    805a05 <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805a75:	8b 13                	mov    (%ebx),%edx
  805a77:	8b 4a 04             	mov    0x4(%edx),%ecx
  805a7a:	39 c8                	cmp    %ecx,%eax
  805a7c:	73 07                	jae    805a85 <sys_mbox_fetch+0x8c>
        timeouts->next->time -= time_needed;
  805a7e:	29 c1                	sub    %eax,%ecx
  805a80:	89 4a 04             	mov    %ecx,0x4(%edx)
  805a83:	eb 07                	jmp    805a8c <sys_mbox_fetch+0x93>
      } else {
        timeouts->next->time = 0;
  805a85:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  805a8c:	83 c4 1c             	add    $0x1c,%esp
  805a8f:	5b                   	pop    %ebx
  805a90:	5e                   	pop    %esi
  805a91:	5f                   	pop    %edi
  805a92:	5d                   	pop    %ebp
  805a93:	c3                   	ret    
	...

00805aa0 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  805aa0:	55                   	push   %ebp
  805aa1:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805aa3:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  805aa8:	5d                   	pop    %ebp
  805aa9:	c3                   	ret    

00805aaa <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  805aaa:	55                   	push   %ebp
  805aab:	89 e5                	mov    %esp,%ebp
  805aad:	57                   	push   %edi
  805aae:	56                   	push   %esi
  805aaf:	53                   	push   %ebx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805ab0:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805ab6:	8b 3d 44 b2 b3 00    	mov    0xb3b244,%edi
  805abc:	0f b7 05 0c 40 81 00 	movzwl 0x81400c,%eax
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  805ac3:	bb 00 10 00 00       	mov    $0x1000,%ebx
  805ac8:	8b 0d 3c b2 b3 00    	mov    0xb3b23c,%ecx
  805ace:	66 83 c0 01          	add    $0x1,%ax
  805ad2:	0f 48 c3             	cmovs  %ebx,%eax
  805ad5:	89 ca                	mov    %ecx,%edx
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805ad7:	eb 09                	jmp    805ae2 <tcp_new_port+0x38>
    if (pcb->local_port == port) {
  805ad9:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805add:	74 ef                	je     805ace <tcp_new_port+0x24>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805adf:	8b 52 0c             	mov    0xc(%edx),%edx
  805ae2:	85 d2                	test   %edx,%edx
  805ae4:	75 f3                	jne    805ad9 <tcp_new_port+0x2f>
  805ae6:	89 f2                	mov    %esi,%edx
  805ae8:	eb 09                	jmp    805af3 <tcp_new_port+0x49>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  805aea:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805aee:	74 de                	je     805ace <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805af0:	8b 52 0c             	mov    0xc(%edx),%edx
  805af3:	85 d2                	test   %edx,%edx
  805af5:	75 f3                	jne    805aea <tcp_new_port+0x40>
  805af7:	89 fa                	mov    %edi,%edx
  805af9:	eb 09                	jmp    805b04 <tcp_new_port+0x5a>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  805afb:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805aff:	74 cd                	je     805ace <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805b01:	8b 52 0c             	mov    0xc(%edx),%edx
  805b04:	85 d2                	test   %edx,%edx
  805b06:	75 f3                	jne    805afb <tcp_new_port+0x51>
  805b08:	66 a3 0c 40 81 00    	mov    %ax,0x81400c
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  805b0e:	5b                   	pop    %ebx
  805b0f:	5e                   	pop    %esi
  805b10:	5f                   	pop    %edi
  805b11:	5d                   	pop    %ebp
  805b12:	c3                   	ret    

00805b13 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  805b13:	55                   	push   %ebp
  805b14:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  805b16:	8b 55 0c             	mov    0xc(%ebp),%edx
  805b19:	8b 45 08             	mov    0x8(%ebp),%eax
  805b1c:	88 50 14             	mov    %dl,0x14(%eax)
}
  805b1f:	5d                   	pop    %ebp
  805b20:	c3                   	ret    

00805b21 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805b21:	55                   	push   %ebp
  805b22:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  805b24:	8b 55 0c             	mov    0xc(%ebp),%edx
  805b27:	8b 45 08             	mov    0x8(%ebp),%eax
  805b2a:	89 50 18             	mov    %edx,0x18(%eax)
}
  805b2d:	5d                   	pop    %ebp
  805b2e:	c3                   	ret    

00805b2f <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805b2f:	55                   	push   %ebp
  805b30:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  805b32:	8b 55 0c             	mov    0xc(%ebp),%edx
  805b35:	8b 45 08             	mov    0x8(%ebp),%eax
  805b38:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805b3e:	5d                   	pop    %ebp
  805b3f:	c3                   	ret    

00805b40 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805b40:	55                   	push   %ebp
  805b41:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805b43:	8b 55 0c             	mov    0xc(%ebp),%edx
  805b46:	8b 45 08             	mov    0x8(%ebp),%eax
  805b49:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805b4f:	5d                   	pop    %ebp
  805b50:	c3                   	ret    

00805b51 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805b51:	55                   	push   %ebp
  805b52:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805b54:	8b 55 0c             	mov    0xc(%ebp),%edx
  805b57:	8b 45 08             	mov    0x8(%ebp),%eax
  805b5a:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805b60:	5d                   	pop    %ebp
  805b61:	c3                   	ret    

00805b62 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805b62:	55                   	push   %ebp
  805b63:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805b65:	8b 55 0c             	mov    0xc(%ebp),%edx
  805b68:	8b 45 08             	mov    0x8(%ebp),%eax
  805b6b:	89 50 20             	mov    %edx,0x20(%eax)
}
  805b6e:	5d                   	pop    %ebp
  805b6f:	c3                   	ret    

00805b70 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805b70:	55                   	push   %ebp
  805b71:	89 e5                	mov    %esp,%ebp
  805b73:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805b76:	8b 55 0c             	mov    0xc(%ebp),%edx
  805b79:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805b7f:	8b 55 10             	mov    0x10(%ebp),%edx
  805b82:	88 50 31             	mov    %dl,0x31(%eax)
}
  805b85:	5d                   	pop    %ebp
  805b86:	c3                   	ret    

00805b87 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  805b87:	55                   	push   %ebp
  805b88:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  805b8a:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805b8f:	03 05 08 40 81 00    	add    0x814008,%eax
  805b95:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  805b9a:	5d                   	pop    %ebp
  805b9b:	c3                   	ret    

00805b9c <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  805b9c:	55                   	push   %ebp
  805b9d:	89 e5                	mov    %esp,%ebp
  805b9f:	53                   	push   %ebx
  805ba0:	83 ec 14             	sub    $0x14,%esp
  805ba3:	0f b7 5d 08          	movzwl 0x8(%ebp),%ebx
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  805ba7:	8b 45 0c             	mov    0xc(%ebp),%eax
  805baa:	89 04 24             	mov    %eax,(%esp)
  805bad:	e8 8f 11 00 00       	call   806d41 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  805bb2:	85 c0                	test   %eax,%eax
  805bb4:	74 12                	je     805bc8 <tcp_eff_send_mss+0x2c>
  805bb6:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  805bba:	66 85 c0             	test   %ax,%ax
  805bbd:	74 09                	je     805bc8 <tcp_eff_send_mss+0x2c>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  805bbf:	83 e8 28             	sub    $0x28,%eax
  805bc2:	66 39 c3             	cmp    %ax,%bx
  805bc5:	0f 47 d8             	cmova  %eax,%ebx
  }
  return sendmss;
}
  805bc8:	89 d8                	mov    %ebx,%eax
  805bca:	83 c4 14             	add    $0x14,%esp
  805bcd:	5b                   	pop    %ebx
  805bce:	5d                   	pop    %ebp
  805bcf:	c3                   	ret    

00805bd0 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  805bd0:	55                   	push   %ebp
  805bd1:	89 e5                	mov    %esp,%ebp
  805bd3:	83 ec 18             	sub    $0x18,%esp
  805bd6:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  805bd9:	89 75 fc             	mov    %esi,-0x4(%ebp)
  805bdc:	8b 45 08             	mov    0x8(%ebp),%eax
  805bdf:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805be3:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  805be7:	0f b7 f1             	movzwl %cx,%esi
  805bea:	0f b7 da             	movzwl %dx,%ebx
  805bed:	8d 1c 1e             	lea    (%esi,%ebx,1),%ebx
  805bf0:	81 fb c0 5d 00 00    	cmp    $0x5dc0,%ebx
  805bf6:	76 0e                	jbe    805c06 <tcp_recved+0x36>
    pcb->rcv_wnd = TCP_WND;
  805bf8:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  805bfe:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  805c04:	eb 11                	jmp    805c17 <tcp_recved+0x47>
  } else {
    pcb->rcv_wnd += len;
  805c06:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  805c09:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805c0d:	66 3b 50 34          	cmp    0x34(%eax),%dx
  805c11:	72 04                	jb     805c17 <tcp_recved+0x47>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  805c13:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  805c17:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  805c1b:	f6 c2 03             	test   $0x3,%dl
  805c1e:	75 20                	jne    805c40 <tcp_recved+0x70>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  805c20:	f6 c2 01             	test   $0x1,%dl
  805c23:	74 13                	je     805c38 <tcp_recved+0x68>
  805c25:	83 e2 fe             	and    $0xfffffffe,%edx
  805c28:	83 ca 02             	or     $0x2,%edx
  805c2b:	88 50 20             	mov    %dl,0x20(%eax)
  805c2e:	89 04 24             	mov    %eax,(%esp)
  805c31:	e8 95 28 00 00       	call   8084cb <tcp_output>
  805c36:	eb 23                	jmp    805c5b <tcp_recved+0x8b>
  805c38:	83 ca 01             	or     $0x1,%edx
  805c3b:	88 50 20             	mov    %dl,0x20(%eax)
  805c3e:	eb 1b                	jmp    805c5b <tcp_recved+0x8b>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  805c40:	f6 c2 01             	test   $0x1,%dl
  805c43:	74 16                	je     805c5b <tcp_recved+0x8b>
  805c45:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  805c4b:	76 0e                	jbe    805c5b <tcp_recved+0x8b>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  805c4d:	83 ca 02             	or     $0x2,%edx
  805c50:	88 50 20             	mov    %dl,0x20(%eax)
  805c53:	89 04 24             	mov    %eax,(%esp)
  805c56:	e8 70 28 00 00       	call   8084cb <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  805c5b:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  805c5e:	8b 75 fc             	mov    -0x4(%ebp),%esi
  805c61:	89 ec                	mov    %ebp,%esp
  805c63:	5d                   	pop    %ebp
  805c64:	c3                   	ret    

00805c65 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  805c65:	55                   	push   %ebp
  805c66:	89 e5                	mov    %esp,%ebp
  805c68:	53                   	push   %ebx
  805c69:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805c6c:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  805c72:	eb 61                	jmp    805cd5 <tcp_fasttmr+0x70>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  805c74:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805c7a:	85 c0                	test   %eax,%eax
  805c7c:	74 3a                	je     805cb8 <tcp_fasttmr+0x53>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805c7e:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  805c84:	85 d2                	test   %edx,%edx
  805c86:	74 1e                	je     805ca6 <tcp_fasttmr+0x41>
  805c88:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  805c8f:	00 
  805c90:	89 44 24 08          	mov    %eax,0x8(%esp)
  805c94:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805c98:	8b 43 18             	mov    0x18(%ebx),%eax
  805c9b:	89 04 24             	mov    %eax,(%esp)
  805c9e:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805ca0:	84 c0                	test   %al,%al
  805ca2:	75 14                	jne    805cb8 <tcp_fasttmr+0x53>
  805ca4:	eb 08                	jmp    805cae <tcp_fasttmr+0x49>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805ca6:	89 04 24             	mov    %eax,(%esp)
  805ca9:	e8 76 f5 ff ff       	call   805224 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  805cae:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805cb5:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  805cb8:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  805cbc:	a8 01                	test   $0x1,%al
  805cbe:	74 12                	je     805cd2 <tcp_fasttmr+0x6d>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805cc0:	83 c8 02             	or     $0x2,%eax
  805cc3:	88 43 20             	mov    %al,0x20(%ebx)
  805cc6:	89 1c 24             	mov    %ebx,(%esp)
  805cc9:	e8 fd 27 00 00       	call   8084cb <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805cce:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805cd2:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  805cd5:	85 db                	test   %ebx,%ebx
  805cd7:	75 9b                	jne    805c74 <tcp_fasttmr+0xf>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  805cd9:	83 c4 14             	add    $0x14,%esp
  805cdc:	5b                   	pop    %ebx
  805cdd:	5d                   	pop    %ebp
  805cde:	c3                   	ret    

00805cdf <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  805cdf:	55                   	push   %ebp
  805ce0:	89 e5                	mov    %esp,%ebp
  805ce2:	53                   	push   %ebx
  805ce3:	83 ec 14             	sub    $0x14,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  805ce6:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  805ced:	e8 16 ee ff ff       	call   804b08 <memp_malloc>
  805cf2:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  805cf4:	85 c0                	test   %eax,%eax
  805cf6:	74 22                	je     805d1a <tcp_seg_copy+0x3b>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805cf8:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  805cff:	00 
  805d00:	8b 45 08             	mov    0x8(%ebp),%eax
  805d03:	89 44 24 04          	mov    %eax,0x4(%esp)
  805d07:	89 1c 24             	mov    %ebx,(%esp)
  805d0a:	e8 1c 9e 00 00       	call   80fb2b <memcpy>
  pbuf_ref(cseg->p);
  805d0f:	8b 43 04             	mov    0x4(%ebx),%eax
  805d12:	89 04 24             	mov    %eax,(%esp)
  805d15:	e8 de f0 ff ff       	call   804df8 <pbuf_ref>
  return cseg;
}
  805d1a:	89 d8                	mov    %ebx,%eax
  805d1c:	83 c4 14             	add    $0x14,%esp
  805d1f:	5b                   	pop    %ebx
  805d20:	5d                   	pop    %ebp
  805d21:	c3                   	ret    

00805d22 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  805d22:	55                   	push   %ebp
  805d23:	89 e5                	mov    %esp,%ebp
  805d25:	83 ec 18             	sub    $0x18,%esp
  805d28:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  805d2b:	89 75 fc             	mov    %esi,-0x4(%ebp)
  805d2e:	8b 75 08             	mov    0x8(%ebp),%esi
  u8_t count = 0;
  
  if (seg != NULL) {
  805d31:	bb 00 00 00 00       	mov    $0x0,%ebx
  805d36:	85 f6                	test   %esi,%esi
  805d38:	74 21                	je     805d5b <tcp_seg_free+0x39>
    if (seg->p != NULL) {
  805d3a:	8b 46 04             	mov    0x4(%esi),%eax
  805d3d:	85 c0                	test   %eax,%eax
  805d3f:	74 0a                	je     805d4b <tcp_seg_free+0x29>
      count = pbuf_free(seg->p);
  805d41:	89 04 24             	mov    %eax,(%esp)
  805d44:	e8 db f4 ff ff       	call   805224 <pbuf_free>
  805d49:	89 c3                	mov    %eax,%ebx
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805d4b:	89 74 24 04          	mov    %esi,0x4(%esp)
  805d4f:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  805d56:	e8 69 ed ff ff       	call   804ac4 <memp_free>
  }
  return count;
}
  805d5b:	89 d8                	mov    %ebx,%eax
  805d5d:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  805d60:	8b 75 fc             	mov    -0x4(%ebp),%esi
  805d63:	89 ec                	mov    %ebp,%esp
  805d65:	5d                   	pop    %ebp
  805d66:	c3                   	ret    

00805d67 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  805d67:	55                   	push   %ebp
  805d68:	89 e5                	mov    %esp,%ebp
  805d6a:	56                   	push   %esi
  805d6b:	53                   	push   %ebx
  805d6c:	83 ec 10             	sub    $0x10,%esp
  805d6f:	8b 45 08             	mov    0x8(%ebp),%eax
  805d72:	be 00 00 00 00       	mov    $0x0,%esi
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  805d77:	eb 0e                	jmp    805d87 <tcp_segs_free+0x20>
    next = seg->next;
  805d79:	8b 18                	mov    (%eax),%ebx
    count += tcp_seg_free(seg);
  805d7b:	89 04 24             	mov    %eax,(%esp)
  805d7e:	e8 9f ff ff ff       	call   805d22 <tcp_seg_free>
  805d83:	01 c6                	add    %eax,%esi
  805d85:	89 d8                	mov    %ebx,%eax
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  805d87:	85 c0                	test   %eax,%eax
  805d89:	75 ee                	jne    805d79 <tcp_segs_free+0x12>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  805d8b:	89 f0                	mov    %esi,%eax
  805d8d:	83 c4 10             	add    $0x10,%esp
  805d90:	5b                   	pop    %ebx
  805d91:	5e                   	pop    %esi
  805d92:	5d                   	pop    %ebp
  805d93:	c3                   	ret    

00805d94 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805d94:	55                   	push   %ebp
  805d95:	89 e5                	mov    %esp,%ebp
  805d97:	53                   	push   %ebx
  805d98:	83 ec 14             	sub    $0x14,%esp
  805d9b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
  805d9e:	8b 43 10             	mov    0x10(%ebx),%eax
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
  805da1:	85 c0                	test   %eax,%eax
  805da3:	74 62                	je     805e07 <tcp_pcb_purge+0x73>
  805da5:	83 f8 0a             	cmp    $0xa,%eax
  805da8:	74 5d                	je     805e07 <tcp_pcb_purge+0x73>
  805daa:	83 f8 01             	cmp    $0x1,%eax
  805dad:	74 58                	je     805e07 <tcp_pcb_purge+0x73>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  805daf:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805db5:	85 c0                	test   %eax,%eax
  805db7:	74 12                	je     805dcb <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  805db9:	89 04 24             	mov    %eax,(%esp)
  805dbc:	e8 63 f4 ff ff       	call   805224 <pbuf_free>
      pcb->refused_data = NULL;
  805dc1:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805dc8:	00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  805dcb:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  805dd1:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805dd4:	89 04 24             	mov    %eax,(%esp)
  805dd7:	e8 8b ff ff ff       	call   805d67 <tcp_segs_free>
    pcb->ooseq = NULL;
  805ddc:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  805de3:	8b 43 74             	mov    0x74(%ebx),%eax
  805de6:	89 04 24             	mov    %eax,(%esp)
  805de9:	e8 79 ff ff ff       	call   805d67 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805dee:	8b 43 78             	mov    0x78(%ebx),%eax
  805df1:	89 04 24             	mov    %eax,(%esp)
  805df4:	e8 6e ff ff ff       	call   805d67 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805df9:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  805e00:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  }
}
  805e07:	83 c4 14             	add    $0x14,%esp
  805e0a:	5b                   	pop    %ebx
  805e0b:	5d                   	pop    %ebp
  805e0c:	c3                   	ret    

00805e0d <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805e0d:	55                   	push   %ebp
  805e0e:	89 e5                	mov    %esp,%ebp
  805e10:	53                   	push   %ebx
  805e11:	83 ec 14             	sub    $0x14,%esp
  805e14:	8b 55 08             	mov    0x8(%ebp),%edx
  805e17:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  805e1a:	8b 02                	mov    (%edx),%eax
  805e1c:	39 d8                	cmp    %ebx,%eax
  805e1e:	75 07                	jne    805e27 <tcp_pcb_remove+0x1a>
  805e20:	8b 40 0c             	mov    0xc(%eax),%eax
  805e23:	89 02                	mov    %eax,(%edx)
  805e25:	eb 29                	jmp    805e50 <tcp_pcb_remove+0x43>
  805e27:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  805e2c:	eb 18                	jmp    805e46 <tcp_pcb_remove+0x39>
  805e2e:	8b 42 0c             	mov    0xc(%edx),%eax
  805e31:	85 c0                	test   %eax,%eax
  805e33:	74 0c                	je     805e41 <tcp_pcb_remove+0x34>
  805e35:	39 c3                	cmp    %eax,%ebx
  805e37:	75 08                	jne    805e41 <tcp_pcb_remove+0x34>
  805e39:	8b 43 0c             	mov    0xc(%ebx),%eax
  805e3c:	89 42 0c             	mov    %eax,0xc(%edx)
  805e3f:	eb 0f                	jmp    805e50 <tcp_pcb_remove+0x43>
  805e41:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  805e46:	8b 15 48 b2 b3 00    	mov    0xb3b248,%edx
  805e4c:	85 d2                	test   %edx,%edx
  805e4e:	75 de                	jne    805e2e <tcp_pcb_remove+0x21>
  805e50:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  805e57:	89 1c 24             	mov    %ebx,(%esp)
  805e5a:	e8 35 ff ff ff       	call   805d94 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  805e5f:	8b 43 10             	mov    0x10(%ebx),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805e62:	83 f8 0a             	cmp    $0xa,%eax
  805e65:	74 1b                	je     805e82 <tcp_pcb_remove+0x75>
  805e67:	83 f8 01             	cmp    $0x1,%eax
  805e6a:	74 16                	je     805e82 <tcp_pcb_remove+0x75>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  805e6c:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805e70:	a8 01                	test   $0x1,%al
  805e72:	74 0e                	je     805e82 <tcp_pcb_remove+0x75>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  805e74:	83 c8 02             	or     $0x2,%eax
  805e77:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805e7a:	89 1c 24             	mov    %ebx,(%esp)
  805e7d:	e8 49 26 00 00       	call   8084cb <tcp_output>
  }

  if (pcb->state != LISTEN) {
  805e82:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  805e86:	74 66                	je     805eee <tcp_pcb_remove+0xe1>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805e88:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  805e8c:	74 1c                	je     805eaa <tcp_pcb_remove+0x9d>
  805e8e:	c7 44 24 08 ef 1d 81 	movl   $0x811def,0x8(%esp)
  805e95:	00 
  805e96:	c7 44 24 04 b4 04 00 	movl   $0x4b4,0x4(%esp)
  805e9d:	00 
  805e9e:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  805ea5:	e8 42 93 00 00       	call   80f1ec <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805eaa:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805eae:	74 1c                	je     805ecc <tcp_pcb_remove+0xbf>
  805eb0:	c7 44 24 08 1b 1e 81 	movl   $0x811e1b,0x8(%esp)
  805eb7:	00 
  805eb8:	c7 44 24 04 b5 04 00 	movl   $0x4b5,0x4(%esp)
  805ebf:	00 
  805ec0:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  805ec7:	e8 20 93 00 00       	call   80f1ec <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805ecc:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  805ed0:	74 1c                	je     805eee <tcp_pcb_remove+0xe1>
  805ed2:	c7 44 24 08 34 1e 81 	movl   $0x811e34,0x8(%esp)
  805ed9:	00 
  805eda:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp)
  805ee1:	00 
  805ee2:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  805ee9:	e8 fe 92 00 00       	call   80f1ec <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  805eee:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805ef5:	83 c4 14             	add    $0x14,%esp
  805ef8:	5b                   	pop    %ebx
  805ef9:	5d                   	pop    %ebp
  805efa:	c3                   	ret    

00805efb <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  805efb:	55                   	push   %ebp
  805efc:	89 e5                	mov    %esp,%ebp
  805efe:	83 ec 18             	sub    $0x18,%esp
  805f01:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  805f04:	89 75 fc             	mov    %esi,-0x4(%ebp)
  805f07:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805f0a:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  805f0e:	74 1c                	je     805f2c <tcp_listen_with_backlog+0x31>
  805f10:	c7 44 24 08 4c 1e 81 	movl   $0x811e4c,0x8(%esp)
  805f17:	00 
  805f18:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  805f1f:	00 
  805f20:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  805f27:	e8 c0 92 00 00       	call   80f1ec <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805f2c:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  805f33:	e8 d0 eb ff ff       	call   804b08 <memp_malloc>
  805f38:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805f3a:	b8 00 00 00 00       	mov    $0x0,%eax
  805f3f:	85 f6                	test   %esi,%esi
  805f41:	0f 84 aa 00 00 00    	je     805ff1 <tcp_listen_with_backlog+0xf6>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  805f47:	8b 43 18             	mov    0x18(%ebx),%eax
  805f4a:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805f4d:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805f51:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  805f55:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  805f5c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805f60:	83 c8 02             	or     $0x2,%eax
  805f63:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  805f67:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  805f6b:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  805f6e:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  805f72:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  805f75:	b8 00 00 00 00       	mov    $0x0,%eax
  805f7a:	85 db                	test   %ebx,%ebx
  805f7c:	74 02                	je     805f80 <tcp_listen_with_backlog+0x85>
  805f7e:	8b 03                	mov    (%ebx),%eax
  805f80:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  805f82:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  805f87:	39 d8                	cmp    %ebx,%eax
  805f89:	75 0a                	jne    805f95 <tcp_listen_with_backlog+0x9a>
  805f8b:	8b 40 0c             	mov    0xc(%eax),%eax
  805f8e:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805f93:	eb 29                	jmp    805fbe <tcp_listen_with_backlog+0xc3>
  805f95:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  805f9a:	eb 18                	jmp    805fb4 <tcp_listen_with_backlog+0xb9>
  805f9c:	8b 42 0c             	mov    0xc(%edx),%eax
  805f9f:	85 c0                	test   %eax,%eax
  805fa1:	74 0c                	je     805faf <tcp_listen_with_backlog+0xb4>
  805fa3:	39 c3                	cmp    %eax,%ebx
  805fa5:	75 08                	jne    805faf <tcp_listen_with_backlog+0xb4>
  805fa7:	8b 43 0c             	mov    0xc(%ebx),%eax
  805faa:	89 42 0c             	mov    %eax,0xc(%edx)
  805fad:	eb 0f                	jmp    805fbe <tcp_listen_with_backlog+0xc3>
  805faf:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  805fb4:	8b 15 48 b2 b3 00    	mov    0xb3b248,%edx
  805fba:	85 d2                	test   %edx,%edx
  805fbc:	75 de                	jne    805f9c <tcp_listen_with_backlog+0xa1>
  805fbe:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  805fc5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805fc9:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  805fd0:	e8 ef ea ff ff       	call   804ac4 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  805fd5:	c7 46 20 a0 5a 80 00 	movl   $0x805aa0,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  805fdc:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  805fe1:	89 46 0c             	mov    %eax,0xc(%esi)
  805fe4:	89 35 44 b2 b3 00    	mov    %esi,0xb3b244
  805fea:	e8 8e c3 ff ff       	call   80237d <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  805fef:	89 f0                	mov    %esi,%eax
}
  805ff1:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  805ff4:	8b 75 fc             	mov    -0x4(%ebp),%esi
  805ff7:	89 ec                	mov    %ebp,%esp
  805ff9:	5d                   	pop    %ebp
  805ffa:	c3                   	ret    

00805ffb <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  805ffb:	55                   	push   %ebp
  805ffc:	89 e5                	mov    %esp,%ebp
  805ffe:	57                   	push   %edi
  805fff:	56                   	push   %esi
  806000:	53                   	push   %ebx
  806001:	83 ec 1c             	sub    $0x1c,%esp
  806004:	8b 75 08             	mov    0x8(%ebp),%esi
  806007:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80600a:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80600e:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  806012:	74 1c                	je     806030 <tcp_bind+0x35>
  806014:	c7 44 24 08 70 1e 81 	movl   $0x811e70,0x8(%esp)
  80601b:	00 
  80601c:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
  806023:	00 
  806024:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  80602b:	e8 bc 91 00 00       	call   80f1ec <_panic>

  if (port == 0) {
  806030:	66 85 c0             	test   %ax,%ax
  806033:	75 05                	jne    80603a <tcp_bind+0x3f>
    port = tcp_new_port();
  806035:	e8 70 fa ff ff       	call   805aaa <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80603a:	8b 15 44 b2 b3 00    	mov    0xb3b244,%edx
  806040:	eb 37                	jmp    806079 <tcp_bind+0x7e>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  806042:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  806046:	75 2e                	jne    806076 <tcp_bind+0x7b>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  806048:	85 d2                	test   %edx,%edx
  80604a:	0f 84 df 00 00 00    	je     80612f <tcp_bind+0x134>
  806050:	8b 0a                	mov    (%edx),%ecx
  806052:	85 c9                	test   %ecx,%ecx
  806054:	0f 84 d5 00 00 00    	je     80612f <tcp_bind+0x134>
  80605a:	85 db                	test   %ebx,%ebx
  80605c:	0f 84 cd 00 00 00    	je     80612f <tcp_bind+0x134>
          ip_addr_isany(ipaddr) ||
  806062:	8b 3b                	mov    (%ebx),%edi
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  806064:	85 ff                	test   %edi,%edi
  806066:	0f 84 c3 00 00 00    	je     80612f <tcp_bind+0x134>
  80606c:	39 f9                	cmp    %edi,%ecx
  80606e:	66 90                	xchg   %ax,%ax
  806070:	0f 84 b9 00 00 00    	je     80612f <tcp_bind+0x134>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  806076:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  806079:	85 d2                	test   %edx,%edx
  80607b:	75 c5                	jne    806042 <tcp_bind+0x47>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80607d:	8b 15 3c b2 b3 00    	mov    0xb3b23c,%edx
  806083:	eb 32                	jmp    8060b7 <tcp_bind+0xbc>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  806085:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  806089:	75 29                	jne    8060b4 <tcp_bind+0xb9>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80608b:	85 d2                	test   %edx,%edx
  80608d:	0f 84 9c 00 00 00    	je     80612f <tcp_bind+0x134>
  806093:	8b 0a                	mov    (%edx),%ecx
  806095:	85 c9                	test   %ecx,%ecx
  806097:	0f 84 92 00 00 00    	je     80612f <tcp_bind+0x134>
  80609d:	85 db                	test   %ebx,%ebx
  80609f:	90                   	nop
  8060a0:	0f 84 89 00 00 00    	je     80612f <tcp_bind+0x134>
          ip_addr_isany(ipaddr) ||
  8060a6:	8b 3b                	mov    (%ebx),%edi
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8060a8:	85 ff                	test   %edi,%edi
  8060aa:	0f 84 7f 00 00 00    	je     80612f <tcp_bind+0x134>
  8060b0:	39 f9                	cmp    %edi,%ecx
  8060b2:	74 7b                	je     80612f <tcp_bind+0x134>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  8060b4:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  8060b7:	85 d2                	test   %edx,%edx
  8060b9:	75 ca                	jne    806085 <tcp_bind+0x8a>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8060bb:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8060c1:	eb 22                	jmp    8060e5 <tcp_bind+0xea>
    if (cpcb->local_port == port) {
  8060c3:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8060c7:	75 19                	jne    8060e2 <tcp_bind+0xe7>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8060c9:	85 d2                	test   %edx,%edx
  8060cb:	74 62                	je     80612f <tcp_bind+0x134>
  8060cd:	8b 0a                	mov    (%edx),%ecx
  8060cf:	85 c9                	test   %ecx,%ecx
  8060d1:	74 5c                	je     80612f <tcp_bind+0x134>
  8060d3:	85 db                	test   %ebx,%ebx
  8060d5:	74 58                	je     80612f <tcp_bind+0x134>
          ip_addr_isany(ipaddr) ||
  8060d7:	8b 3b                	mov    (%ebx),%edi
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8060d9:	85 ff                	test   %edi,%edi
  8060db:	74 52                	je     80612f <tcp_bind+0x134>
  8060dd:	39 f9                	cmp    %edi,%ecx
  8060df:	90                   	nop
  8060e0:	74 4d                	je     80612f <tcp_bind+0x134>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8060e2:	8b 52 0c             	mov    0xc(%edx),%edx
  8060e5:	85 d2                	test   %edx,%edx
  8060e7:	75 da                	jne    8060c3 <tcp_bind+0xc8>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8060e9:	8b 15 50 b2 b3 00    	mov    0xb3b250,%edx
  8060ef:	eb 0f                	jmp    806100 <tcp_bind+0x105>
    if (cpcb->local_port == port) {
  8060f1:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8060f5:	75 06                	jne    8060fd <tcp_bind+0x102>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  8060f7:	8b 0a                	mov    (%edx),%ecx
  8060f9:	3b 0b                	cmp    (%ebx),%ecx
  8060fb:	74 32                	je     80612f <tcp_bind+0x134>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8060fd:	8b 52 0c             	mov    0xc(%edx),%edx
  806100:	85 d2                	test   %edx,%edx
  806102:	75 ed                	jne    8060f1 <tcp_bind+0xf6>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  806104:	85 db                	test   %ebx,%ebx
  806106:	74 09                	je     806111 <tcp_bind+0x116>
  806108:	83 3b 00             	cmpl   $0x0,(%ebx)
  80610b:	74 04                	je     806111 <tcp_bind+0x116>
    pcb->local_ip = *ipaddr;
  80610d:	8b 13                	mov    (%ebx),%edx
  80610f:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  806111:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  806115:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  80611a:	89 46 0c             	mov    %eax,0xc(%esi)
  80611d:	89 35 4c b2 b3 00    	mov    %esi,0xb3b24c
  806123:	e8 55 c2 ff ff       	call   80237d <tcp_timer_needed>
  806128:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  80612d:	eb 05                	jmp    806134 <tcp_bind+0x139>
  80612f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  806134:	83 c4 1c             	add    $0x1c,%esp
  806137:	5b                   	pop    %ebx
  806138:	5e                   	pop    %esi
  806139:	5f                   	pop    %edi
  80613a:	5d                   	pop    %ebp
  80613b:	c3                   	ret    

0080613c <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  80613c:	55                   	push   %ebp
  80613d:	89 e5                	mov    %esp,%ebp
  80613f:	57                   	push   %edi
  806140:	56                   	push   %esi
  806141:	53                   	push   %ebx
  806142:	83 ec 3c             	sub    $0x3c,%esp
  806145:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806148:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80614b:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80614f:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  806153:	74 1c                	je     806171 <tcp_connect+0x35>
  806155:	c7 44 24 08 9c 1e 81 	movl   $0x811e9c,0x8(%esp)
  80615c:	00 
  80615d:	c7 44 24 04 ec 01 00 	movl   $0x1ec,0x4(%esp)
  806164:	00 
  806165:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  80616c:	e8 7b 90 00 00       	call   80f1ec <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  806171:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  806176:	85 ff                	test   %edi,%edi
  806178:	0f 84 26 01 00 00    	je     8062a4 <tcp_connect+0x168>
    pcb->remote_ip = *ipaddr;
  80617e:	8b 17                	mov    (%edi),%edx
  806180:	89 53 04             	mov    %edx,0x4(%ebx)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  806183:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  806187:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  80618c:	75 09                	jne    806197 <tcp_connect+0x5b>
    pcb->local_port = tcp_new_port();
  80618e:	e8 17 f9 ff ff       	call   805aaa <tcp_new_port>
  806193:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  806197:	e8 eb f9 ff ff       	call   805b87 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  80619c:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  8061a3:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  8061a6:	83 e8 01             	sub    $0x1,%eax
  8061a9:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  8061ac:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  8061af:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  8061b5:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  8061bb:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8061c1:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8061c7:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8061cb:	c7 04 24 18 02 00 00 	movl   $0x218,(%esp)
  8061d2:	e8 c5 f9 ff ff       	call   805b9c <tcp_eff_send_mss>
  8061d7:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  8061db:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  8061e1:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8061e4:	01 c0                	add    %eax,%eax
  8061e6:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  8061ea:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  8061f1:	8b 45 14             	mov    0x14(%ebp),%eax
  8061f4:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8061fa:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  8061ff:	39 d8                	cmp    %ebx,%eax
  806201:	75 0a                	jne    80620d <tcp_connect+0xd1>
  806203:	8b 40 0c             	mov    0xc(%eax),%eax
  806206:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  80620b:	eb 29                	jmp    806236 <tcp_connect+0xfa>
  80620d:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  806212:	eb 18                	jmp    80622c <tcp_connect+0xf0>
  806214:	8b 42 0c             	mov    0xc(%edx),%eax
  806217:	85 c0                	test   %eax,%eax
  806219:	74 0c                	je     806227 <tcp_connect+0xeb>
  80621b:	39 c3                	cmp    %eax,%ebx
  80621d:	75 08                	jne    806227 <tcp_connect+0xeb>
  80621f:	8b 43 0c             	mov    0xc(%ebx),%eax
  806222:	89 42 0c             	mov    %eax,0xc(%edx)
  806225:	eb 0f                	jmp    806236 <tcp_connect+0xfa>
  806227:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80622c:	8b 15 48 b2 b3 00    	mov    0xb3b248,%edx
  806232:	85 d2                	test   %edx,%edx
  806234:	75 de                	jne    806214 <tcp_connect+0xd8>
  806236:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  TCP_REG(&tcp_active_pcbs, pcb);
  80623d:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  806242:	89 43 0c             	mov    %eax,0xc(%ebx)
  806245:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  80624b:	e8 2d c1 ff ff       	call   80237d <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  806250:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  806257:	e8 24 1c 00 00       	call   807e80 <htonl>
  80625c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  80625f:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  806266:	00 
  806267:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80626a:	89 44 24 14          	mov    %eax,0x14(%esp)
  80626e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  806275:	00 
  806276:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  80627d:	00 
  80627e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  806285:	00 
  806286:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80628d:	00 
  80628e:	89 1c 24             	mov    %ebx,(%esp)
  806291:	e8 6d 27 00 00       	call   808a03 <tcp_enqueue>
  806296:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  806298:	84 c0                	test   %al,%al
  80629a:	75 08                	jne    8062a4 <tcp_connect+0x168>
    tcp_output(pcb);
  80629c:	89 1c 24             	mov    %ebx,(%esp)
  80629f:	e8 27 22 00 00       	call   8084cb <tcp_output>
  }
  return ret;
} 
  8062a4:	89 f0                	mov    %esi,%eax
  8062a6:	83 c4 3c             	add    $0x3c,%esp
  8062a9:	5b                   	pop    %ebx
  8062aa:	5e                   	pop    %esi
  8062ab:	5f                   	pop    %edi
  8062ac:	5d                   	pop    %ebp
  8062ad:	c3                   	ret    

008062ae <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  8062ae:	55                   	push   %ebp
  8062af:	89 e5                	mov    %esp,%ebp
  8062b1:	57                   	push   %edi
  8062b2:	56                   	push   %esi
  8062b3:	53                   	push   %ebx
  8062b4:	83 ec 4c             	sub    $0x4c,%esp
  8062b7:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  8062ba:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  8062be:	75 25                	jne    8062e5 <tcp_abort+0x37>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  8062c0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8062c4:	c7 04 24 50 b2 b3 00 	movl   $0xb3b250,(%esp)
  8062cb:	e8 3d fb ff ff       	call   805e0d <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  8062d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8062d4:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8062db:	e8 e4 e7 ff ff       	call   804ac4 <memp_free>
  8062e0:	e9 d1 00 00 00       	jmp    8063b6 <tcp_abort+0x108>
  } else {
    seqno = pcb->snd_nxt;
  8062e5:	8b 43 54             	mov    0x54(%ebx),%eax
  8062e8:	89 45 d0             	mov    %eax,-0x30(%ebp)
    ackno = pcb->rcv_nxt;
  8062eb:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  8062ee:	b8 00 00 00 00       	mov    $0x0,%eax
  8062f3:	85 db                	test   %ebx,%ebx
  8062f5:	74 02                	je     8062f9 <tcp_abort+0x4b>
  8062f7:	8b 03                	mov    (%ebx),%eax
  8062f9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  8062fc:	b8 00 00 00 00       	mov    $0x0,%eax
  806301:	83 fb fc             	cmp    $0xfffffffc,%ebx
  806304:	74 03                	je     806309 <tcp_abort+0x5b>
  806306:	8b 43 04             	mov    0x4(%ebx),%eax
  806309:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  80630c:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  806310:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    remote_port = pcb->remote_port;
  806314:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  806318:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80631c:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  806322:	8b 43 18             	mov    0x18(%ebx),%eax
  806325:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  806328:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80632c:	c7 04 24 3c b2 b3 00 	movl   $0xb3b23c,(%esp)
  806333:	e8 d5 fa ff ff       	call   805e0d <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  806338:	8b 43 78             	mov    0x78(%ebx),%eax
  80633b:	85 c0                	test   %eax,%eax
  80633d:	74 08                	je     806347 <tcp_abort+0x99>
      tcp_segs_free(pcb->unacked);
  80633f:	89 04 24             	mov    %eax,(%esp)
  806342:	e8 20 fa ff ff       	call   805d67 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  806347:	8b 43 74             	mov    0x74(%ebx),%eax
  80634a:	85 c0                	test   %eax,%eax
  80634c:	74 08                	je     806356 <tcp_abort+0xa8>
      tcp_segs_free(pcb->unsent);
  80634e:	89 04 24             	mov    %eax,(%esp)
  806351:	e8 11 fa ff ff       	call   805d67 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  806356:	8b 43 7c             	mov    0x7c(%ebx),%eax
  806359:	85 c0                	test   %eax,%eax
  80635b:	74 08                	je     806365 <tcp_abort+0xb7>
      tcp_segs_free(pcb->ooseq);
  80635d:	89 04 24             	mov    %eax,(%esp)
  806360:	e8 02 fa ff ff       	call   805d67 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  806365:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806369:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806370:	e8 4f e7 ff ff       	call   804ac4 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  806375:	85 f6                	test   %esi,%esi
  806377:	74 10                	je     806389 <tcp_abort+0xdb>
  806379:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  806380:	ff 
  806381:	8b 45 cc             	mov    -0x34(%ebp),%eax
  806384:	89 04 24             	mov    %eax,(%esp)
  806387:	ff d6                	call   *%esi
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  806389:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80638d:	89 44 24 14          	mov    %eax,0x14(%esp)
  806391:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  806395:	89 44 24 10          	mov    %eax,0x10(%esp)
  806399:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80639c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8063a0:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8063a3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8063a7:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8063ab:	8b 45 d0             	mov    -0x30(%ebp),%eax
  8063ae:	89 04 24             	mov    %eax,(%esp)
  8063b1:	e8 b6 1f 00 00       	call   80836c <tcp_rst>
  }
}
  8063b6:	83 c4 4c             	add    $0x4c,%esp
  8063b9:	5b                   	pop    %ebx
  8063ba:	5e                   	pop    %esi
  8063bb:	5f                   	pop    %edi
  8063bc:	5d                   	pop    %ebp
  8063bd:	c3                   	ret    

008063be <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  8063be:	55                   	push   %ebp
  8063bf:	89 e5                	mov    %esp,%ebp
  8063c1:	83 ec 38             	sub    $0x38,%esp
  8063c4:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8063c7:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8063ca:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8063cd:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  8063d1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8063d8:	e8 2b e7 ff ff       	call   804b08 <memp_malloc>
  8063dd:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  8063df:	85 c0                	test   %eax,%eax
  8063e1:	0f 85 c1 00 00 00    	jne    8064a8 <tcp_alloc+0xea>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8063e7:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8063ec:	8b 1d 40 b2 b3 00    	mov    0xb3b240,%ebx
  8063f2:	b9 00 00 00 00       	mov    $0x0,%ecx
  8063f7:	bf 00 00 00 00       	mov    $0x0,%edi
  8063fc:	eb 14                	jmp    806412 <tcp_alloc+0x54>
  8063fe:	89 da                	mov    %ebx,%edx
  806400:	2b 50 2c             	sub    0x2c(%eax),%edx
  806403:	39 ca                	cmp    %ecx,%edx
  806405:	72 04                	jb     80640b <tcp_alloc+0x4d>
  806407:	89 c7                	mov    %eax,%edi
  806409:	eb 02                	jmp    80640d <tcp_alloc+0x4f>
  80640b:	89 ca                	mov    %ecx,%edx
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80640d:	8b 40 0c             	mov    0xc(%eax),%eax
  806410:	89 d1                	mov    %edx,%ecx
  806412:	85 c0                	test   %eax,%eax
  806414:	75 e8                	jne    8063fe <tcp_alloc+0x40>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  806416:	85 ff                	test   %edi,%edi
  806418:	74 08                	je     806422 <tcp_alloc+0x64>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  80641a:	89 3c 24             	mov    %edi,(%esp)
  80641d:	e8 8c fe ff ff       	call   8062ae <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  806422:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806429:	e8 da e6 ff ff       	call   804b08 <memp_malloc>
  80642e:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  806430:	85 c0                	test   %eax,%eax
  806432:	75 74                	jne    8064a8 <tcp_alloc+0xea>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806434:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806439:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  80643f:	89 55 e0             	mov    %edx,-0x20(%ebp)
  806442:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  806447:	bf 00 00 00 00       	mov    $0x0,%edi
  80644c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  806453:	eb 28                	jmp    80647d <tcp_alloc+0xbf>
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  806455:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  806459:	89 f3                	mov    %esi,%ebx
  80645b:	38 d3                	cmp    %dl,%bl
  80645d:	72 13                	jb     806472 <tcp_alloc+0xb4>
  80645f:	38 ca                	cmp    %cl,%dl
  806461:	77 0f                	ja     806472 <tcp_alloc+0xb4>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806463:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  806466:	2b 58 2c             	sub    0x2c(%eax),%ebx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  806469:	39 fb                	cmp    %edi,%ebx
  80646b:	72 05                	jb     806472 <tcp_alloc+0xb4>
  80646d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806470:	eb 04                	jmp    806476 <tcp_alloc+0xb8>
  806472:	89 ca                	mov    %ecx,%edx
  806474:	89 fb                	mov    %edi,%ebx
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806476:	8b 40 0c             	mov    0xc(%eax),%eax
  806479:	89 d1                	mov    %edx,%ecx
  80647b:	89 df                	mov    %ebx,%edi
  80647d:	85 c0                	test   %eax,%eax
  80647f:	75 d4                	jne    806455 <tcp_alloc+0x97>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  806481:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  806485:	74 0b                	je     806492 <tcp_alloc+0xd4>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  806487:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80648a:	89 04 24             	mov    %eax,(%esp)
  80648d:	e8 1c fe ff ff       	call   8062ae <tcp_abort>
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  806492:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806499:	e8 6a e6 ff ff       	call   804b08 <memp_malloc>
  80649e:	89 c3                	mov    %eax,%ebx
    }
  }
  if (pcb != NULL) {
  8064a0:	85 c0                	test   %eax,%eax
  8064a2:	0f 84 9b 00 00 00    	je     806543 <tcp_alloc+0x185>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  8064a8:	c7 44 24 08 a8 00 00 	movl   $0xa8,0x8(%esp)
  8064af:	00 
  8064b0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8064b7:	00 
  8064b8:	89 1c 24             	mov    %ebx,(%esp)
  8064bb:	e8 90 95 00 00       	call   80fa50 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  8064c0:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  8064c4:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  8064ca:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  8064d0:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  8064d6:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  8064dc:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  8064e0:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8064e4:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8064ea:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  8064f0:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8064f6:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  8064fc:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  806502:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  806508:	e8 7a f6 ff ff       	call   805b87 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  80650d:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  806510:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  806513:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  806516:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  806519:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  80651c:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806521:	89 43 2c             	mov    %eax,0x2c(%ebx)

    pcb->polltmr = 0;
  806524:	c6 43 30 00          	movb   $0x0,0x30(%ebx)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  806528:	c7 83 88 00 00 00 09 	movl   $0x806b09,0x88(%ebx)
  80652f:	6b 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  806532:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  806539:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  80653c:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  }
  return pcb;
}
  806543:	89 d8                	mov    %ebx,%eax
  806545:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  806548:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80654b:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80654e:	89 ec                	mov    %ebp,%esp
  806550:	5d                   	pop    %ebp
  806551:	c3                   	ret    

00806552 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  806552:	55                   	push   %ebp
  806553:	89 e5                	mov    %esp,%ebp
  806555:	83 ec 18             	sub    $0x18,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  806558:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  80655f:	e8 5a fe ff ff       	call   8063be <tcp_alloc>
}
  806564:	c9                   	leave  
  806565:	c3                   	ret    

00806566 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  806566:	55                   	push   %ebp
  806567:	89 e5                	mov    %esp,%ebp
  806569:	57                   	push   %edi
  80656a:	56                   	push   %esi
  80656b:	53                   	push   %ebx
  80656c:	83 ec 2c             	sub    $0x2c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  80656f:	83 05 40 b2 b3 00 01 	addl   $0x1,0xb3b240

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  806576:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  80657c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  806580:	bf 00 00 00 00       	mov    $0x0,%edi
  806585:	e9 3b 03 00 00       	jmp    8068c5 <tcp_slowtmr+0x35f>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80658a:	8b 43 10             	mov    0x10(%ebx),%eax
  80658d:	85 c0                	test   %eax,%eax
  80658f:	75 1c                	jne    8065ad <tcp_slowtmr+0x47>
  806591:	c7 44 24 08 d0 1e 81 	movl   $0x811ed0,0x8(%esp)
  806598:	00 
  806599:	c7 44 24 04 36 02 00 	movl   $0x236,0x4(%esp)
  8065a0:	00 
  8065a1:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  8065a8:	e8 3f 8c 00 00       	call   80f1ec <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  8065ad:	83 f8 01             	cmp    $0x1,%eax
  8065b0:	75 1c                	jne    8065ce <tcp_slowtmr+0x68>
  8065b2:	c7 44 24 08 fc 1e 81 	movl   $0x811efc,0x8(%esp)
  8065b9:	00 
  8065ba:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
  8065c1:	00 
  8065c2:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  8065c9:	e8 1e 8c 00 00       	call   80f1ec <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  8065ce:	83 f8 0a             	cmp    $0xa,%eax
  8065d1:	75 1c                	jne    8065ef <tcp_slowtmr+0x89>
  8065d3:	c7 44 24 08 28 1f 81 	movl   $0x811f28,0x8(%esp)
  8065da:	00 
  8065db:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  8065e2:	00 
  8065e3:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  8065ea:	e8 fd 8b 00 00       	call   80f1ec <_panic>

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  8065ef:	83 f8 02             	cmp    $0x2,%eax
  8065f2:	75 0f                	jne    806603 <tcp_slowtmr+0x9d>
  8065f4:	be 01 00 00 00       	mov    $0x1,%esi
  8065f9:	80 7b 46 06          	cmpb   $0x6,0x46(%ebx)
  8065fd:	0f 84 13 01 00 00    	je     806716 <tcp_slowtmr+0x1b0>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  806603:	be 01 00 00 00       	mov    $0x1,%esi
  806608:	80 7b 46 0c          	cmpb   $0xc,0x46(%ebx)
  80660c:	0f 84 e9 00 00 00    	je     8066fb <tcp_slowtmr+0x195>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  806612:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  806619:	74 55                	je     806670 <tcp_slowtmr+0x10a>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  80661b:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  806621:	83 c0 01             	add    $0x1,%eax
  806624:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  80662a:	0f b6 93 a4 00 00 00 	movzbl 0xa4(%ebx),%edx
  806631:	0f b6 92 5c 20 81 00 	movzbl 0x81205c(%edx),%edx
  806638:	39 d0                	cmp    %edx,%eax
  80663a:	0f 82 b6 00 00 00    	jb     8066f6 <tcp_slowtmr+0x190>
          pcb->persist_cnt = 0;
  806640:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  806647:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80664a:	0f b6 83 a4 00 00 00 	movzbl 0xa4(%ebx),%eax
  806651:	3c 06                	cmp    $0x6,%al
  806653:	77 09                	ja     80665e <tcp_slowtmr+0xf8>
            pcb->persist_backoff++;
  806655:	83 c0 01             	add    $0x1,%eax
  806658:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  80665e:	89 1c 24             	mov    %ebx,(%esp)
  806661:	e8 3a 1a 00 00       	call   8080a0 <tcp_zero_window_probe>
  806666:	be 00 00 00 00       	mov    $0x0,%esi
  80666b:	e9 8b 00 00 00       	jmp    8066fb <tcp_slowtmr+0x195>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  806670:	0f b7 43 32          	movzwl 0x32(%ebx),%eax
  806674:	66 85 c0             	test   %ax,%ax
  806677:	78 07                	js     806680 <tcp_slowtmr+0x11a>
          ++pcb->rtime;
  806679:	83 c0 01             	add    $0x1,%eax
  80667c:	66 89 43 32          	mov    %ax,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  806680:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  806684:	74 70                	je     8066f6 <tcp_slowtmr+0x190>
  806686:	0f b7 43 32          	movzwl 0x32(%ebx),%eax
  80668a:	66 3b 43 44          	cmp    0x44(%ebx),%ax
  80668e:	7c 66                	jl     8066f6 <tcp_slowtmr+0x190>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  806690:	83 7b 10 02          	cmpl   $0x2,0x10(%ebx)
  806694:	74 20                	je     8066b6 <tcp_slowtmr+0x150>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  806696:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  80669a:	66 c1 f8 03          	sar    $0x3,%ax
  80669e:	98                   	cwtl   
  80669f:	0f bf 53 42          	movswl 0x42(%ebx),%edx
  8066a3:	01 d0                	add    %edx,%eax
  8066a5:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  8066a9:	0f b6 8a 50 20 81 00 	movzbl 0x812050(%edx),%ecx
  8066b0:	d3 e0                	shl    %cl,%eax
  8066b2:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  8066b6:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  8066bc:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  8066c0:	66 39 43 4e          	cmp    %ax,0x4e(%ebx)
  8066c4:	66 0f 46 43 4e       	cmovbe 0x4e(%ebx),%ax
  8066c9:	66 d1 e8             	shr    %ax
  8066cc:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  8066d0:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  8066d4:	66 39 d0             	cmp    %dx,%ax
  8066d7:	73 06                	jae    8066df <tcp_slowtmr+0x179>
            pcb->ssthresh = pcb->mss * 2;
  8066d9:	01 d2                	add    %edx,%edx
  8066db:	66 89 53 50          	mov    %dx,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  8066df:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  8066e3:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  8066e7:	89 1c 24             	mov    %ebx,(%esp)
  8066ea:	e8 bf 22 00 00       	call   8089ae <tcp_rexmit_rto>
  8066ef:	be 00 00 00 00       	mov    $0x0,%esi
  8066f4:	eb 05                	jmp    8066fb <tcp_slowtmr+0x195>
  8066f6:	be 00 00 00 00       	mov    $0x0,%esi
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  8066fb:	8b 43 10             	mov    0x10(%ebx),%eax
  8066fe:	83 f8 06             	cmp    $0x6,%eax
  806701:	75 13                	jne    806716 <tcp_slowtmr+0x1b0>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  806703:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  806709:	2b 53 2c             	sub    0x2c(%ebx),%edx
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80670c:	83 fa 29             	cmp    $0x29,%edx
  80670f:	89 f2                	mov    %esi,%edx
  806711:	80 da ff             	sbb    $0xff,%dl
  806714:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  806716:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  80671a:	74 6a                	je     806786 <tcp_slowtmr+0x220>
  80671c:	83 f8 04             	cmp    $0x4,%eax
  80671f:	74 05                	je     806726 <tcp_slowtmr+0x1c0>
  806721:	83 f8 07             	cmp    $0x7,%eax
  806724:	75 60                	jne    806786 <tcp_slowtmr+0x220>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  806726:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80672b:	2b 43 2c             	sub    0x2c(%ebx),%eax
  80672e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  806731:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
  806737:	8d 81 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%eax
  80673d:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  806742:	f7 e2                	mul    %edx
  806744:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  806747:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80674a:	76 0a                	jbe    806756 <tcp_slowtmr+0x1f0>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  80674c:	89 1c 24             	mov    %ebx,(%esp)
  80674f:	e8 5a fb ff ff       	call   8062ae <tcp_abort>
  806754:	eb 30                	jmp    806786 <tcp_slowtmr+0x220>
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  806756:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  80675d:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  806763:	8d 0c 0a             	lea    (%edx,%ecx,1),%ecx
              / TCP_SLOW_INTERVAL)
  806766:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80676b:	89 c8                	mov    %ecx,%eax
  80676d:	f7 e2                	mul    %edx
  80676f:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  806772:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  806775:	76 0f                	jbe    806786 <tcp_slowtmr+0x220>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  806777:	89 1c 24             	mov    %ebx,(%esp)
  80677a:	e8 98 1a 00 00       	call   808217 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  80677f:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  806786:	8b 53 7c             	mov    0x7c(%ebx),%edx
  806789:	85 d2                	test   %edx,%edx
  80678b:	74 25                	je     8067b2 <tcp_slowtmr+0x24c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  80678d:	8b 0d 40 b2 b3 00    	mov    0xb3b240,%ecx
  806793:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  806796:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  80679a:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80679d:	01 c0                	add    %eax,%eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80679f:	39 c1                	cmp    %eax,%ecx
  8067a1:	72 0f                	jb     8067b2 <tcp_slowtmr+0x24c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  8067a3:	89 14 24             	mov    %edx,(%esp)
  8067a6:	e8 bc f5 ff ff       	call   805d67 <tcp_segs_free>
      pcb->ooseq = NULL;
  8067ab:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  8067b2:	8b 43 10             	mov    0x10(%ebx),%eax
  8067b5:	83 f8 03             	cmp    $0x3,%eax
  8067b8:	75 13                	jne    8067cd <tcp_slowtmr+0x267>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  8067ba:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  8067c0:	2b 53 2c             	sub    0x2c(%ebx),%edx
  8067c3:	83 fa 28             	cmp    $0x28,%edx
  8067c6:	76 05                	jbe    8067cd <tcp_slowtmr+0x267>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  8067c8:	83 c6 01             	add    $0x1,%esi
  8067cb:	eb 19                	jmp    8067e6 <tcp_slowtmr+0x280>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  8067cd:	83 f8 09             	cmp    $0x9,%eax
  8067d0:	75 14                	jne    8067e6 <tcp_slowtmr+0x280>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8067d2:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8067d7:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  8067da:	3d f1 00 00 00       	cmp    $0xf1,%eax
  8067df:	89 f2                	mov    %esi,%edx
  8067e1:	80 da ff             	sbb    $0xff,%dl
  8067e4:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  8067e6:	89 f0                	mov    %esi,%eax
  8067e8:	84 c0                	test   %al,%al
  8067ea:	0f 84 94 00 00 00    	je     806884 <tcp_slowtmr+0x31e>
      tcp_pcb_purge(pcb);      
  8067f0:	89 1c 24             	mov    %ebx,(%esp)
  8067f3:	e8 9c f5 ff ff       	call   805d94 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  8067f8:	85 ff                	test   %edi,%edi
  8067fa:	74 2c                	je     806828 <tcp_slowtmr+0x2c2>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  8067fc:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  806802:	75 1c                	jne    806820 <tcp_slowtmr+0x2ba>
  806804:	c7 44 24 08 58 1f 81 	movl   $0x811f58,0x8(%esp)
  80680b:	00 
  80680c:	c7 44 24 04 c1 02 00 	movl   $0x2c1,0x4(%esp)
  806813:	00 
  806814:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  80681b:	e8 cc 89 00 00       	call   80f1ec <_panic>
        prev->next = pcb->next;
  806820:	8b 43 0c             	mov    0xc(%ebx),%eax
  806823:	89 47 0c             	mov    %eax,0xc(%edi)
  806826:	eb 2d                	jmp    806855 <tcp_slowtmr+0x2ef>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  806828:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80682d:	39 d8                	cmp    %ebx,%eax
  80682f:	74 1c                	je     80684d <tcp_slowtmr+0x2e7>
  806831:	c7 44 24 08 84 1f 81 	movl   $0x811f84,0x8(%esp)
  806838:	00 
  806839:	c7 44 24 04 c5 02 00 	movl   $0x2c5,0x4(%esp)
  806840:	00 
  806841:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  806848:	e8 9f 89 00 00       	call   80f1ec <_panic>
        tcp_active_pcbs = pcb->next;
  80684d:	8b 40 0c             	mov    0xc(%eax),%eax
  806850:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  806855:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80685b:	85 c0                	test   %eax,%eax
  80685d:	74 10                	je     80686f <tcp_slowtmr+0x309>
  80685f:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  806866:	ff 
  806867:	8b 53 18             	mov    0x18(%ebx),%edx
  80686a:	89 14 24             	mov    %edx,(%esp)
  80686d:	ff d0                	call   *%eax

      pcb2 = pcb->next;
  80686f:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  806872:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806876:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80687d:	e8 42 e2 ff ff       	call   804ac4 <memp_free>
  806882:	eb 3f                	jmp    8068c3 <tcp_slowtmr+0x35d>
      pcb = pcb2;
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  806884:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  806888:	83 c0 01             	add    $0x1,%eax
  80688b:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  80688e:	3a 43 31             	cmp    0x31(%ebx),%al
  806891:	72 2b                	jb     8068be <tcp_slowtmr+0x358>
        pcb->polltmr = 0;
  806893:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  806897:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80689d:	85 c0                	test   %eax,%eax
  80689f:	74 0f                	je     8068b0 <tcp_slowtmr+0x34a>
  8068a1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8068a5:	8b 53 18             	mov    0x18(%ebx),%edx
  8068a8:	89 14 24             	mov    %edx,(%esp)
  8068ab:	ff d0                	call   *%eax
  8068ad:	88 45 e3             	mov    %al,-0x1d(%ebp)
        if (err == ERR_OK) {
  8068b0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8068b4:	75 08                	jne    8068be <tcp_slowtmr+0x358>
          tcp_output(pcb);
  8068b6:	89 1c 24             	mov    %ebx,(%esp)
  8068b9:	e8 0d 1c 00 00       	call   8084cb <tcp_output>
        }
      }
      
      prev = pcb;
      pcb = pcb->next;
  8068be:	8b 73 0c             	mov    0xc(%ebx),%esi
  8068c1:	89 df                	mov    %ebx,%edi
  8068c3:	89 f3                	mov    %esi,%ebx
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  8068c5:	85 db                	test   %ebx,%ebx
  8068c7:	0f 85 bd fc ff ff    	jne    80658a <tcp_slowtmr+0x24>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  8068cd:	8b 1d 50 b2 b3 00    	mov    0xb3b250,%ebx
  8068d3:	be 00 00 00 00       	mov    $0x0,%esi
  while (pcb != NULL) {
  8068d8:	e9 b2 00 00 00       	jmp    80698f <tcp_slowtmr+0x429>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8068dd:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  8068e1:	74 1c                	je     8068ff <tcp_slowtmr+0x399>
  8068e3:	c7 44 24 08 b0 1f 81 	movl   $0x811fb0,0x8(%esp)
  8068ea:	00 
  8068eb:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
  8068f2:	00 
  8068f3:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  8068fa:	e8 ed 88 00 00       	call   80f1ec <_panic>
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8068ff:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806904:	2b 43 2c             	sub    0x2c(%ebx),%eax
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  806907:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80690c:	76 7a                	jbe    806988 <tcp_slowtmr+0x422>
      tcp_pcb_purge(pcb);      
  80690e:	89 1c 24             	mov    %ebx,(%esp)
  806911:	e8 7e f4 ff ff       	call   805d94 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  806916:	85 f6                	test   %esi,%esi
  806918:	74 2c                	je     806946 <tcp_slowtmr+0x3e0>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  80691a:	3b 1d 50 b2 b3 00    	cmp    0xb3b250,%ebx
  806920:	75 1c                	jne    80693e <tcp_slowtmr+0x3d8>
  806922:	c7 44 24 08 e0 1f 81 	movl   $0x811fe0,0x8(%esp)
  806929:	00 
  80692a:	c7 44 24 04 f4 02 00 	movl   $0x2f4,0x4(%esp)
  806931:	00 
  806932:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  806939:	e8 ae 88 00 00       	call   80f1ec <_panic>
        prev->next = pcb->next;
  80693e:	8b 43 0c             	mov    0xc(%ebx),%eax
  806941:	89 46 0c             	mov    %eax,0xc(%esi)
  806944:	eb 2d                	jmp    806973 <tcp_slowtmr+0x40d>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  806946:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80694b:	39 d8                	cmp    %ebx,%eax
  80694d:	74 1c                	je     80696b <tcp_slowtmr+0x405>
  80694f:	c7 44 24 08 08 20 81 	movl   $0x812008,0x8(%esp)
  806956:	00 
  806957:	c7 44 24 04 f8 02 00 	movl   $0x2f8,0x4(%esp)
  80695e:	00 
  80695f:	c7 04 24 07 1e 81 00 	movl   $0x811e07,(%esp)
  806966:	e8 81 88 00 00       	call   80f1ec <_panic>
        tcp_tw_pcbs = pcb->next;
  80696b:	8b 40 0c             	mov    0xc(%eax),%eax
  80696e:	a3 50 b2 b3 00       	mov    %eax,0xb3b250
      }
      pcb2 = pcb->next;
  806973:	8b 7b 0c             	mov    0xc(%ebx),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  806976:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80697a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806981:	e8 3e e1 ff ff       	call   804ac4 <memp_free>
  806986:	eb 05                	jmp    80698d <tcp_slowtmr+0x427>
      pcb = pcb2;
    } else {
      prev = pcb;
      pcb = pcb->next;
  806988:	8b 7b 0c             	mov    0xc(%ebx),%edi
  80698b:	89 de                	mov    %ebx,%esi
  80698d:	89 fb                	mov    %edi,%ebx

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  80698f:	85 db                	test   %ebx,%ebx
  806991:	0f 85 46 ff ff ff    	jne    8068dd <tcp_slowtmr+0x377>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  806997:	83 c4 2c             	add    $0x2c,%esp
  80699a:	5b                   	pop    %ebx
  80699b:	5e                   	pop    %esi
  80699c:	5f                   	pop    %edi
  80699d:	5d                   	pop    %ebp
  80699e:	c3                   	ret    

0080699f <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  80699f:	55                   	push   %ebp
  8069a0:	89 e5                	mov    %esp,%ebp
  8069a2:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  8069a5:	e8 bb f2 ff ff       	call   805c65 <tcp_fasttmr>

  if (++tcp_timer & 1) {
  8069aa:	0f b6 05 e8 43 b3 00 	movzbl 0xb343e8,%eax
  8069b1:	83 c0 01             	add    $0x1,%eax
  8069b4:	a2 e8 43 b3 00       	mov    %al,0xb343e8
  8069b9:	a8 01                	test   $0x1,%al
  8069bb:	74 05                	je     8069c2 <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  8069bd:	e8 a4 fb ff ff       	call   806566 <tcp_slowtmr>
  }
}
  8069c2:	c9                   	leave  
  8069c3:	c3                   	ret    

008069c4 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  8069c4:	55                   	push   %ebp
  8069c5:	89 e5                	mov    %esp,%ebp
  8069c7:	53                   	push   %ebx
  8069c8:	83 ec 14             	sub    $0x14,%esp
  8069cb:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  8069ce:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8069d2:	77 0a                	ja     8069de <tcp_close+0x1a>
  8069d4:	8b 43 10             	mov    0x10(%ebx),%eax
  8069d7:	ff 24 85 30 20 81 00 	jmp    *0x812030(,%eax,4)
  8069de:	bb 00 00 00 00       	mov    $0x0,%ebx
  8069e3:	e9 03 01 00 00       	jmp    806aeb <tcp_close+0x127>
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  8069e8:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  8069ed:	39 d8                	cmp    %ebx,%eax
  8069ef:	75 0a                	jne    8069fb <tcp_close+0x37>
  8069f1:	8b 40 0c             	mov    0xc(%eax),%eax
  8069f4:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  8069f9:	eb 29                	jmp    806a24 <tcp_close+0x60>
  8069fb:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  806a00:	eb 18                	jmp    806a1a <tcp_close+0x56>
  806a02:	8b 42 0c             	mov    0xc(%edx),%eax
  806a05:	85 c0                	test   %eax,%eax
  806a07:	74 0c                	je     806a15 <tcp_close+0x51>
  806a09:	39 c3                	cmp    %eax,%ebx
  806a0b:	75 08                	jne    806a15 <tcp_close+0x51>
  806a0d:	8b 43 0c             	mov    0xc(%ebx),%eax
  806a10:	89 42 0c             	mov    %eax,0xc(%edx)
  806a13:	eb 0f                	jmp    806a24 <tcp_close+0x60>
  806a15:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  806a1a:	8b 15 48 b2 b3 00    	mov    0xb3b248,%edx
  806a20:	85 d2                	test   %edx,%edx
  806a22:	75 de                	jne    806a02 <tcp_close+0x3e>
  806a24:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  806a2b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806a2f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806a36:	e8 89 e0 ff ff       	call   804ac4 <memp_free>
  806a3b:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    break;
  806a40:	e9 be 00 00 00       	jmp    806b03 <tcp_close+0x13f>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  806a45:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806a49:	c7 04 24 44 b2 b3 00 	movl   $0xb3b244,(%esp)
  806a50:	e8 b8 f3 ff ff       	call   805e0d <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  806a55:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806a59:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  806a60:	e8 5f e0 ff ff       	call   804ac4 <memp_free>
  806a65:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    break;
  806a6a:	e9 94 00 00 00       	jmp    806b03 <tcp_close+0x13f>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  806a6f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806a73:	c7 04 24 3c b2 b3 00 	movl   $0xb3b23c,(%esp)
  806a7a:	e8 8e f3 ff ff       	call   805e0d <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  806a7f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806a83:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806a8a:	e8 35 e0 ff ff       	call   804ac4 <memp_free>
  806a8f:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  806a94:	eb 6d                	jmp    806b03 <tcp_close+0x13f>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  806a96:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  806a9d:	00 
  806a9e:	89 1c 24             	mov    %ebx,(%esp)
  806aa1:	e8 b3 26 00 00       	call   809159 <tcp_send_ctrl>
    if (err == ERR_OK) {
  806aa6:	84 c0                	test   %al,%al
  806aa8:	75 59                	jne    806b03 <tcp_close+0x13f>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  806aaa:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  806ab1:	eb 38                	jmp    806aeb <tcp_close+0x127>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  806ab3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  806aba:	00 
  806abb:	89 1c 24             	mov    %ebx,(%esp)
  806abe:	e8 96 26 00 00       	call   809159 <tcp_send_ctrl>
    if (err == ERR_OK) {
  806ac3:	84 c0                	test   %al,%al
  806ac5:	75 3c                	jne    806b03 <tcp_close+0x13f>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  806ac7:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  806ace:	eb 1b                	jmp    806aeb <tcp_close+0x127>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  806ad0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  806ad7:	00 
  806ad8:	89 1c 24             	mov    %ebx,(%esp)
  806adb:	e8 79 26 00 00       	call   809159 <tcp_send_ctrl>
    if (err == ERR_OK) {
  806ae0:	84 c0                	test   %al,%al
  806ae2:	75 1f                	jne    806b03 <tcp_close+0x13f>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  806ae4:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  806aeb:	85 db                	test   %ebx,%ebx
  806aed:	75 07                	jne    806af6 <tcp_close+0x132>
  806aef:	b8 00 00 00 00       	mov    $0x0,%eax
  806af4:	eb 0d                	jmp    806b03 <tcp_close+0x13f>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  806af6:	89 1c 24             	mov    %ebx,(%esp)
  806af9:	e8 cd 19 00 00       	call   8084cb <tcp_output>
  806afe:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  806b03:	83 c4 14             	add    $0x14,%esp
  806b06:	5b                   	pop    %ebx
  806b07:	5d                   	pop    %ebp
  806b08:	c3                   	ret    

00806b09 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  806b09:	55                   	push   %ebp
  806b0a:	89 e5                	mov    %esp,%ebp
  806b0c:	83 ec 18             	sub    $0x18,%esp
  806b0f:	8b 45 10             	mov    0x10(%ebp),%eax
  806b12:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  806b16:	85 c0                	test   %eax,%eax
  806b18:	74 0f                	je     806b29 <tcp_recv_null+0x20>
    pbuf_free(p);
  806b1a:	89 04 24             	mov    %eax,(%esp)
  806b1d:	e8 02 e7 ff ff       	call   805224 <pbuf_free>
  806b22:	b8 00 00 00 00       	mov    $0x0,%eax
  806b27:	eb 14                	jmp    806b3d <tcp_recv_null+0x34>
  } else if (err == ERR_OK) {
  806b29:	b8 00 00 00 00       	mov    $0x0,%eax
  806b2e:	84 d2                	test   %dl,%dl
  806b30:	75 0b                	jne    806b3d <tcp_recv_null+0x34>
    return tcp_close(pcb);
  806b32:	8b 45 0c             	mov    0xc(%ebp),%eax
  806b35:	89 04 24             	mov    %eax,(%esp)
  806b38:	e8 87 fe ff ff       	call   8069c4 <tcp_close>
  }
  return ERR_OK;
}
  806b3d:	c9                   	leave  
  806b3e:	c3                   	ret    
	...

00806b40 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  806b40:	55                   	push   %ebp
  806b41:	89 e5                	mov    %esp,%ebp
  806b43:	53                   	push   %ebx
  806b44:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  806b47:	8b 45 08             	mov    0x8(%ebp),%eax
  806b4a:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806b4c:	8d 5a ff             	lea    -0x1(%edx),%ebx
  806b4f:	b8 01 00 00 00       	mov    $0x1,%eax
  806b54:	83 fb fd             	cmp    $0xfffffffd,%ebx
  806b57:	77 26                	ja     806b7f <ip_addr_isbroadcast+0x3f>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  806b59:	f6 41 2e 02          	testb  $0x2,0x2e(%ecx)
  806b5d:	74 1b                	je     806b7a <ip_addr_isbroadcast+0x3a>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  806b5f:	8b 41 04             	mov    0x4(%ecx),%eax
  806b62:	39 d0                	cmp    %edx,%eax
  806b64:	74 14                	je     806b7a <ip_addr_isbroadcast+0x3a>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806b66:	8b 49 08             	mov    0x8(%ecx),%ecx
  806b69:	31 d0                	xor    %edx,%eax
  806b6b:	85 c8                	test   %ecx,%eax
  806b6d:	75 0b                	jne    806b7a <ip_addr_isbroadcast+0x3a>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806b6f:	f7 d1                	not    %ecx
  806b71:	21 ca                	and    %ecx,%edx
  806b73:	39 d1                	cmp    %edx,%ecx
  806b75:	0f 94 c0             	sete   %al
  806b78:	eb 05                	jmp    806b7f <ip_addr_isbroadcast+0x3f>
  806b7a:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  806b7f:	5b                   	pop    %ebx
  806b80:	5d                   	pop    %ebp
  806b81:	c3                   	ret    
	...

00806b90 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  806b90:	55                   	push   %ebp
  806b91:	89 e5                	mov    %esp,%ebp
  806b93:	83 ec 48             	sub    $0x48,%esp
  806b96:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  806b99:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806b9c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806b9f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806ba2:	8b 7d 10             	mov    0x10(%ebp),%edi
  806ba5:	8b 75 20             	mov    0x20(%ebp),%esi
  806ba8:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  806bac:	88 45 d8             	mov    %al,-0x28(%ebp)
  806baf:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
  806bb3:	88 55 d7             	mov    %dl,-0x29(%ebp)
  806bb6:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  806bba:	88 45 d6             	mov    %al,-0x2a(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  806bbd:	85 ff                	test   %edi,%edi
  806bbf:	0f 84 3a 01 00 00    	je     806cff <ip_output_if+0x16f>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806bc5:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  806bcc:	00 
  806bcd:	89 1c 24             	mov    %ebx,(%esp)
  806bd0:	e8 f2 e2 ff ff       	call   804ec7 <pbuf_header>
  806bd5:	89 c2                	mov    %eax,%edx
  806bd7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  806bdc:	84 d2                	test   %dl,%dl
  806bde:	0f 85 50 01 00 00    	jne    806d34 <ip_output_if+0x1a4>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  806be4:	8b 43 04             	mov    0x4(%ebx),%eax
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806be7:	66 83 7b 0a 13       	cmpw   $0x13,0xa(%ebx)
  806bec:	77 1c                	ja     806c0a <ip_output_if+0x7a>
  806bee:	c7 44 24 08 6c 20 81 	movl   $0x81206c,0x8(%esp)
  806bf5:	00 
  806bf6:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
  806bfd:	00 
  806bfe:	c7 04 24 99 20 81 00 	movl   $0x812099,(%esp)
  806c05:	e8 e2 85 00 00       	call   80f1ec <_panic>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  806c0a:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  806c0d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  806c11:	89 04 24             	mov    %eax,(%esp)
  806c14:	e8 53 12 00 00       	call   807e6c <ntohs>
  806c19:	0f b6 d0             	movzbl %al,%edx
  806c1c:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
  806c20:	c1 e0 08             	shl    $0x8,%eax
  806c23:	09 d0                	or     %edx,%eax
  806c25:	0f b7 c0             	movzwl %ax,%eax
  806c28:	89 04 24             	mov    %eax,(%esp)
  806c2b:	e8 2f 12 00 00       	call   807e5f <htons>
  806c30:	8b 55 d0             	mov    -0x30(%ebp),%edx
  806c33:	66 89 42 08          	mov    %ax,0x8(%edx)
    IPH_PROTO_SET(iphdr, proto);
  806c37:	0f b7 c0             	movzwl %ax,%eax
  806c3a:	89 04 24             	mov    %eax,(%esp)
  806c3d:	e8 2a 12 00 00       	call   807e6c <ntohs>
  806c42:	89 c2                	mov    %eax,%edx
  806c44:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  806c4a:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
  806c4e:	09 d0                	or     %edx,%eax
  806c50:	0f b7 c0             	movzwl %ax,%eax
  806c53:	89 04 24             	mov    %eax,(%esp)
  806c56:	e8 04 12 00 00       	call   807e5f <htons>
  806c5b:	8b 55 d0             	mov    -0x30(%ebp),%edx
  806c5e:	66 89 42 08          	mov    %ax,0x8(%edx)

    ip_addr_set(&(iphdr->dest), dest);
  806c62:	8b 07                	mov    (%edi),%eax
  806c64:	89 42 10             	mov    %eax,0x10(%edx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806c67:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
  806c6b:	80 cc 45             	or     $0x45,%ah
  806c6e:	89 04 24             	mov    %eax,(%esp)
  806c71:	e8 e9 11 00 00       	call   807e5f <htons>
  806c76:	8b 55 d0             	mov    -0x30(%ebp),%edx
  806c79:	66 89 02             	mov    %ax,(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  806c7c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806c80:	89 04 24             	mov    %eax,(%esp)
  806c83:	e8 d7 11 00 00       	call   807e5f <htons>
  806c88:	8b 55 d0             	mov    -0x30(%ebp),%edx
  806c8b:	66 89 42 02          	mov    %ax,0x2(%edx)
    IPH_OFFSET_SET(iphdr, 0);
  806c8f:	66 c7 42 06 00 00    	movw   $0x0,0x6(%edx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806c95:	0f b7 05 ec 43 b3 00 	movzwl 0xb343ec,%eax
  806c9c:	89 04 24             	mov    %eax,(%esp)
  806c9f:	e8 bb 11 00 00       	call   807e5f <htons>
  806ca4:	8b 55 d0             	mov    -0x30(%ebp),%edx
  806ca7:	66 89 42 04          	mov    %ax,0x4(%edx)
    ++ip_id;
  806cab:	66 83 05 ec 43 b3 00 	addw   $0x1,0xb343ec
  806cb2:	01 

    if (ip_addr_isany(src)) {
  806cb3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806cb7:	74 09                	je     806cc2 <ip_output_if+0x132>
  806cb9:	8b 55 0c             	mov    0xc(%ebp),%edx
  806cbc:	8b 02                	mov    (%edx),%eax
  806cbe:	85 c0                	test   %eax,%eax
  806cc0:	75 15                	jne    806cd7 <ip_output_if+0x147>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806cc2:	b8 00 00 00 00       	mov    $0x0,%eax
  806cc7:	83 fe fc             	cmp    $0xfffffffc,%esi
  806cca:	74 03                	je     806ccf <ip_output_if+0x13f>
  806ccc:	8b 46 04             	mov    0x4(%esi),%eax
  806ccf:	8b 55 d0             	mov    -0x30(%ebp),%edx
  806cd2:	89 42 0c             	mov    %eax,0xc(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
    ++ip_id;

    if (ip_addr_isany(src)) {
  806cd5:	eb 06                	jmp    806cdd <ip_output_if+0x14d>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
    } else {
      ip_addr_set(&(iphdr->src), src);
  806cd7:	8b 55 d0             	mov    -0x30(%ebp),%edx
  806cda:	89 42 0c             	mov    %eax,0xc(%edx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806cdd:	8b 45 d0             	mov    -0x30(%ebp),%eax
  806ce0:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806ce6:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  806ced:	00 
  806cee:	89 04 24             	mov    %eax,(%esp)
  806cf1:	e8 6c 0e 00 00       	call   807b62 <inet_chksum>
  806cf6:	8b 55 d0             	mov    -0x30(%ebp),%edx
  806cf9:	66 89 42 0a          	mov    %ax,0xa(%edx)
  806cfd:	eb 06                	jmp    806d05 <ip_output_if+0x175>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  806cff:	8b 7b 04             	mov    0x4(%ebx),%edi
  806d02:	83 c7 10             	add    $0x10,%edi
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806d05:	0f b7 46 2c          	movzwl 0x2c(%esi),%eax
  806d09:	66 85 c0             	test   %ax,%ax
  806d0c:	74 18                	je     806d26 <ip_output_if+0x196>
  806d0e:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  806d12:	73 12                	jae    806d26 <ip_output_if+0x196>
    return ip_frag(p,netif,dest);
  806d14:	89 7c 24 08          	mov    %edi,0x8(%esp)
  806d18:	89 74 24 04          	mov    %esi,0x4(%esp)
  806d1c:	89 1c 24             	mov    %ebx,(%esp)
  806d1f:	e8 9c 03 00 00       	call   8070c0 <ip_frag>
  806d24:	eb 0e                	jmp    806d34 <ip_output_if+0x1a4>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806d26:	89 7c 24 08          	mov    %edi,0x8(%esp)
  806d2a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806d2e:	89 34 24             	mov    %esi,(%esp)
  806d31:	ff 56 14             	call   *0x14(%esi)
  }
}
  806d34:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  806d37:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806d3a:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806d3d:	89 ec                	mov    %ebp,%esp
  806d3f:	5d                   	pop    %ebp
  806d40:	c3                   	ret    

00806d41 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  806d41:	55                   	push   %ebp
  806d42:	89 e5                	mov    %esp,%ebp
  806d44:	56                   	push   %esi
  806d45:	53                   	push   %ebx
  806d46:	83 ec 10             	sub    $0x10,%esp
  806d49:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806d4c:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  806d52:	eb 18                	jmp    806d6c <ip_route+0x2b>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  806d54:	89 1c 24             	mov    %ebx,(%esp)
  806d57:	e8 f3 de ff ff       	call   804c4f <netif_is_up>
  806d5c:	84 c0                	test   %al,%al
  806d5e:	74 0a                	je     806d6a <ip_route+0x29>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  806d60:	8b 43 04             	mov    0x4(%ebx),%eax
  806d63:	33 06                	xor    (%esi),%eax
  806d65:	85 43 08             	test   %eax,0x8(%ebx)
  806d68:	74 20                	je     806d8a <ip_route+0x49>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806d6a:	8b 1b                	mov    (%ebx),%ebx
  806d6c:	85 db                	test   %ebx,%ebx
  806d6e:	75 e4                	jne    806d54 <ip_route+0x13>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  806d70:	a1 38 b2 b3 00       	mov    0xb3b238,%eax
  806d75:	85 c0                	test   %eax,%eax
  806d77:	74 11                	je     806d8a <ip_route+0x49>
  806d79:	89 04 24             	mov    %eax,(%esp)
  806d7c:	e8 ce de ff ff       	call   804c4f <netif_is_up>
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  806d81:	84 c0                	test   %al,%al
  806d83:	0f 45 1d 38 b2 b3 00 	cmovne 0xb3b238,%ebx
}
  806d8a:	89 d8                	mov    %ebx,%eax
  806d8c:	83 c4 10             	add    $0x10,%esp
  806d8f:	5b                   	pop    %ebx
  806d90:	5e                   	pop    %esi
  806d91:	5d                   	pop    %ebp
  806d92:	c3                   	ret    

00806d93 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806d93:	55                   	push   %ebp
  806d94:	89 e5                	mov    %esp,%ebp
  806d96:	83 ec 48             	sub    $0x48,%esp
  806d99:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  806d9c:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806d9f:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806da2:	8b 5d 10             	mov    0x10(%ebp),%ebx
  806da5:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  806da9:	88 45 e7             	mov    %al,-0x19(%ebp)
  806dac:	0f b6 7d 18          	movzbl 0x18(%ebp),%edi
  806db0:	0f b6 75 1c          	movzbl 0x1c(%ebp),%esi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806db4:	89 1c 24             	mov    %ebx,(%esp)
  806db7:	e8 85 ff ff ff       	call   806d41 <ip_route>
  806dbc:	89 c2                	mov    %eax,%edx
  806dbe:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  806dc3:	85 d2                	test   %edx,%edx
  806dc5:	74 36                	je     806dfd <ip_output+0x6a>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806dc7:	89 54 24 18          	mov    %edx,0x18(%esp)
  806dcb:	81 e6 ff 00 00 00    	and    $0xff,%esi
  806dd1:	89 74 24 14          	mov    %esi,0x14(%esp)
  806dd5:	81 e7 ff 00 00 00    	and    $0xff,%edi
  806ddb:	89 7c 24 10          	mov    %edi,0x10(%esp)
  806ddf:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  806de3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  806de7:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  806deb:	8b 45 0c             	mov    0xc(%ebp),%eax
  806dee:	89 44 24 04          	mov    %eax,0x4(%esp)
  806df2:	8b 45 08             	mov    0x8(%ebp),%eax
  806df5:	89 04 24             	mov    %eax,(%esp)
  806df8:	e8 93 fd ff ff       	call   806b90 <ip_output_if>
}
  806dfd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  806e00:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806e03:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806e06:	89 ec                	mov    %ebp,%esp
  806e08:	5d                   	pop    %ebp
  806e09:	c3                   	ret    

00806e0a <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  806e0a:	55                   	push   %ebp
  806e0b:	89 e5                	mov    %esp,%ebp
  806e0d:	83 ec 48             	sub    $0x48,%esp
  806e10:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  806e13:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806e16:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806e19:	8b 75 08             	mov    0x8(%ebp),%esi

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806e1c:	8b 5e 04             	mov    0x4(%esi),%ebx
  if (IPH_V(iphdr) != 4) {
  806e1f:	0f b7 03             	movzwl (%ebx),%eax
  806e22:	89 04 24             	mov    %eax,(%esp)
  806e25:	e8 42 10 00 00       	call   807e6c <ntohs>
  806e2a:	66 c1 e8 0c          	shr    $0xc,%ax
  806e2e:	66 83 f8 04          	cmp    $0x4,%ax
  806e32:	74 0d                	je     806e41 <ip_input+0x37>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  806e34:	89 34 24             	mov    %esi,(%esp)
  806e37:	e8 e8 e3 ff ff       	call   805224 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806e3c:	e9 65 02 00 00       	jmp    8070a6 <ip_input+0x29c>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  806e41:	0f b7 03             	movzwl (%ebx),%eax
  806e44:	89 04 24             	mov    %eax,(%esp)
  806e47:	e8 20 10 00 00       	call   807e6c <ntohs>
  806e4c:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  806e50:	83 e0 3c             	and    $0x3c,%eax
  806e53:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  806e57:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806e5b:	89 04 24             	mov    %eax,(%esp)
  806e5e:	e8 09 10 00 00       	call   807e6c <ntohs>
  806e63:	89 c7                	mov    %eax,%edi

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806e65:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  806e69:	66 3b 46 0a          	cmp    0xa(%esi),%ax
  806e6d:	77 06                	ja     806e75 <ip_input+0x6b>
  806e6f:	66 3b 7e 08          	cmp    0x8(%esi),%di
  806e73:	76 0d                	jbe    806e82 <ip_input+0x78>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  806e75:	89 34 24             	mov    %esi,(%esp)
  806e78:	e8 a7 e3 ff ff       	call   805224 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  806e7d:	e9 24 02 00 00       	jmp    8070a6 <ip_input+0x29c>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  806e82:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  806e86:	89 44 24 04          	mov    %eax,0x4(%esp)
  806e8a:	89 1c 24             	mov    %ebx,(%esp)
  806e8d:	e8 d0 0c 00 00       	call   807b62 <inet_chksum>
  806e92:	66 85 c0             	test   %ax,%ax
  806e95:	74 0e                	je     806ea5 <ip_input+0x9b>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  806e97:	89 34 24             	mov    %esi,(%esp)
  806e9a:	e8 85 e3 ff ff       	call   805224 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806e9f:	90                   	nop
  806ea0:	e9 01 02 00 00       	jmp    8070a6 <ip_input+0x29c>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  806ea5:	0f b7 ff             	movzwl %di,%edi
  806ea8:	89 7c 24 04          	mov    %edi,0x4(%esp)
  806eac:	89 34 24             	mov    %esi,(%esp)
  806eaf:	e8 f9 e4 ff ff       	call   8053ad <pbuf_realloc>
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806eb4:	8d 43 10             	lea    0x10(%ebx),%eax
  806eb7:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806eba:	8b 7d 0c             	mov    0xc(%ebp),%edi
  806ebd:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
        netif = netif->next;
      }
      if (netif == inp) {
        netif = netif->next;
      }
    } while(netif != NULL);
  806ec4:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  806ec7:	89 de                	mov    %ebx,%esi
  806ec9:	bb 01 00 00 00       	mov    $0x1,%ebx
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  806ece:	89 3c 24             	mov    %edi,(%esp)
  806ed1:	e8 79 dd ff ff       	call   804c4f <netif_is_up>
  806ed6:	84 c0                	test   %al,%al
  806ed8:	74 24                	je     806efe <ip_input+0xf4>
  806eda:	83 ff fc             	cmp    $0xfffffffc,%edi
  806edd:	74 1f                	je     806efe <ip_input+0xf4>
  806edf:	8b 47 04             	mov    0x4(%edi),%eax
  806ee2:	85 c0                	test   %eax,%eax
  806ee4:	74 18                	je     806efe <ip_input+0xf4>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806ee6:	3b 46 10             	cmp    0x10(%esi),%eax
  806ee9:	74 36                	je     806f21 <ip_input+0x117>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806eeb:	89 7c 24 04          	mov    %edi,0x4(%esp)
  806eef:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806ef2:	89 04 24             	mov    %eax,(%esp)
  806ef5:	e8 46 fc ff ff       	call   806b40 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806efa:	84 c0                	test   %al,%al
  806efc:	75 23                	jne    806f21 <ip_input+0x117>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  806efe:	85 db                	test   %ebx,%ebx
  806f00:	74 08                	je     806f0a <ip_input+0x100>
        first = 0;
        netif = netif_list;
  806f02:	8b 3d 34 b2 b3 00    	mov    0xb3b234,%edi
  806f08:	eb 02                	jmp    806f0c <ip_input+0x102>
      } else {
        netif = netif->next;
  806f0a:	8b 3f                	mov    (%edi),%edi
      }
      if (netif == inp) {
  806f0c:	3b 7d 0c             	cmp    0xc(%ebp),%edi
  806f0f:	75 05                	jne    806f16 <ip_input+0x10c>
        netif = netif->next;
  806f11:	8b 45 0c             	mov    0xc(%ebp),%eax
  806f14:	8b 38                	mov    (%eax),%edi
      }
    } while(netif != NULL);
  806f16:	85 ff                	test   %edi,%edi
  806f18:	74 12                	je     806f2c <ip_input+0x122>
  806f1a:	bb 00 00 00 00       	mov    $0x0,%ebx
  806f1f:	eb ad                	jmp    806ece <ip_input+0xc4>
  806f21:	89 f3                	mov    %esi,%ebx
  806f23:	8b 75 d4             	mov    -0x2c(%ebp),%esi
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  806f26:	85 ff                	test   %edi,%edi
  806f28:	75 2e                	jne    806f58 <ip_input+0x14e>
  806f2a:	eb 05                	jmp    806f31 <ip_input+0x127>
  806f2c:	89 f3                	mov    %esi,%ebx
  806f2e:	8b 75 d4             	mov    -0x2c(%ebp),%esi
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806f31:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806f35:	89 04 24             	mov    %eax,(%esp)
  806f38:	e8 2f 0f 00 00       	call   807e6c <ntohs>
  806f3d:	3c 11                	cmp    $0x11,%al
  806f3f:	75 17                	jne    806f58 <ip_input+0x14e>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  806f41:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  806f45:	0f b7 44 03 02       	movzwl 0x2(%ebx,%eax,1),%eax
  806f4a:	89 04 24             	mov    %eax,(%esp)
  806f4d:	e8 1a 0f 00 00       	call   807e6c <ntohs>
  806f52:	66 83 f8 44          	cmp    $0x44,%ax
  806f56:	74 4e                	je     806fa6 <ip_input+0x19c>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806f58:	8b 45 0c             	mov    0xc(%ebp),%eax
  806f5b:	89 44 24 04          	mov    %eax,0x4(%esp)
  806f5f:	8d 43 0c             	lea    0xc(%ebx),%eax
  806f62:	89 04 24             	mov    %eax,(%esp)
  806f65:	e8 d6 fb ff ff       	call   806b40 <ip_addr_isbroadcast>
  806f6a:	84 c0                	test   %al,%al
  806f6c:	75 2b                	jne    806f99 <ip_input+0x18f>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  806f6e:	8b 43 0c             	mov    0xc(%ebx),%eax
  806f71:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806f74:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  806f7b:	e8 0c 11 00 00       	call   80808c <ntohl>
  806f80:	89 45 e0             	mov    %eax,-0x20(%ebp)
  806f83:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806f8a:	e8 fd 10 00 00       	call   80808c <ntohl>
  806f8f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806f92:	23 55 dc             	and    -0x24(%ebp),%edx

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806f95:	39 c2                	cmp    %eax,%edx
  806f97:	75 10                	jne    806fa9 <ip_input+0x19f>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  806f99:	89 34 24             	mov    %esi,(%esp)
  806f9c:	e8 83 e2 ff ff       	call   805224 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  806fa1:	e9 00 01 00 00       	jmp    8070a6 <ip_input+0x29c>
  806fa6:	8b 7d 0c             	mov    0xc(%ebp),%edi
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  806fa9:	85 ff                	test   %edi,%edi
  806fab:	75 0d                	jne    806fba <ip_input+0x1b0>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  806fad:	89 34 24             	mov    %esi,(%esp)
  806fb0:	e8 6f e2 ff ff       	call   805224 <pbuf_free>
    return ERR_OK;
  806fb5:	e9 ec 00 00 00       	jmp    8070a6 <ip_input+0x29c>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806fba:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
  806fbe:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  806fc5:	e8 95 0e 00 00       	call   807e5f <htons>
  806fca:	66 85 f8             	test   %di,%ax
  806fcd:	74 15                	je     806fe4 <ip_input+0x1da>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  806fcf:	89 34 24             	mov    %esi,(%esp)
  806fd2:	e8 38 05 00 00       	call   80750f <ip_reass>
  806fd7:	89 c6                	mov    %eax,%esi
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  806fd9:	85 c0                	test   %eax,%eax
  806fdb:	0f 84 c5 00 00 00    	je     8070a6 <ip_input+0x29c>
      return ERR_OK;
    }
    iphdr = p->payload;
  806fe1:	8b 58 04             	mov    0x4(%eax),%ebx
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  806fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
  806fe7:	89 44 24 04          	mov    %eax,0x4(%esp)
  806feb:	89 34 24             	mov    %esi,(%esp)
  806fee:	e8 66 7b 00 00       	call   80eb59 <raw_input>
  806ff3:	84 c0                	test   %al,%al
  806ff5:	0f 85 ab 00 00 00    	jne    8070a6 <ip_input+0x29c>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  806ffb:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806fff:	89 04 24             	mov    %eax,(%esp)
  807002:	e8 65 0e 00 00       	call   807e6c <ntohs>
  807007:	0f b6 c0             	movzbl %al,%eax
  80700a:	83 f8 06             	cmp    $0x6,%eax
  80700d:	74 1d                	je     80702c <ip_input+0x222>
  80700f:	83 f8 11             	cmp    $0x11,%eax
  807012:	74 07                	je     80701b <ip_input+0x211>
  807014:	83 f8 01             	cmp    $0x1,%eax
  807017:	75 35                	jne    80704e <ip_input+0x244>
  807019:	eb 22                	jmp    80703d <ip_input+0x233>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  80701b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80701e:	89 44 24 04          	mov    %eax,0x4(%esp)
  807022:	89 34 24             	mov    %esi,(%esp)
  807025:	e8 84 25 00 00       	call   8095ae <udp_input>
      break;
  80702a:	eb 7a                	jmp    8070a6 <ip_input+0x29c>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  80702c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80702f:	89 44 24 04          	mov    %eax,0x4(%esp)
  807033:	89 34 24             	mov    %esi,(%esp)
  807036:	e8 6c 6b 00 00       	call   80dba7 <tcp_input>
      break;
  80703b:	eb 69                	jmp    8070a6 <ip_input+0x29c>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  80703d:	8b 45 0c             	mov    0xc(%ebp),%eax
  807040:	89 44 24 04          	mov    %eax,0x4(%esp)
  807044:	89 34 24             	mov    %esi,(%esp)
  807047:	e8 e8 7d 00 00       	call   80ee34 <icmp_input>
      break;
  80704c:	eb 58                	jmp    8070a6 <ip_input+0x29c>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  80704e:	8b 45 0c             	mov    0xc(%ebp),%eax
  807051:	89 44 24 04          	mov    %eax,0x4(%esp)
  807055:	8d 43 10             	lea    0x10(%ebx),%eax
  807058:	89 04 24             	mov    %eax,(%esp)
  80705b:	e8 e0 fa ff ff       	call   806b40 <ip_addr_isbroadcast>
  807060:	84 c0                	test   %al,%al
  807062:	75 3a                	jne    80709e <ip_input+0x294>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  807064:	8b 43 10             	mov    0x10(%ebx),%eax
  807067:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80706a:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  807071:	e8 16 10 00 00       	call   80808c <ntohl>
  807076:	89 c7                	mov    %eax,%edi
  807078:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80707f:	e8 08 10 00 00       	call   80808c <ntohl>
  807084:	23 7d e4             	and    -0x1c(%ebp),%edi
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  807087:	39 c7                	cmp    %eax,%edi
  807089:	74 13                	je     80709e <ip_input+0x294>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  80708b:	89 5e 04             	mov    %ebx,0x4(%esi)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  80708e:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  807095:	00 
  807096:	89 34 24             	mov    %esi,(%esp)
  807099:	e8 84 7c 00 00       	call   80ed22 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  80709e:	89 34 24             	mov    %esi,(%esp)
  8070a1:	e8 7e e1 ff ff       	call   805224 <pbuf_free>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  8070a6:	b8 00 00 00 00       	mov    $0x0,%eax
  8070ab:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8070ae:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8070b1:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8070b4:	89 ec                	mov    %ebp,%esp
  8070b6:	5d                   	pop    %ebp
  8070b7:	c3                   	ret    
	...

008070c0 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  8070c0:	55                   	push   %ebp
  8070c1:	89 e5                	mov    %esp,%ebp
  8070c3:	57                   	push   %edi
  8070c4:	56                   	push   %esi
  8070c5:	53                   	push   %ebx
  8070c6:	83 ec 5c             	sub    $0x5c,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  8070c9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8070cc:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  8070d0:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  8070d7:	00 
  8070d8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8070df:	00 
  8070e0:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8070e7:	e8 f3 e3 ff ff       	call   8054df <pbuf_alloc>
  8070ec:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if (rambuf == NULL) {
  8070ef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8070f4:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  8070f8:	0f 84 c8 01 00 00    	je     8072c6 <ip_frag+0x206>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  8070fe:	8b 55 d8             	mov    -0x28(%ebp),%edx
  807101:	66 89 72 0a          	mov    %si,0xa(%edx)
  807105:	66 89 72 08          	mov    %si,0x8(%edx)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  807109:	bb 23 44 b3 00       	mov    $0xb34423,%ebx
  80710e:	83 e3 fc             	and    $0xfffffffc,%ebx
  807111:	89 5a 04             	mov    %ebx,0x4(%edx)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  807114:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80711b:	00 
  80711c:	8b 55 08             	mov    0x8(%ebp),%edx
  80711f:	8b 42 04             	mov    0x4(%edx),%eax
  807122:	89 44 24 04          	mov    %eax,0x4(%esp)
  807126:	89 1c 24             	mov    %ebx,(%esp)
  807129:	e8 fd 89 00 00       	call   80fb2b <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  80712e:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  807132:	89 04 24             	mov    %eax,(%esp)
  807135:	e8 32 0d 00 00       	call   807e6c <ntohs>
  ofo = tmp & IP_OFFMASK;
  80713a:	89 c2                	mov    %eax,%edx
  80713c:	66 81 e2 ff 1f       	and    $0x1fff,%dx
  807141:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
  omf = tmp & IP_MF;
  807145:	66 25 00 20          	and    $0x2000,%ax
  807149:	66 89 45 b6          	mov    %ax,-0x4a(%ebp)

  left = p->tot_len - IP_HLEN;
  80714d:	8b 45 08             	mov    0x8(%ebp),%eax
  807150:	0f b7 78 08          	movzwl 0x8(%eax),%edi
  807154:	83 ef 14             	sub    $0x14,%edi

  nfb = (mtu - IP_HLEN) / 8;
  807157:	0f b7 c6             	movzwl %si,%eax
  80715a:	8d 50 f3             	lea    -0xd(%eax),%edx
  80715d:	83 e8 14             	sub    $0x14,%eax
  807160:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807163:	0f 48 c2             	cmovs  %edx,%eax
  807166:	c1 e8 03             	shr    $0x3,%eax
  807169:	66 89 45 b8          	mov    %ax,-0x48(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  80716d:	66 c7 45 e4 14 00    	movw   $0x14,-0x1c(%ebp)
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;
  807173:	c1 e0 03             	shl    $0x3,%eax
  807176:	66 89 45 ae          	mov    %ax,-0x52(%ebp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80717a:	8d 53 14             	lea    0x14(%ebx),%edx
  80717d:	89 55 b0             	mov    %edx,-0x50(%ebp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  807180:	e9 28 01 00 00       	jmp    8072ad <ip_frag+0x1ed>
    last = (left <= mtu - IP_HLEN);
  807185:	0f b7 c7             	movzwl %di,%eax
  807188:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80718b:	0f 9d c0             	setge  %al
  80718e:	0f b6 f0             	movzbl %al,%esi

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  807191:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807195:	66 25 ff 1f          	and    $0x1fff,%ax
  807199:	66 0b 45 b6          	or     -0x4a(%ebp),%ax
  80719d:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    if (!last)
  8071a1:	66 89 7d e6          	mov    %di,-0x1a(%ebp)
  8071a5:	66 85 f6             	test   %si,%si
  8071a8:	75 0e                	jne    8071b8 <ip_frag+0xf8>
      tmp = tmp | IP_MF;
  8071aa:	66 81 4d e0 00 20    	orw    $0x2000,-0x20(%ebp)
  8071b0:	0f b7 45 ae          	movzwl -0x52(%ebp),%eax
  8071b4:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8071b8:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8071bc:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8071c0:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8071c4:	89 44 24 08          	mov    %eax,0x8(%esp)
  8071c8:	8b 55 b0             	mov    -0x50(%ebp),%edx
  8071cb:	89 54 24 04          	mov    %edx,0x4(%esp)
  8071cf:	8b 45 08             	mov    0x8(%ebp),%eax
  8071d2:	89 04 24             	mov    %eax,(%esp)
  8071d5:	e8 e0 dd ff ff       	call   804fba <pbuf_copy_partial>
  8071da:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8071de:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  8071e2:	89 04 24             	mov    %eax,(%esp)
  8071e5:	e8 75 0c 00 00       	call   807e5f <htons>
  8071ea:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8071ee:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8071f2:	83 c0 14             	add    $0x14,%eax
  8071f5:	0f b7 c0             	movzwl %ax,%eax
  8071f8:	89 04 24             	mov    %eax,(%esp)
  8071fb:	e8 5f 0c 00 00       	call   807e5f <htons>
  807200:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  807204:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80720a:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  807211:	00 
  807212:	89 1c 24             	mov    %ebx,(%esp)
  807215:	e8 48 09 00 00       	call   807b62 <inet_chksum>
  80721a:	66 89 43 0a          	mov    %ax,0xa(%ebx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  80721e:	66 85 f6             	test   %si,%si
  807221:	74 15                	je     807238 <ip_frag+0x178>
      pbuf_realloc(rambuf, left + IP_HLEN);
  807223:	8d 47 14             	lea    0x14(%edi),%eax
  807226:	0f b7 c0             	movzwl %ax,%eax
  807229:	89 44 24 04          	mov    %eax,0x4(%esp)
  80722d:	8b 55 d8             	mov    -0x28(%ebp),%edx
  807230:	89 14 24             	mov    %edx,(%esp)
  807233:	e8 75 e1 ff ff       	call   8053ad <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  807238:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80723f:	00 
  807240:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807247:	00 
  807248:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80724f:	e8 8b e2 ff ff       	call   8054df <pbuf_alloc>
  807254:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  807256:	85 c0                	test   %eax,%eax
  807258:	74 41                	je     80729b <ip_frag+0x1db>

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80725a:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  80725e:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    if (header != NULL) {
      pbuf_chain(header, rambuf);
  807262:	8b 55 d8             	mov    -0x28(%ebp),%edx
  807265:	89 54 24 04          	mov    %edx,0x4(%esp)
  807269:	89 34 24             	mov    %esi,(%esp)
  80726c:	e8 2f dc ff ff       	call   804ea0 <pbuf_chain>
      netif->output(netif, header, dest);
  807271:	8b 45 10             	mov    0x10(%ebp),%eax
  807274:	89 44 24 08          	mov    %eax,0x8(%esp)
  807278:	89 74 24 04          	mov    %esi,0x4(%esp)
  80727c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80727f:	89 14 24             	mov    %edx,(%esp)
  807282:	ff 52 14             	call   *0x14(%edx)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  807285:	89 34 24             	mov    %esi,(%esp)
  807288:	e8 97 df ff ff       	call   805224 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  80728d:	66 2b 7d e6          	sub    -0x1a(%ebp),%di
    ofo += nfb;
  807291:	0f b7 45 b8          	movzwl -0x48(%ebp),%eax
  807295:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
  807299:	eb 12                	jmp    8072ad <ip_frag+0x1ed>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  80729b:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80729e:	89 14 24             	mov    %edx,(%esp)
  8072a1:	e8 7e df ff ff       	call   805224 <pbuf_free>
  8072a6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
  8072ab:	eb 19                	jmp    8072c6 <ip_frag+0x206>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  8072ad:	66 85 ff             	test   %di,%di
  8072b0:	0f 85 cf fe ff ff    	jne    807185 <ip_frag+0xc5>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  8072b6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8072b9:	89 04 24             	mov    %eax,(%esp)
  8072bc:	e8 63 df ff ff       	call   805224 <pbuf_free>
  8072c1:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  8072c6:	83 c4 5c             	add    $0x5c,%esp
  8072c9:	5b                   	pop    %ebx
  8072ca:	5e                   	pop    %esi
  8072cb:	5f                   	pop    %edi
  8072cc:	5d                   	pop    %ebp
  8072cd:	c3                   	ret    

008072ce <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  8072ce:	55                   	push   %ebp
  8072cf:	89 e5                	mov    %esp,%ebp
  8072d1:	83 ec 18             	sub    $0x18,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  8072d4:	8b 0d 00 44 b3 00    	mov    0xb34400,%ecx
  8072da:	39 c1                	cmp    %eax,%ecx
  8072dc:	75 0a                	jne    8072e8 <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  8072de:	8b 11                	mov    (%ecx),%edx
  8072e0:	89 15 00 44 b3 00    	mov    %edx,0xb34400
  8072e6:	eb 24                	jmp    80730c <ip_reass_dequeue_datagram+0x3e>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  8072e8:	85 d2                	test   %edx,%edx
  8072ea:	75 1c                	jne    807308 <ip_reass_dequeue_datagram+0x3a>
  8072ec:	c7 44 24 08 b1 20 81 	movl   $0x8120b1,0x8(%esp)
  8072f3:	00 
  8072f4:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
  8072fb:	00 
  8072fc:	c7 04 24 ca 20 81 00 	movl   $0x8120ca,(%esp)
  807303:	e8 e4 7e 00 00       	call   80f1ec <_panic>
    prev->next = ipr->next;
  807308:	8b 08                	mov    (%eax),%ecx
  80730a:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  80730c:	89 44 24 04          	mov    %eax,0x4(%esp)
  807310:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807317:	e8 a8 d7 ff ff       	call   804ac4 <memp_free>
}
  80731c:	c9                   	leave  
  80731d:	c3                   	ret    

0080731e <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  80731e:	55                   	push   %ebp
  80731f:	89 e5                	mov    %esp,%ebp
  807321:	57                   	push   %edi
  807322:	56                   	push   %esi
  807323:	53                   	push   %ebx
  807324:	83 ec 2c             	sub    $0x2c,%esp
  807327:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80732a:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  80732d:	39 c2                	cmp    %eax,%edx
  80732f:	75 1c                	jne    80734d <ip_reass_free_complete_datagram+0x2f>
  807331:	c7 44 24 08 e7 20 81 	movl   $0x8120e7,0x8(%esp)
  807338:	00 
  807339:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  807340:	00 
  807341:	c7 04 24 ca 20 81 00 	movl   $0x8120ca,(%esp)
  807348:	e8 9f 7e 00 00       	call   80f1ec <_panic>
  if (prev != NULL) {
  80734d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  807351:	74 26                	je     807379 <ip_reass_free_complete_datagram+0x5b>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  807353:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807356:	8b 45 e0             	mov    -0x20(%ebp),%eax
  807359:	39 10                	cmp    %edx,(%eax)
  80735b:	74 1c                	je     807379 <ip_reass_free_complete_datagram+0x5b>
  80735d:	c7 44 24 08 f3 20 81 	movl   $0x8120f3,0x8(%esp)
  807364:	00 
  807365:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  80736c:	00 
  80736d:	c7 04 24 ca 20 81 00 	movl   $0x8120ca,(%esp)
  807374:	e8 73 7e 00 00       	call   80f1ec <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  807379:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80737c:	8b 58 04             	mov    0x4(%eax),%ebx
  80737f:	8b 43 04             	mov    0x4(%ebx),%eax
  if (iprh->start == 0) {
  807382:	be 00 00 00 00       	mov    $0x0,%esi
  807387:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  80738c:	75 47                	jne    8073d5 <ip_reass_free_complete_datagram+0xb7>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  80738e:	8b 00                	mov    (%eax),%eax
  807390:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807393:	89 42 04             	mov    %eax,0x4(%edx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  807396:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80739d:	00 
  80739e:	89 d0                	mov    %edx,%eax
  8073a0:	83 c0 08             	add    $0x8,%eax
  8073a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8073a7:	8b 43 04             	mov    0x4(%ebx),%eax
  8073aa:	89 04 24             	mov    %eax,(%esp)
  8073ad:	e8 79 87 00 00       	call   80fb2b <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  8073b2:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8073b9:	00 
  8073ba:	89 1c 24             	mov    %ebx,(%esp)
  8073bd:	e8 4e 78 00 00       	call   80ec10 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  8073c2:	89 1c 24             	mov    %ebx,(%esp)
  8073c5:	e8 16 da ff ff       	call   804de0 <pbuf_clen>
  8073ca:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  8073cd:	89 1c 24             	mov    %ebx,(%esp)
  8073d0:	e8 4f de ff ff       	call   805224 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  8073d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8073d8:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  8073db:	eb 1c                	jmp    8073f9 <ip_reass_free_complete_datagram+0xdb>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  8073dd:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  8073e0:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  8073e2:	89 1c 24             	mov    %ebx,(%esp)
  8073e5:	e8 f6 d9 ff ff       	call   804de0 <pbuf_clen>
  8073ea:	0f b6 c0             	movzbl %al,%eax
  8073ed:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  8073ef:	89 1c 24             	mov    %ebx,(%esp)
  8073f2:	e8 2d de ff ff       	call   805224 <pbuf_free>
  8073f7:	89 fb                	mov    %edi,%ebx
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  8073f9:	85 db                	test   %ebx,%ebx
  8073fb:	75 e0                	jne    8073dd <ip_reass_free_complete_datagram+0xbf>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  8073fd:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807400:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807403:	e8 c6 fe ff ff       	call   8072ce <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  807408:	0f b7 05 04 44 b3 00 	movzwl 0xb34404,%eax
  80740f:	0f b7 d0             	movzwl %ax,%edx
  807412:	39 f2                	cmp    %esi,%edx
  807414:	7d 1c                	jge    807432 <ip_reass_free_complete_datagram+0x114>
  807416:	c7 44 24 08 05 21 81 	movl   $0x812105,0x8(%esp)
  80741d:	00 
  80741e:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  807425:	00 
  807426:	c7 04 24 ca 20 81 00 	movl   $0x8120ca,(%esp)
  80742d:	e8 ba 7d 00 00       	call   80f1ec <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  807432:	66 29 f0             	sub    %si,%ax
  807435:	66 a3 04 44 b3 00    	mov    %ax,0xb34404

  return pbufs_freed;
}
  80743b:	89 f0                	mov    %esi,%eax
  80743d:	83 c4 2c             	add    $0x2c,%esp
  807440:	5b                   	pop    %ebx
  807441:	5e                   	pop    %esi
  807442:	5f                   	pop    %edi
  807443:	5d                   	pop    %ebp
  807444:	c3                   	ret    

00807445 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  807445:	55                   	push   %ebp
  807446:	89 e5                	mov    %esp,%ebp
  807448:	57                   	push   %edi
  807449:	56                   	push   %esi
  80744a:	53                   	push   %ebx
  80744b:	83 ec 2c             	sub    $0x2c,%esp
  80744e:	89 c6                	mov    %eax,%esi
  807450:	89 55 e0             	mov    %edx,-0x20(%ebp)
  807453:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  80745a:	8b 0d 00 44 b3 00    	mov    0xb34400,%ecx
  807460:	bb 00 00 00 00       	mov    $0x0,%ebx
  807465:	ba 00 00 00 00       	mov    $0x0,%edx
  80746a:	b8 00 00 00 00       	mov    $0x0,%eax
  80746f:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
    while (r != NULL) {
  807472:	eb 38                	jmp    8074ac <ip_reass_remove_oldest_datagram+0x67>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  807474:	8b 79 14             	mov    0x14(%ecx),%edi
  807477:	3b 7e 0c             	cmp    0xc(%esi),%edi
  80747a:	75 12                	jne    80748e <ip_reass_remove_oldest_datagram+0x49>
  80747c:	8b 79 18             	mov    0x18(%ecx),%edi
  80747f:	3b 7e 10             	cmp    0x10(%esi),%edi
  807482:	75 0a                	jne    80748e <ip_reass_remove_oldest_datagram+0x49>
  807484:	0f b7 79 0c          	movzwl 0xc(%ecx),%edi
  807488:	66 3b 7e 04          	cmp    0x4(%esi),%di
  80748c:	74 15                	je     8074a3 <ip_reass_remove_oldest_datagram+0x5e>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  80748e:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
        if (oldest == NULL) {
  807492:	85 c0                	test   %eax,%eax
  807494:	74 0b                	je     8074a1 <ip_reass_remove_oldest_datagram+0x5c>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
  807496:	0f b6 79 1f          	movzbl 0x1f(%ecx),%edi
  80749a:	89 fb                	mov    %edi,%ebx
  80749c:	3a 58 1f             	cmp    0x1f(%eax),%bl
  80749f:	77 02                	ja     8074a3 <ip_reass_remove_oldest_datagram+0x5e>
  8074a1:	89 c8                	mov    %ecx,%eax
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  8074a3:	8b 39                	mov    (%ecx),%edi
  8074a5:	85 ff                	test   %edi,%edi
  8074a7:	0f 45 d1             	cmovne %ecx,%edx
  8074aa:	89 f9                	mov    %edi,%ecx
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  8074ac:	85 c9                	test   %ecx,%ecx
  8074ae:	75 c4                	jne    807474 <ip_reass_remove_oldest_datagram+0x2f>
  8074b0:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  8074b3:	85 c0                	test   %eax,%eax
  8074b5:	74 08                	je     8074bf <ip_reass_remove_oldest_datagram+0x7a>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  8074b7:	e8 62 fe ff ff       	call   80731e <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  8074bc:	01 45 e4             	add    %eax,-0x1c(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  8074bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8074c2:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  8074c5:	7d 05                	jge    8074cc <ip_reass_remove_oldest_datagram+0x87>
  8074c7:	83 fb 01             	cmp    $0x1,%ebx
  8074ca:	7f 8e                	jg     80745a <ip_reass_remove_oldest_datagram+0x15>
  return pbufs_freed;
}
  8074cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8074cf:	83 c4 2c             	add    $0x2c,%esp
  8074d2:	5b                   	pop    %ebx
  8074d3:	5e                   	pop    %esi
  8074d4:	5f                   	pop    %edi
  8074d5:	5d                   	pop    %ebp
  8074d6:	c3                   	ret    

008074d7 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  8074d7:	55                   	push   %ebp
  8074d8:	89 e5                	mov    %esp,%ebp
  8074da:	56                   	push   %esi
  8074db:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  8074dc:	a1 00 44 b3 00       	mov    0xb34400,%eax
  8074e1:	be 00 00 00 00       	mov    $0x0,%esi
  while (r != NULL) {
  8074e6:	eb 1f                	jmp    807507 <ip_reass_tmr+0x30>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  8074e8:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  8074ec:	84 d2                	test   %dl,%dl
  8074ee:	74 0c                	je     8074fc <ip_reass_tmr+0x25>
      r->timer--;
  8074f0:	83 ea 01             	sub    $0x1,%edx
  8074f3:	88 50 1f             	mov    %dl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
      r = r->next;
  8074f6:	8b 18                	mov    (%eax),%ebx
  8074f8:	89 c6                	mov    %eax,%esi
  8074fa:	eb 09                	jmp    807505 <ip_reass_tmr+0x2e>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  8074fc:	8b 18                	mov    (%eax),%ebx
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  8074fe:	89 f2                	mov    %esi,%edx
  807500:	e8 19 fe ff ff       	call   80731e <ip_reass_free_complete_datagram>
  807505:	89 d8                	mov    %ebx,%eax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  807507:	85 c0                	test   %eax,%eax
  807509:	75 dd                	jne    8074e8 <ip_reass_tmr+0x11>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  80750b:	5b                   	pop    %ebx
  80750c:	5e                   	pop    %esi
  80750d:	5d                   	pop    %ebp
  80750e:	c3                   	ret    

0080750f <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  80750f:	55                   	push   %ebp
  807510:	89 e5                	mov    %esp,%ebp
  807512:	57                   	push   %edi
  807513:	56                   	push   %esi
  807514:	53                   	push   %ebx
  807515:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  807518:	8b 45 08             	mov    0x8(%ebp),%eax
  80751b:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  80751e:	0f b7 03             	movzwl (%ebx),%eax
  807521:	89 04 24             	mov    %eax,(%esp)
  807524:	e8 43 09 00 00       	call   807e6c <ntohs>
  807529:	c1 e8 06             	shr    $0x6,%eax
  80752c:	83 e0 3c             	and    $0x3c,%eax
  80752f:	83 f8 14             	cmp    $0x14,%eax
  807532:	0f 85 6c 04 00 00    	jne    8079a4 <ip_reass+0x495>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  807538:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80753c:	89 04 24             	mov    %eax,(%esp)
  80753f:	e8 28 09 00 00       	call   807e6c <ntohs>
  807544:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  807548:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80754c:	89 04 24             	mov    %eax,(%esp)
  80754f:	e8 18 09 00 00       	call   807e6c <ntohs>
  807554:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
  807558:	0f b7 03             	movzwl (%ebx),%eax
  80755b:	89 04 24             	mov    %eax,(%esp)
  80755e:	e8 09 09 00 00       	call   807e6c <ntohs>
  807563:	66 89 45 de          	mov    %ax,-0x22(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  807567:	8b 55 08             	mov    0x8(%ebp),%edx
  80756a:	89 14 24             	mov    %edx,(%esp)
  80756d:	e8 6e d8 ff ff       	call   804de0 <pbuf_clen>
  807572:	89 c7                	mov    %eax,%edi
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  807574:	0f b6 c8             	movzbl %al,%ecx
  807577:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80757a:	0f b7 05 04 44 b3 00 	movzwl 0xb34404,%eax
  807581:	01 c8                	add    %ecx,%eax
  807583:	83 f8 0a             	cmp    $0xa,%eax
  807586:	7e 24                	jle    8075ac <ip_reass+0x9d>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  807588:	89 ca                	mov    %ecx,%edx
  80758a:	89 d8                	mov    %ebx,%eax
  80758c:	e8 b4 fe ff ff       	call   807445 <ip_reass_remove_oldest_datagram>
  807591:	85 c0                	test   %eax,%eax
  807593:	0f 84 0b 04 00 00    	je     8079a4 <ip_reass+0x495>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  807599:	0f b7 05 04 44 b3 00 	movzwl 0xb34404,%eax
  8075a0:	03 45 e0             	add    -0x20(%ebp),%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  8075a3:	83 f8 0a             	cmp    $0xa,%eax
  8075a6:	0f 8f f8 03 00 00    	jg     8079a4 <ip_reass+0x495>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  8075ac:	8b 35 00 44 b3 00    	mov    0xb34400,%esi
  8075b2:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  8075b9:	ba 00 00 00 00       	mov    $0x0,%edx
  8075be:	eb 22                	jmp    8075e2 <ip_reass+0xd3>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  8075c0:	8b 46 14             	mov    0x14(%esi),%eax
  8075c3:	3b 43 0c             	cmp    0xc(%ebx),%eax
  8075c6:	75 16                	jne    8075de <ip_reass+0xcf>
  8075c8:	8b 46 18             	mov    0x18(%esi),%eax
  8075cb:	3b 43 10             	cmp    0x10(%ebx),%eax
  8075ce:	75 0e                	jne    8075de <ip_reass+0xcf>
  8075d0:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8075d4:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  8075d8:	0f 84 88 00 00 00    	je     807666 <ip_reass+0x157>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  8075de:	89 f2                	mov    %esi,%edx
  8075e0:	8b 36                	mov    (%esi),%esi
  8075e2:	85 f6                	test   %esi,%esi
  8075e4:	75 da                	jne    8075c0 <ip_reass+0xb1>
  8075e6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  8075e9:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  8075f0:	e8 13 d5 ff ff       	call   804b08 <memp_malloc>
  8075f5:	89 c6                	mov    %eax,%esi
  if (ipr == NULL) {
  8075f7:	85 c0                	test   %eax,%eax
  8075f9:	75 29                	jne    807624 <ip_reass+0x115>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  8075fb:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8075fe:	89 d8                	mov    %ebx,%eax
  807600:	e8 40 fe ff ff       	call   807445 <ip_reass_remove_oldest_datagram>
  807605:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  807608:	0f 8f 96 03 00 00    	jg     8079a4 <ip_reass+0x495>
      ipr = memp_malloc(MEMP_REASSDATA);
  80760e:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807615:	e8 ee d4 ff ff       	call   804b08 <memp_malloc>
  80761a:	89 c6                	mov    %eax,%esi
    }
    if (ipr == NULL)
  80761c:	85 c0                	test   %eax,%eax
  80761e:	0f 84 80 03 00 00    	je     8079a4 <ip_reass+0x495>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  807624:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80762b:	00 
  80762c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807633:	00 
  807634:	89 34 24             	mov    %esi,(%esp)
  807637:	e8 14 84 00 00       	call   80fa50 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  80763c:	c6 46 1f 03          	movb   $0x3,0x1f(%esi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  807640:	a1 00 44 b3 00       	mov    0xb34400,%eax
  807645:	89 06                	mov    %eax,(%esi)
  reassdatagrams = ipr;
  807647:	89 35 00 44 b3 00    	mov    %esi,0xb34400
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  80764d:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  807654:	00 
  807655:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  807659:	8d 46 08             	lea    0x8(%esi),%eax
  80765c:	89 04 24             	mov    %eax,(%esp)
  80765f:	e8 c7 84 00 00       	call   80fb2b <memcpy>
  807664:	eb 47                	jmp    8076ad <ip_reass+0x19e>
  807666:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  807669:	89 75 e0             	mov    %esi,-0x20(%ebp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80766c:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  807670:	89 04 24             	mov    %eax,(%esp)
  807673:	e8 f4 07 00 00       	call   807e6c <ntohs>
  807678:	66 a9 ff 1f          	test   $0x1fff,%ax
  80767c:	75 2f                	jne    8076ad <ip_reass+0x19e>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  80767e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807681:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
  807685:	89 04 24             	mov    %eax,(%esp)
  807688:	e8 df 07 00 00       	call   807e6c <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80768d:	66 a9 ff 1f          	test   $0x1fff,%ax
  807691:	74 1a                	je     8076ad <ip_reass+0x19e>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  807693:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80769a:	00 
  80769b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80769f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8076a2:	83 c0 08             	add    $0x8,%eax
  8076a5:	89 04 24             	mov    %eax,(%esp)
  8076a8:	e8 7e 84 00 00       	call   80fb2b <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  8076ad:	66 81 e7 ff 00       	and    $0xff,%di
  8076b2:	66 01 3d 04 44 b3 00 	add    %di,0xb34404

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  8076b9:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  8076bd:	89 04 24             	mov    %eax,(%esp)
  8076c0:	e8 a7 07 00 00       	call   807e6c <ntohs>
  8076c5:	f6 c4 20             	test   $0x20,%ah
  8076c8:	75 21                	jne    8076eb <ip_reass+0x1dc>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  8076ca:	80 4e 1e 01          	orb    $0x1,0x1e(%esi)
    ipr->datagram_len = offset + len;
  8076ce:	0f b7 4d d0          	movzwl -0x30(%ebp),%ecx
  8076d2:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  8076d6:	8d 04 ca             	lea    (%edx,%ecx,8),%eax
  8076d9:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  8076dd:	66 c1 ea 06          	shr    $0x6,%dx
  8076e1:	83 e2 3c             	and    $0x3c,%edx
  8076e4:	66 29 d0             	sub    %dx,%ax
  8076e7:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  8076eb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8076ee:	8b 59 04             	mov    0x4(%ecx),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  8076f1:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  8076f5:	89 04 24             	mov    %eax,(%esp)
  8076f8:	e8 6f 07 00 00       	call   807e6c <ntohs>
  8076fd:	89 c7                	mov    %eax,%edi
  8076ff:	0f b7 03             	movzwl (%ebx),%eax
  807702:	89 04 24             	mov    %eax,(%esp)
  807705:	e8 62 07 00 00       	call   807e6c <ntohs>
  80770a:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80770e:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  807712:	89 04 24             	mov    %eax,(%esp)
  807715:	e8 52 07 00 00       	call   807e6c <ntohs>
  80771a:	c1 e0 03             	shl    $0x3,%eax
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  80771d:	8b 55 08             	mov    0x8(%ebp),%edx
  807720:	8b 52 04             	mov    0x4(%edx),%edx
  807723:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  807726:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  80772c:	66 89 42 04          	mov    %ax,0x4(%edx)
  iprh->end = offset + len;
  807730:	8d 0c 38             	lea    (%eax,%edi,1),%ecx
  807733:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  807737:	66 c1 ea 06          	shr    $0x6,%dx
  80773b:	83 e2 3c             	and    $0x3c,%edx
  80773e:	66 29 d1             	sub    %dx,%cx
  807741:	66 89 4d de          	mov    %cx,-0x22(%ebp)
  807745:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807748:	66 89 4a 06          	mov    %cx,0x6(%edx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  80774c:	8b 4e 04             	mov    0x4(%esi),%ecx
  80774f:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  807752:	89 cb                	mov    %ecx,%ebx
  807754:	b9 01 00 00 00       	mov    $0x1,%ecx
  807759:	bf 00 00 00 00       	mov    $0x0,%edi
  80775e:	89 75 d0             	mov    %esi,-0x30(%ebp)
  807761:	89 ce                	mov    %ecx,%esi
  807763:	eb 74                	jmp    8077d9 <ip_reass+0x2ca>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  807765:	8b 53 04             	mov    0x4(%ebx),%edx
    if (iprh->start < iprh_tmp->start) {
  807768:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  80776c:	66 39 c8             	cmp    %cx,%ax
  80776f:	73 41                	jae    8077b2 <ip_reass+0x2a3>
  807771:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  807774:	89 f1                	mov    %esi,%ecx
  807776:	8b 75 d0             	mov    -0x30(%ebp),%esi
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  807779:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80777c:	89 1a                	mov    %ebx,(%edx)
      if (iprh_prev != NULL) {
  80777e:	85 ff                	test   %edi,%edi
  807780:	74 25                	je     8077a7 <ip_reass+0x298>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  807782:	66 3b 47 06          	cmp    0x6(%edi),%ax
  807786:	0f 82 92 01 00 00    	jb     80791e <ip_reass+0x40f>
  80778c:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  807790:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807793:	66 3b 50 04          	cmp    0x4(%eax),%dx
  807797:	0f 87 81 01 00 00    	ja     80791e <ip_reass+0x40f>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  80779d:	8b 45 08             	mov    0x8(%ebp),%eax
  8077a0:	89 07                	mov    %eax,(%edi)
  8077a2:	e9 a6 00 00 00       	jmp    80784d <ip_reass+0x33e>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  8077a7:	8b 55 08             	mov    0x8(%ebp),%edx
  8077aa:	89 56 04             	mov    %edx,0x4(%esi)
  8077ad:	e9 9b 00 00 00       	jmp    80784d <ip_reass+0x33e>
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  8077b2:	66 39 c8             	cmp    %cx,%ax
  8077b5:	0f 84 63 01 00 00    	je     80791e <ip_reass+0x40f>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  8077bb:	66 3b 42 06          	cmp    0x6(%edx),%ax
  8077bf:	0f 82 59 01 00 00    	jb     80791e <ip_reass+0x40f>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  8077c5:	85 ff                	test   %edi,%edi
  8077c7:	74 0c                	je     8077d5 <ip_reass+0x2c6>
        if (iprh_prev->end != iprh_tmp->start) {
  8077c9:	66 3b 4f 06          	cmp    0x6(%edi),%cx
  8077cd:	b9 00 00 00 00       	mov    $0x0,%ecx
  8077d2:	0f 45 f1             	cmovne %ecx,%esi
           * and the previous fragment */
          valid = 0;
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  8077d5:	8b 1a                	mov    (%edx),%ebx
  8077d7:	89 d7                	mov    %edx,%edi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  8077d9:	85 db                	test   %ebx,%ebx
  8077db:	75 88                	jne    807765 <ip_reass+0x256>
  8077dd:	e9 e8 01 00 00       	jmp    8079ca <ip_reass+0x4bb>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  8077e2:	0f b7 47 06          	movzwl 0x6(%edi),%eax
  8077e6:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8077e9:	66 3b 42 04          	cmp    0x4(%edx),%ax
  8077ed:	76 1c                	jbe    80780b <ip_reass+0x2fc>
  8077ef:	c7 44 24 08 20 21 81 	movl   $0x812120,0x8(%esp)
  8077f6:	00 
  8077f7:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp)
  8077fe:	00 
  8077ff:	c7 04 24 ca 20 81 00 	movl   $0x8120ca,(%esp)
  807806:	e8 e1 79 00 00       	call   80f1ec <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  80780b:	8b 45 08             	mov    0x8(%ebp),%eax
  80780e:	89 07                	mov    %eax,(%edi)
      if (iprh_prev->end != iprh->start) {
  807810:	0f b7 47 06          	movzwl 0x6(%edi),%eax
  807814:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807817:	66 3b 42 04          	cmp    0x4(%edx),%ax
  80781b:	b8 00 00 00 00       	mov    $0x0,%eax
  807820:	0f 45 c8             	cmovne %eax,%ecx
  807823:	eb 28                	jmp    80784d <ip_reass+0x33e>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  807825:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  807829:	74 1c                	je     807847 <ip_reass+0x338>
  80782b:	c7 44 24 08 4c 21 81 	movl   $0x81214c,0x8(%esp)
  807832:	00 
  807833:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  80783a:	00 
  80783b:	c7 04 24 ca 20 81 00 	movl   $0x8120ca,(%esp)
  807842:	e8 a5 79 00 00       	call   80f1ec <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  807847:	8b 45 08             	mov    0x8(%ebp),%eax
  80784a:	89 46 04             	mov    %eax,0x4(%esi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  80784d:	f6 46 1e 01          	testb  $0x1,0x1e(%esi)
  807851:	0f 84 61 01 00 00    	je     8079b8 <ip_reass+0x4a9>
    /* and had no wholes so far */
    if (valid) {
  807857:	85 c9                	test   %ecx,%ecx
  807859:	0f 84 59 01 00 00    	je     8079b8 <ip_reass+0x4a9>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  80785f:	8b 5e 04             	mov    0x4(%esi),%ebx
  807862:	8b 4b 04             	mov    0x4(%ebx),%ecx
  807865:	66 83 79 04 00       	cmpw   $0x0,0x4(%ecx)
  80786a:	0f 85 48 01 00 00    	jne    8079b8 <ip_reass+0x4a9>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  807870:	8b 45 e0             	mov    -0x20(%ebp),%eax
  807873:	8b 10                	mov    (%eax),%edx
  807875:	89 c7                	mov    %eax,%edi
  807877:	eb 15                	jmp    80788e <ip_reass+0x37f>
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  807879:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  80787c:	0f b7 57 06          	movzwl 0x6(%edi),%edx
  807880:	66 3b 50 04          	cmp    0x4(%eax),%dx
  807884:	0f 85 2e 01 00 00    	jne    8079b8 <ip_reass+0x4a9>
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  80788a:	8b 10                	mov    (%eax),%edx
  80788c:	89 c7                	mov    %eax,%edi
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  80788e:	85 d2                	test   %edx,%edx
  807890:	75 e7                	jne    807879 <ip_reass+0x36a>
  807892:	e9 45 01 00 00       	jmp    8079dc <ip_reass+0x4cd>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  807897:	c7 44 24 08 3e 21 81 	movl   $0x81213e,0x8(%esp)
  80789e:	00 
  80789f:	c7 44 24 04 ac 01 00 	movl   $0x1ac,0x4(%esp)
  8078a6:	00 
  8078a7:	c7 04 24 ca 20 81 00 	movl   $0x8120ca,(%esp)
  8078ae:	e8 39 79 00 00       	call   80f1ec <_panic>
          LWIP_ASSERT("sanity check",
  8078b3:	39 c1                	cmp    %eax,%ecx
  8078b5:	75 1c                	jne    8078d3 <ip_reass+0x3c4>
  8078b7:	c7 44 24 08 3e 21 81 	movl   $0x81213e,0x8(%esp)
  8078be:	00 
  8078bf:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp)
  8078c6:	00 
  8078c7:	c7 04 24 ca 20 81 00 	movl   $0x8120ca,(%esp)
  8078ce:	e8 19 79 00 00       	call   80f1ec <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  8078d3:	83 38 00             	cmpl   $0x0,(%eax)
  8078d6:	74 1c                	je     8078f4 <ip_reass+0x3e5>
  8078d8:	c7 44 24 08 84 21 81 	movl   $0x812184,0x8(%esp)
  8078df:	00 
  8078e0:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
  8078e7:	00 
  8078e8:	c7 04 24 ca 20 81 00 	movl   $0x8120ca,(%esp)
  8078ef:	e8 f8 78 00 00       	call   80f1ec <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  8078f4:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  8078f8:	66 3b 46 1c          	cmp    0x1c(%esi),%ax
  8078fc:	0f 84 e9 00 00 00    	je     8079eb <ip_reass+0x4dc>
  807902:	c7 44 24 08 a8 21 81 	movl   $0x8121a8,0x8(%esp)
  807909:	00 
  80790a:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  807911:	00 
  807912:	c7 04 24 ca 20 81 00 	movl   $0x8120ca,(%esp)
  807919:	e8 ce 78 00 00       	call   80f1ec <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  80791e:	0f b7 1d 04 44 b3 00 	movzwl 0xb34404,%ebx
  807925:	8b 55 08             	mov    0x8(%ebp),%edx
  807928:	89 14 24             	mov    %edx,(%esp)
  80792b:	e8 b0 d4 ff ff       	call   804de0 <pbuf_clen>
  807930:	0f b6 c0             	movzbl %al,%eax
  807933:	66 29 c3             	sub    %ax,%bx
  807936:	66 89 1d 04 44 b3 00 	mov    %bx,0xb34404
  pbuf_free(new_p);
  80793d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807940:	89 0c 24             	mov    %ecx,(%esp)
  807943:	e8 dc d8 ff ff       	call   805224 <pbuf_free>
  807948:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80794f:	eb 6e                	jmp    8079bf <ip_reass+0x4b0>

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
  807951:	8b 5f 04             	mov    0x4(%edi),%ebx

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  807954:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80795b:	ff 
  80795c:	89 3c 24             	mov    %edi,(%esp)
  80795f:	e8 63 d5 ff ff       	call   804ec7 <pbuf_header>
      pbuf_cat(p, r);
  807964:	89 7c 24 04          	mov    %edi,0x4(%esp)
  807968:	89 34 24             	mov    %esi,(%esp)
  80796b:	e8 99 d4 ff ff       	call   804e09 <pbuf_cat>
      r = iprh->next_pbuf;
  807970:	8b 3b                	mov    (%ebx),%edi
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807972:	85 ff                	test   %edi,%edi
  807974:	75 db                	jne    807951 <ip_reass+0x442>
  807976:	8b 75 e0             	mov    -0x20(%ebp),%esi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  807979:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80797c:	89 f0                	mov    %esi,%eax
  80797e:	e8 4b f9 ff ff       	call   8072ce <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  807983:	0f b7 1d 04 44 b3 00 	movzwl 0xb34404,%ebx
  80798a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80798d:	89 04 24             	mov    %eax,(%esp)
  807990:	e8 4b d4 ff ff       	call   804de0 <pbuf_clen>
  807995:	0f b6 c0             	movzbl %al,%eax
  807998:	66 29 c3             	sub    %ax,%bx
  80799b:	66 89 1d 04 44 b3 00 	mov    %bx,0xb34404

    /* Return the pbuf chain */
    return p;
  8079a2:	eb 1b                	jmp    8079bf <ip_reass+0x4b0>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  8079a4:	8b 55 08             	mov    0x8(%ebp),%edx
  8079a7:	89 14 24             	mov    %edx,(%esp)
  8079aa:	e8 75 d8 ff ff       	call   805224 <pbuf_free>
  8079af:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  return NULL;
  8079b6:	eb 07                	jmp    8079bf <ip_reass+0x4b0>
  8079b8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  8079bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8079c2:	83 c4 3c             	add    $0x3c,%esp
  8079c5:	5b                   	pop    %ebx
  8079c6:	5e                   	pop    %esi
  8079c7:	5f                   	pop    %edi
  8079c8:	5d                   	pop    %ebp
  8079c9:	c3                   	ret    
  8079ca:	89 f1                	mov    %esi,%ecx
  8079cc:	8b 75 d0             	mov    -0x30(%ebp),%esi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  8079cf:	85 ff                	test   %edi,%edi
  8079d1:	0f 85 0b fe ff ff    	jne    8077e2 <ip_reass+0x2d3>
  8079d7:	e9 49 fe ff ff       	jmp    807825 <ip_reass+0x316>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  8079dc:	85 db                	test   %ebx,%ebx
  8079de:	66 90                	xchg   %ax,%ax
  8079e0:	0f 85 cd fe ff ff    	jne    8078b3 <ip_reass+0x3a4>
  8079e6:	e9 ac fe ff ff       	jmp    807897 <ip_reass+0x388>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  8079eb:	83 c0 14             	add    $0x14,%eax
  8079ee:	66 89 46 1c          	mov    %ax,0x1c(%esi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  8079f2:	8b 46 04             	mov    0x4(%esi),%eax
  8079f5:	8b 58 04             	mov    0x4(%eax),%ebx
  8079f8:	8b 3b                	mov    (%ebx),%edi

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  8079fa:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  807a01:	00 
  807a02:	8d 46 08             	lea    0x8(%esi),%eax
  807a05:	89 44 24 04          	mov    %eax,0x4(%esp)
  807a09:	89 1c 24             	mov    %ebx,(%esp)
  807a0c:	e8 1a 81 00 00       	call   80fb2b <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  807a11:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  807a15:	89 04 24             	mov    %eax,(%esp)
  807a18:	e8 42 04 00 00       	call   807e5f <htons>
  807a1d:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(fraghdr, 0);
  807a21:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_CHKSUM_SET(fraghdr, 0);
  807a27:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  807a2d:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  807a34:	00 
  807a35:	89 1c 24             	mov    %ebx,(%esp)
  807a38:	e8 25 01 00 00       	call   807b62 <inet_chksum>
  807a3d:	66 89 43 0a          	mov    %ax,0xa(%ebx)

    p = ipr->p;
  807a41:	8b 4e 04             	mov    0x4(%esi),%ecx
  807a44:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  807a47:	89 75 e0             	mov    %esi,-0x20(%ebp)
  807a4a:	89 ce                	mov    %ecx,%esi

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807a4c:	e9 21 ff ff ff       	jmp    807972 <ip_reass+0x463>
  807a51:	00 00                	add    %al,(%eax)
	...

00807a54 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  807a54:	55                   	push   %ebp
  807a55:	89 e5                	mov    %esp,%ebp
  807a57:	57                   	push   %edi
  807a58:	56                   	push   %esi
  807a59:	53                   	push   %ebx
  807a5a:	83 ec 2c             	sub    $0x2c,%esp
  807a5d:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  807a61:	89 c1                	mov    %eax,%ecx
  807a63:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (len > 1) {
  807a68:	eb 17                	jmp    807a81 <lwip_standard_chksum+0x2d>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  807a6a:	0f b6 39             	movzbl (%ecx),%edi
  807a6d:	c1 e7 08             	shl    $0x8,%edi
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  807a70:	0f b6 71 01          	movzbl 0x1(%ecx),%esi
  807a74:	09 fe                	or     %edi,%esi
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  807a76:	83 c1 02             	add    $0x2,%ecx
    src = (*octetptr) << 8;
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
    octetptr++;
    acc += src;
  807a79:	0f b7 f6             	movzwl %si,%esi
  807a7c:	01 f3                	add    %esi,%ebx
    len -= 2;
  807a7e:	83 ea 02             	sub    $0x2,%edx
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  807a81:	66 83 fa 01          	cmp    $0x1,%dx
  807a85:	77 e3                	ja     807a6a <lwip_standard_chksum+0x16>
  807a87:	89 d9                	mov    %ebx,%ecx
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  807a89:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  807a8d:	66 d1 ea             	shr    %dx
  807a90:	0f b7 f2             	movzwl %dx,%esi
  807a93:	8d 04 70             	lea    (%eax,%esi,2),%eax
  807a96:	01 d2                	add    %edx,%edx
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  807a98:	66 39 55 e6          	cmp    %dx,-0x1a(%ebp)
  807a9c:	74 0c                	je     807aaa <lwip_standard_chksum+0x56>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    acc += src;
  807a9e:	0f b6 18             	movzbl (%eax),%ebx
  807aa1:	c1 e3 08             	shl    $0x8,%ebx
  807aa4:	0f b7 db             	movzwl %bx,%ebx
  807aa7:	8d 1c 19             	lea    (%ecx,%ebx,1),%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807aaa:	89 d8                	mov    %ebx,%eax
  807aac:	c1 e8 10             	shr    $0x10,%eax
  807aaf:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  807ab5:	01 c3                	add    %eax,%ebx
  if ((acc & 0xffff0000) != 0) {
  807ab7:	f7 c3 00 00 ff ff    	test   $0xffff0000,%ebx
  807abd:	74 0d                	je     807acc <lwip_standard_chksum+0x78>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807abf:	89 d8                	mov    %ebx,%eax
  807ac1:	c1 e8 10             	shr    $0x10,%eax
  807ac4:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  807aca:	01 c3                	add    %eax,%ebx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  807acc:	0f b7 db             	movzwl %bx,%ebx
  807acf:	89 1c 24             	mov    %ebx,(%esp)
  807ad2:	e8 88 03 00 00       	call   807e5f <htons>
}
  807ad7:	83 c4 2c             	add    $0x2c,%esp
  807ada:	5b                   	pop    %ebx
  807adb:	5e                   	pop    %esi
  807adc:	5f                   	pop    %edi
  807add:	5d                   	pop    %ebp
  807ade:	c3                   	ret    

00807adf <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  807adf:	55                   	push   %ebp
  807ae0:	89 e5                	mov    %esp,%ebp
  807ae2:	57                   	push   %edi
  807ae3:	56                   	push   %esi
  807ae4:	53                   	push   %ebx
  807ae5:	83 ec 0c             	sub    $0xc,%esp
  807ae8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807aeb:	bf 00 00 00 00       	mov    $0x0,%edi
  807af0:	be 00 00 00 00       	mov    $0x0,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807af5:	eb 43                	jmp    807b3a <inet_chksum_pbuf+0x5b>
    acc += LWIP_CHKSUM(q->payload, q->len);
  807af7:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807afb:	8b 43 04             	mov    0x4(%ebx),%eax
  807afe:	e8 51 ff ff ff       	call   807a54 <lwip_standard_chksum>
  807b03:	0f b7 c0             	movzwl %ax,%eax
  807b06:	8d 34 30             	lea    (%eax,%esi,1),%esi
    acc = FOLD_U32T(acc);
  807b09:	89 f0                	mov    %esi,%eax
  807b0b:	c1 e8 10             	shr    $0x10,%eax
  807b0e:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  807b14:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  807b16:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807b1a:	74 1c                	je     807b38 <inet_chksum_pbuf+0x59>
      swapped = 1 - swapped;
  807b1c:	b8 01 00 00 00       	mov    $0x1,%eax
  807b21:	89 fa                	mov    %edi,%edx
  807b23:	28 d0                	sub    %dl,%al
  807b25:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807b27:	89 f0                	mov    %esi,%eax
  807b29:	c1 e0 08             	shl    $0x8,%eax
  807b2c:	25 ff ff 00 00       	and    $0xffff,%eax
  807b31:	89 f2                	mov    %esi,%edx
  807b33:	0f b6 f6             	movzbl %dh,%esi
  807b36:	09 c6                	or     %eax,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807b38:	8b 1b                	mov    (%ebx),%ebx
  807b3a:	85 db                	test   %ebx,%ebx
  807b3c:	75 b9                	jne    807af7 <inet_chksum_pbuf+0x18>
  807b3e:	89 f0                	mov    %esi,%eax
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  807b40:	89 fa                	mov    %edi,%edx
  807b42:	84 d2                	test   %dl,%dl
  807b44:	74 10                	je     807b56 <inet_chksum_pbuf+0x77>
    acc = SWAP_BYTES_IN_WORD(acc);
  807b46:	89 f2                	mov    %esi,%edx
  807b48:	c1 e2 08             	shl    $0x8,%edx
  807b4b:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  807b51:	0f b6 f4             	movzbl %ah,%esi
  807b54:	09 d6                	or     %edx,%esi
  807b56:	89 f0                	mov    %esi,%eax
  807b58:	f7 d0                	not    %eax
  }
  return (u16_t)~(acc & 0xffffUL);
}
  807b5a:	83 c4 0c             	add    $0xc,%esp
  807b5d:	5b                   	pop    %ebx
  807b5e:	5e                   	pop    %esi
  807b5f:	5f                   	pop    %edi
  807b60:	5d                   	pop    %ebp
  807b61:	c3                   	ret    

00807b62 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  807b62:	55                   	push   %ebp
  807b63:	89 e5                	mov    %esp,%ebp
  807b65:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  807b68:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  807b6c:	8b 45 08             	mov    0x8(%ebp),%eax
  807b6f:	e8 e0 fe ff ff       	call   807a54 <lwip_standard_chksum>
  807b74:	f7 d0                	not    %eax
}
  807b76:	c9                   	leave  
  807b77:	c3                   	ret    

00807b78 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  807b78:	55                   	push   %ebp
  807b79:	89 e5                	mov    %esp,%ebp
  807b7b:	57                   	push   %edi
  807b7c:	56                   	push   %esi
  807b7d:	53                   	push   %ebx
  807b7e:	83 ec 2c             	sub    $0x2c,%esp
  807b81:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  807b85:	88 45 e7             	mov    %al,-0x19(%ebp)
  807b88:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  807b8c:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  807b90:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807b93:	bf 00 00 00 00       	mov    $0x0,%edi
  807b98:	be 00 00 00 00       	mov    $0x0,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807b9d:	eb 43                	jmp    807be2 <inet_chksum_pseudo+0x6a>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  807b9f:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807ba3:	8b 43 04             	mov    0x4(%ebx),%eax
  807ba6:	e8 a9 fe ff ff       	call   807a54 <lwip_standard_chksum>
  807bab:	0f b7 c0             	movzwl %ax,%eax
  807bae:	8d 34 30             	lea    (%eax,%esi,1),%esi
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  807bb1:	89 f0                	mov    %esi,%eax
  807bb3:	c1 e8 10             	shr    $0x10,%eax
  807bb6:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  807bbc:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  807bbe:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807bc2:	74 1c                	je     807be0 <inet_chksum_pseudo+0x68>
      swapped = 1 - swapped;
  807bc4:	b8 01 00 00 00       	mov    $0x1,%eax
  807bc9:	89 fa                	mov    %edi,%edx
  807bcb:	28 d0                	sub    %dl,%al
  807bcd:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807bcf:	89 f0                	mov    %esi,%eax
  807bd1:	c1 e0 08             	shl    $0x8,%eax
  807bd4:	25 ff ff 00 00       	and    $0xffff,%eax
  807bd9:	89 f2                	mov    %esi,%edx
  807bdb:	0f b6 f6             	movzbl %dh,%esi
  807bde:	09 c6                	or     %eax,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807be0:	8b 1b                	mov    (%ebx),%ebx
  807be2:	85 db                	test   %ebx,%ebx
  807be4:	75 b9                	jne    807b9f <inet_chksum_pseudo+0x27>
  807be6:	89 f0                	mov    %esi,%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807be8:	89 fa                	mov    %edi,%edx
  807bea:	84 d2                	test   %dl,%dl
  807bec:	74 10                	je     807bfe <inet_chksum_pseudo+0x86>
    acc = SWAP_BYTES_IN_WORD(acc);
  807bee:	89 f2                	mov    %esi,%edx
  807bf0:	c1 e2 08             	shl    $0x8,%edx
  807bf3:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  807bf9:	0f b6 f4             	movzbl %ah,%esi
  807bfc:	09 d6                	or     %edx,%esi
  }
  acc += (src->addr & 0xffffUL);
  807bfe:	8b 45 0c             	mov    0xc(%ebp),%eax
  807c01:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807c03:	8b 45 10             	mov    0x10(%ebp),%eax
  807c06:	8b 00                	mov    (%eax),%eax
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  807c08:	89 d1                	mov    %edx,%ecx
  807c0a:	c1 e9 10             	shr    $0x10,%ecx
  807c0d:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  807c13:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  807c16:	0f b7 c8             	movzwl %ax,%ecx
  807c19:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  807c1b:	c1 e8 10             	shr    $0x10,%eax
  807c1e:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807c21:	8d 34 30             	lea    (%eax,%esi,1),%esi
  acc += (u32_t)htons((u16_t)proto);
  807c24:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  807c28:	89 04 24             	mov    %eax,(%esp)
  807c2b:	e8 2f 02 00 00       	call   807e5f <htons>
  807c30:	0f b7 c0             	movzwl %ax,%eax
  807c33:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons(proto_len);
  807c35:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807c39:	89 04 24             	mov    %eax,(%esp)
  807c3c:	e8 1e 02 00 00       	call   807e5f <htons>
  807c41:	0f b7 c0             	movzwl %ax,%eax
  807c44:	01 c6                	add    %eax,%esi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807c46:	89 f0                	mov    %esi,%eax
  807c48:	c1 e8 10             	shr    $0x10,%eax
  807c4b:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  807c51:	01 c6                	add    %eax,%esi
  acc = FOLD_U32T(acc);
  807c53:	89 f0                	mov    %esi,%eax
  807c55:	c1 e8 10             	shr    $0x10,%eax
  807c58:	8d 04 06             	lea    (%esi,%eax,1),%eax
  807c5b:	f7 d0                	not    %eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  807c5d:	83 c4 2c             	add    $0x2c,%esp
  807c60:	5b                   	pop    %ebx
  807c61:	5e                   	pop    %esi
  807c62:	5f                   	pop    %edi
  807c63:	5d                   	pop    %ebp
  807c64:	c3                   	ret    

00807c65 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  807c65:	55                   	push   %ebp
  807c66:	89 e5                	mov    %esp,%ebp
  807c68:	57                   	push   %edi
  807c69:	56                   	push   %esi
  807c6a:	53                   	push   %ebx
  807c6b:	83 ec 3c             	sub    $0x3c,%esp
  807c6e:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  807c72:	88 45 d6             	mov    %al,-0x2a(%ebp)
  807c75:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  807c79:	66 89 55 d4          	mov    %dx,-0x2c(%ebp)
  807c7d:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  807c81:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807c84:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
  807c88:	bf 00 00 00 00       	mov    $0x0,%edi
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807c8d:	eb 79                	jmp    807d08 <inet_chksum_pseudo_partial+0xa3>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  807c8f:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807c93:	66 39 c6             	cmp    %ax,%si
  807c96:	89 c2                	mov    %eax,%edx
  807c98:	0f 46 d6             	cmovbe %esi,%edx
  807c9b:	66 89 55 d8          	mov    %dx,-0x28(%ebp)
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  807c9f:	0f b7 d2             	movzwl %dx,%edx
  807ca2:	8b 43 04             	mov    0x4(%ebx),%eax
  807ca5:	e8 aa fd ff ff       	call   807a54 <lwip_standard_chksum>
    chksum_len -= chklen;
  807caa:	66 2b 75 d8          	sub    -0x28(%ebp),%si
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807cae:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  807cb3:	76 1c                	jbe    807cd1 <inet_chksum_pseudo_partial+0x6c>
  807cb5:	c7 44 24 08 d5 21 81 	movl   $0x8121d5,0x8(%esp)
  807cbc:	00 
  807cbd:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  807cc4:	00 
  807cc5:	c7 04 24 e0 21 81 00 	movl   $0x8121e0,(%esp)
  807ccc:	e8 1b 75 00 00       	call   80f1ec <_panic>
      (void *)q, (void *)q->next));
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  807cd1:	0f b7 c0             	movzwl %ax,%eax
  807cd4:	8d 3c 38             	lea    (%eax,%edi,1),%edi
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  807cd7:	89 fa                	mov    %edi,%edx
  807cd9:	c1 ea 10             	shr    $0x10,%edx
  807cdc:	81 e7 ff ff 00 00    	and    $0xffff,%edi
  807ce2:	01 d7                	add    %edx,%edi
    if (q->len % 2 != 0) {
  807ce4:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807ce8:	74 1c                	je     807d06 <inet_chksum_pseudo_partial+0xa1>
      swapped = 1 - swapped;
  807cea:	b8 01 00 00 00       	mov    $0x1,%eax
  807cef:	2a 45 d7             	sub    -0x29(%ebp),%al
  807cf2:	88 45 d7             	mov    %al,-0x29(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807cf5:	89 f8                	mov    %edi,%eax
  807cf7:	c1 e0 08             	shl    $0x8,%eax
  807cfa:	25 ff ff 00 00       	and    $0xffff,%eax
  807cff:	89 fa                	mov    %edi,%edx
  807d01:	0f b6 fe             	movzbl %dh,%edi
  807d04:	09 c7                	or     %eax,%edi
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807d06:	8b 1b                	mov    (%ebx),%ebx
  807d08:	85 db                	test   %ebx,%ebx
  807d0a:	74 09                	je     807d15 <inet_chksum_pseudo_partial+0xb0>
  807d0c:	66 85 f6             	test   %si,%si
  807d0f:	0f 85 7a ff ff ff    	jne    807c8f <inet_chksum_pseudo_partial+0x2a>
  807d15:	89 f8                	mov    %edi,%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807d17:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  807d1b:	74 10                	je     807d2d <inet_chksum_pseudo_partial+0xc8>
    acc = SWAP_BYTES_IN_WORD(acc);
  807d1d:	89 fa                	mov    %edi,%edx
  807d1f:	c1 e2 08             	shl    $0x8,%edx
  807d22:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  807d28:	0f b6 fc             	movzbl %ah,%edi
  807d2b:	09 d7                	or     %edx,%edi
  }
  acc += (src->addr & 0xffffUL);
  807d2d:	8b 45 0c             	mov    0xc(%ebp),%eax
  807d30:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807d32:	8b 45 10             	mov    0x10(%ebp),%eax
  807d35:	8b 00                	mov    (%eax),%eax
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  807d37:	89 d1                	mov    %edx,%ecx
  807d39:	c1 e9 10             	shr    $0x10,%ecx
  807d3c:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  807d42:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  807d45:	0f b7 c8             	movzwl %ax,%ecx
  807d48:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  807d4a:	c1 e8 10             	shr    $0x10,%eax
  807d4d:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807d50:	8d 3c 38             	lea    (%eax,%edi,1),%edi
  acc += (u32_t)htons((u16_t)proto);
  807d53:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
  807d57:	89 04 24             	mov    %eax,(%esp)
  807d5a:	e8 00 01 00 00       	call   807e5f <htons>
  807d5f:	0f b7 c0             	movzwl %ax,%eax
  807d62:	01 c7                	add    %eax,%edi
  acc += (u32_t)htons(proto_len);
  807d64:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  807d68:	89 04 24             	mov    %eax,(%esp)
  807d6b:	e8 ef 00 00 00       	call   807e5f <htons>
  807d70:	0f b7 c0             	movzwl %ax,%eax
  807d73:	01 c7                	add    %eax,%edi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807d75:	89 f8                	mov    %edi,%eax
  807d77:	c1 e8 10             	shr    $0x10,%eax
  807d7a:	81 e7 ff ff 00 00    	and    $0xffff,%edi
  807d80:	8d 04 07             	lea    (%edi,%eax,1),%eax
  acc = FOLD_U32T(acc);
  807d83:	89 c2                	mov    %eax,%edx
  807d85:	c1 ea 10             	shr    $0x10,%edx
  807d88:	01 d0                	add    %edx,%eax
  807d8a:	f7 d0                	not    %eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  807d8c:	83 c4 3c             	add    $0x3c,%esp
  807d8f:	5b                   	pop    %ebx
  807d90:	5e                   	pop    %esi
  807d91:	5f                   	pop    %edi
  807d92:	5d                   	pop    %ebp
  807d93:	c3                   	ret    
	...

00807da0 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  807da0:	55                   	push   %ebp
  807da1:	89 e5                	mov    %esp,%ebp
  807da3:	57                   	push   %edi
  807da4:	56                   	push   %esi
  807da5:	53                   	push   %ebx
  807da6:	83 ec 20             	sub    $0x20,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807da9:	8b 45 08             	mov    0x8(%ebp),%eax
  807dac:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  807daf:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  807db2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
  807db6:	c7 45 e0 fc 49 b3 00 	movl   $0xb349fc,-0x20(%ebp)
  807dbd:	ba 00 00 00 00       	mov    $0x0,%edx
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
  807dc2:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  807dc5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807dc8:	0f b6 00             	movzbl (%eax),%eax
  807dcb:	88 45 db             	mov    %al,-0x25(%ebp)
      *ap /= (u8_t)10;
  807dce:	b8 cd ff ff ff       	mov    $0xffffffcd,%eax
  807dd3:	f6 65 db             	mulb   -0x25(%ebp)
  807dd6:	66 c1 e8 08          	shr    $0x8,%ax
  807dda:	c0 e8 03             	shr    $0x3,%al
  807ddd:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  807de0:	88 01                	mov    %al,(%ecx)
      inv[i++] = '0' + rem;
  807de2:	0f b6 f2             	movzbl %dl,%esi
  807de5:	8d 3c 80             	lea    (%eax,%eax,4),%edi
  807de8:	01 ff                	add    %edi,%edi
  807dea:	0f b6 5d db          	movzbl -0x25(%ebp),%ebx
  807dee:	89 f9                	mov    %edi,%ecx
  807df0:	28 cb                	sub    %cl,%bl
  807df2:	89 df                	mov    %ebx,%edi
  807df4:	8d 4f 30             	lea    0x30(%edi),%ecx
  807df7:	88 4c 35 ed          	mov    %cl,-0x13(%ebp,%esi,1)
  807dfb:	8d 4a 01             	lea    0x1(%edx),%ecx
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  807dfe:	89 ca                	mov    %ecx,%edx
    i = 0;
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
  807e00:	84 c0                	test   %al,%al
  807e02:	75 c1                	jne    807dc5 <inet_ntoa+0x25>
  807e04:	8b 45 e0             	mov    -0x20(%ebp),%eax
  807e07:	89 ce                	mov    %ecx,%esi
  807e09:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  807e0c:	eb 10                	jmp    807e1e <inet_ntoa+0x7e>
    while(i--)
  807e0e:	83 ea 01             	sub    $0x1,%edx
      *rp++ = inv[i];
  807e11:	0f b6 ca             	movzbl %dl,%ecx
  807e14:	0f b6 4c 0d ed       	movzbl -0x13(%ebp,%ecx,1),%ecx
  807e19:	88 08                	mov    %cl,(%eax)
  807e1b:	83 c0 01             	add    $0x1,%eax
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  807e1e:	84 d2                	test   %dl,%dl
  807e20:	75 ec                	jne    807e0e <inet_ntoa+0x6e>
  807e22:	89 f1                	mov    %esi,%ecx
  807e24:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  807e27:	0f b6 c9             	movzbl %cl,%ecx
  807e2a:	03 4d e0             	add    -0x20(%ebp),%ecx
      *rp++ = inv[i];
    *rp++ = '.';
  807e2d:	c6 01 2e             	movb   $0x2e,(%ecx)
  807e30:	83 c1 01             	add    $0x1,%ecx
  807e33:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807e36:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
  807e3a:	80 7d df 03          	cmpb   $0x3,-0x21(%ebp)
  807e3e:	77 0b                	ja     807e4b <inet_ntoa+0xab>
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  807e40:	83 c3 01             	add    $0x1,%ebx
  807e43:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  807e46:	e9 7a ff ff ff       	jmp    807dc5 <inet_ntoa+0x25>
  }
  *--rp = 0;
  807e4b:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  807e4e:	c6 43 ff 00          	movb   $0x0,-0x1(%ebx)
  return str;
}
  807e52:	b8 fc 49 b3 00       	mov    $0xb349fc,%eax
  807e57:	83 c4 20             	add    $0x20,%esp
  807e5a:	5b                   	pop    %ebx
  807e5b:	5e                   	pop    %esi
  807e5c:	5f                   	pop    %edi
  807e5d:	5d                   	pop    %ebp
  807e5e:	c3                   	ret    

00807e5f <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  807e5f:	55                   	push   %ebp
  807e60:	89 e5                	mov    %esp,%ebp
  807e62:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807e66:	66 c1 c0 08          	rol    $0x8,%ax
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
}
  807e6a:	5d                   	pop    %ebp
  807e6b:	c3                   	ret    

00807e6c <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  807e6c:	55                   	push   %ebp
  807e6d:	89 e5                	mov    %esp,%ebp
  807e6f:	83 ec 04             	sub    $0x4,%esp
  return htons(n);
  807e72:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807e76:	89 04 24             	mov    %eax,(%esp)
  807e79:	e8 e1 ff ff ff       	call   807e5f <htons>
}
  807e7e:	c9                   	leave  
  807e7f:	c3                   	ret    

00807e80 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  807e80:	55                   	push   %ebp
  807e81:	89 e5                	mov    %esp,%ebp
  807e83:	8b 55 08             	mov    0x8(%ebp),%edx
  807e86:	89 d1                	mov    %edx,%ecx
  807e88:	c1 e9 18             	shr    $0x18,%ecx
  807e8b:	89 d0                	mov    %edx,%eax
  807e8d:	c1 e0 18             	shl    $0x18,%eax
  807e90:	09 c8                	or     %ecx,%eax
  807e92:	89 d1                	mov    %edx,%ecx
  807e94:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  807e9a:	c1 e1 08             	shl    $0x8,%ecx
  807e9d:	09 c8                	or     %ecx,%eax
  807e9f:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  807ea5:	c1 ea 08             	shr    $0x8,%edx
  807ea8:	09 d0                	or     %edx,%eax
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  807eaa:	5d                   	pop    %ebp
  807eab:	c3                   	ret    

00807eac <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  807eac:	55                   	push   %ebp
  807ead:	89 e5                	mov    %esp,%ebp
  807eaf:	57                   	push   %edi
  807eb0:	56                   	push   %esi
  807eb1:	53                   	push   %ebx
  807eb2:	83 ec 28             	sub    $0x28,%esp
  807eb5:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  807eb8:	0f be 10             	movsbl (%eax),%edx
  807ebb:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  807ebe:	89 4d d8             	mov    %ecx,-0x28(%ebp)
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  807ec1:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  807ec4:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  807ec7:	8d 4a d0             	lea    -0x30(%edx),%ecx
  807eca:	80 f9 09             	cmp    $0x9,%cl
  807ecd:	0f 87 87 01 00 00    	ja     80805a <inet_aton+0x1ae>
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
  807ed3:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
  807eda:	83 fa 30             	cmp    $0x30,%edx
  807edd:	75 24                	jne    807f03 <inet_aton+0x57>
      c = *++cp;
  807edf:	83 c0 01             	add    $0x1,%eax
  807ee2:	0f be 10             	movsbl (%eax),%edx
      if (c == 'x' || c == 'X') {
  807ee5:	83 fa 78             	cmp    $0x78,%edx
  807ee8:	74 0c                	je     807ef6 <inet_aton+0x4a>
  807eea:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
  807ef1:	83 fa 58             	cmp    $0x58,%edx
  807ef4:	75 0d                	jne    807f03 <inet_aton+0x57>
        base = 16;
        c = *++cp;
  807ef6:	83 c0 01             	add    $0x1,%eax
  807ef9:	0f be 10             	movsbl (%eax),%edx
  807efc:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
  807f03:	83 c0 01             	add    $0x1,%eax
  807f06:	be 00 00 00 00       	mov    $0x0,%esi
  807f0b:	eb 03                	jmp    807f10 <inet_aton+0x64>
  807f0d:	83 c0 01             	add    $0x1,%eax
  807f10:	8d 78 ff             	lea    -0x1(%eax),%edi
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  807f13:	89 d1                	mov    %edx,%ecx
  807f15:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  807f18:	80 fb 09             	cmp    $0x9,%bl
  807f1b:	77 0d                	ja     807f2a <inet_aton+0x7e>
        val = (val * base) + (int)(c - '0');
  807f1d:	0f af 75 e0          	imul   -0x20(%ebp),%esi
  807f21:	8d 74 32 d0          	lea    -0x30(%edx,%esi,1),%esi
        c = *++cp;
  807f25:	0f be 10             	movsbl (%eax),%edx
  807f28:	eb e3                	jmp    807f0d <inet_aton+0x61>
      } else if (base == 16 && isxdigit(c)) {
  807f2a:	83 7d e0 10          	cmpl   $0x10,-0x20(%ebp)
  807f2e:	75 2b                	jne    807f5b <inet_aton+0xaf>
  807f30:	8d 59 9f             	lea    -0x61(%ecx),%ebx
  807f33:	88 5d d3             	mov    %bl,-0x2d(%ebp)
  807f36:	80 fb 05             	cmp    $0x5,%bl
  807f39:	76 08                	jbe    807f43 <inet_aton+0x97>
  807f3b:	8d 59 bf             	lea    -0x41(%ecx),%ebx
  807f3e:	80 fb 05             	cmp    $0x5,%bl
  807f41:	77 18                	ja     807f5b <inet_aton+0xaf>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  807f43:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  807f47:	19 c9                	sbb    %ecx,%ecx
  807f49:	83 e1 20             	and    $0x20,%ecx
  807f4c:	c1 e6 04             	shl    $0x4,%esi
  807f4f:	29 ca                	sub    %ecx,%edx
  807f51:	8d 52 c9             	lea    -0x37(%edx),%edx
  807f54:	09 d6                	or     %edx,%esi
        c = *++cp;
  807f56:	0f be 10             	movsbl (%eax),%edx
  807f59:	eb b2                	jmp    807f0d <inet_aton+0x61>
      } else
        break;
    }
    if (c == '.') {
  807f5b:	83 fa 2e             	cmp    $0x2e,%edx
  807f5e:	75 22                	jne    807f82 <inet_aton+0xd6>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  807f60:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807f63:	39 55 d8             	cmp    %edx,-0x28(%ebp)
  807f66:	0f 83 ee 00 00 00    	jae    80805a <inet_aton+0x1ae>
        return (0);
      *pp++ = val;
  807f6c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  807f6f:	89 31                	mov    %esi,(%ecx)
  807f71:	83 c1 04             	add    $0x4,%ecx
  807f74:	89 4d d8             	mov    %ecx,-0x28(%ebp)
      c = *++cp;
  807f77:	8d 47 01             	lea    0x1(%edi),%eax
  807f7a:	0f be 10             	movsbl (%eax),%edx
    } else
      break;
  }
  807f7d:	e9 45 ff ff ff       	jmp    807ec7 <inet_aton+0x1b>
  807f82:	89 f3                	mov    %esi,%ebx
  807f84:	89 f0                	mov    %esi,%eax
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807f86:	85 d2                	test   %edx,%edx
  807f88:	74 36                	je     807fc0 <inet_aton+0x114>
  807f8a:	80 f9 1f             	cmp    $0x1f,%cl
  807f8d:	0f 86 c7 00 00 00    	jbe    80805a <inet_aton+0x1ae>
  807f93:	84 d2                	test   %dl,%dl
  807f95:	0f 88 bf 00 00 00    	js     80805a <inet_aton+0x1ae>
  807f9b:	83 fa 20             	cmp    $0x20,%edx
  807f9e:	66 90                	xchg   %ax,%ax
  807fa0:	74 1e                	je     807fc0 <inet_aton+0x114>
  807fa2:	83 fa 0c             	cmp    $0xc,%edx
  807fa5:	74 19                	je     807fc0 <inet_aton+0x114>
  807fa7:	83 fa 0a             	cmp    $0xa,%edx
  807faa:	74 14                	je     807fc0 <inet_aton+0x114>
  807fac:	83 fa 0d             	cmp    $0xd,%edx
  807faf:	90                   	nop
  807fb0:	74 0e                	je     807fc0 <inet_aton+0x114>
  807fb2:	83 fa 09             	cmp    $0x9,%edx
  807fb5:	74 09                	je     807fc0 <inet_aton+0x114>
  807fb7:	83 fa 0b             	cmp    $0xb,%edx
  807fba:	0f 85 9a 00 00 00    	jne    80805a <inet_aton+0x1ae>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  807fc0:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  807fc3:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  807fc6:	29 d1                	sub    %edx,%ecx
  807fc8:	89 ca                	mov    %ecx,%edx
  807fca:	c1 fa 02             	sar    $0x2,%edx
  807fcd:	83 c2 01             	add    $0x1,%edx
  807fd0:	83 fa 02             	cmp    $0x2,%edx
  807fd3:	74 1d                	je     807ff2 <inet_aton+0x146>
  807fd5:	83 fa 02             	cmp    $0x2,%edx
  807fd8:	7f 08                	jg     807fe2 <inet_aton+0x136>
  807fda:	85 d2                	test   %edx,%edx
  807fdc:	74 7c                	je     80805a <inet_aton+0x1ae>
  807fde:	66 90                	xchg   %ax,%ax
  807fe0:	eb 59                	jmp    80803b <inet_aton+0x18f>
  807fe2:	83 fa 03             	cmp    $0x3,%edx
  807fe5:	74 1c                	je     808003 <inet_aton+0x157>
  807fe7:	83 fa 04             	cmp    $0x4,%edx
  807fea:	75 4f                	jne    80803b <inet_aton+0x18f>
  807fec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  807ff0:	eb 2a                	jmp    80801c <inet_aton+0x170>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  807ff2:	3d ff ff ff 00       	cmp    $0xffffff,%eax
  807ff7:	77 61                	ja     80805a <inet_aton+0x1ae>
      return (0);
    val |= parts[0] << 24;
  807ff9:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  807ffc:	c1 e3 18             	shl    $0x18,%ebx
  807fff:	09 c3                	or     %eax,%ebx
    break;
  808001:	eb 38                	jmp    80803b <inet_aton+0x18f>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  808003:	3d ff ff 00 00       	cmp    $0xffff,%eax
  808008:	77 50                	ja     80805a <inet_aton+0x1ae>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  80800a:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  80800d:	c1 e3 10             	shl    $0x10,%ebx
  808010:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808013:	c1 e2 18             	shl    $0x18,%edx
  808016:	09 d3                	or     %edx,%ebx
  808018:	09 c3                	or     %eax,%ebx
    break;
  80801a:	eb 1f                	jmp    80803b <inet_aton+0x18f>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  80801c:	3d ff 00 00 00       	cmp    $0xff,%eax
  808021:	77 37                	ja     80805a <inet_aton+0x1ae>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  808023:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  808026:	c1 e3 10             	shl    $0x10,%ebx
  808029:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80802c:	c1 e2 18             	shl    $0x18,%edx
  80802f:	09 d3                	or     %edx,%ebx
  808031:	8b 55 ec             	mov    -0x14(%ebp),%edx
  808034:	c1 e2 08             	shl    $0x8,%edx
  808037:	09 d3                	or     %edx,%ebx
  808039:	09 c3                	or     %eax,%ebx
    break;
  }
  if (addr)
  80803b:	b8 01 00 00 00       	mov    $0x1,%eax
  808040:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  808044:	74 19                	je     80805f <inet_aton+0x1b3>
    addr->s_addr = htonl(val);
  808046:	89 1c 24             	mov    %ebx,(%esp)
  808049:	e8 32 fe ff ff       	call   807e80 <htonl>
  80804e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  808051:	89 03                	mov    %eax,(%ebx)
  808053:	b8 01 00 00 00       	mov    $0x1,%eax
  808058:	eb 05                	jmp    80805f <inet_aton+0x1b3>
  80805a:	b8 00 00 00 00       	mov    $0x0,%eax
  return (1);
}
  80805f:	83 c4 28             	add    $0x28,%esp
  808062:	5b                   	pop    %ebx
  808063:	5e                   	pop    %esi
  808064:	5f                   	pop    %edi
  808065:	5d                   	pop    %ebp
  808066:	c3                   	ret    

00808067 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  808067:	55                   	push   %ebp
  808068:	89 e5                	mov    %esp,%ebp
  80806a:	83 ec 18             	sub    $0x18,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  80806d:	8d 45 fc             	lea    -0x4(%ebp),%eax
  808070:	89 44 24 04          	mov    %eax,0x4(%esp)
  808074:	8b 45 08             	mov    0x8(%ebp),%eax
  808077:	89 04 24             	mov    %eax,(%esp)
  80807a:	e8 2d fe ff ff       	call   807eac <inet_aton>
  80807f:	85 c0                	test   %eax,%eax
  808081:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808086:	0f 45 45 fc          	cmovne -0x4(%ebp),%eax
    return (val.s_addr);
  }
  return (INADDR_NONE);
}
  80808a:	c9                   	leave  
  80808b:	c3                   	ret    

0080808c <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  80808c:	55                   	push   %ebp
  80808d:	89 e5                	mov    %esp,%ebp
  80808f:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  808092:	8b 45 08             	mov    0x8(%ebp),%eax
  808095:	89 04 24             	mov    %eax,(%esp)
  808098:	e8 e3 fd ff ff       	call   807e80 <htonl>
}
  80809d:	c9                   	leave  
  80809e:	c3                   	ret    
	...

008080a0 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  8080a0:	55                   	push   %ebp
  8080a1:	89 e5                	mov    %esp,%ebp
  8080a3:	57                   	push   %edi
  8080a4:	56                   	push   %esi
  8080a5:	53                   	push   %ebx
  8080a6:	83 ec 3c             	sub    $0x3c,%esp
  8080a9:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  8080ac:	8b 46 78             	mov    0x78(%esi),%eax
  8080af:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  8080b2:	85 c0                	test   %eax,%eax
  8080b4:	75 0e                	jne    8080c4 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  8080b6:	8b 56 74             	mov    0x74(%esi),%edx
  8080b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  if(seg == NULL)
  8080bc:	85 d2                	test   %edx,%edx
  8080be:	0f 84 4b 01 00 00    	je     80820f <tcp_zero_window_probe+0x16f>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  8080c4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8080cb:	00 
  8080cc:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  8080d3:	00 
  8080d4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8080db:	e8 ff d3 ff ff       	call   8054df <pbuf_alloc>
  8080e0:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  8080e2:	85 c0                	test   %eax,%eax
  8080e4:	0f 84 25 01 00 00    	je     80820f <tcp_zero_window_probe+0x16f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8080ea:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8080ef:	77 1c                	ja     80810d <tcp_zero_window_probe+0x6d>
  8080f1:	c7 44 24 08 04 22 81 	movl   $0x812204,0x8(%esp)
  8080f8:	00 
  8080f9:	c7 44 24 04 8d 03 00 	movl   $0x38d,0x4(%esp)
  808100:	00 
  808101:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  808108:	e8 df 70 00 00       	call   80f1ec <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80810d:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808110:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808114:	89 04 24             	mov    %eax,(%esp)
  808117:	e8 43 fd ff ff       	call   807e5f <htons>
  80811c:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80811f:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808123:	89 04 24             	mov    %eax,(%esp)
  808126:	e8 34 fd ff ff       	call   807e5f <htons>
  80812b:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  80812f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808132:	8b 41 10             	mov    0x10(%ecx),%eax
  808135:	8b 40 04             	mov    0x4(%eax),%eax
  808138:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80813b:	8b 46 24             	mov    0x24(%esi),%eax
  80813e:	89 04 24             	mov    %eax,(%esp)
  808141:	e8 3a fd ff ff       	call   807e80 <htonl>
  808146:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808149:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80814d:	89 04 24             	mov    %eax,(%esp)
  808150:	e8 17 fd ff ff       	call   807e6c <ntohs>
  808155:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80815a:	89 04 24             	mov    %eax,(%esp)
  80815d:	e8 fd fc ff ff       	call   807e5f <htons>
  808162:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808166:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80816a:	89 04 24             	mov    %eax,(%esp)
  80816d:	e8 ed fc ff ff       	call   807e5f <htons>
  808172:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808176:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80817c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808180:	89 04 24             	mov    %eax,(%esp)
  808183:	e8 e4 fc ff ff       	call   807e6c <ntohs>
  808188:	83 e0 3f             	and    $0x3f,%eax
  80818b:	80 cc 50             	or     $0x50,%ah
  80818e:	89 04 24             	mov    %eax,(%esp)
  808191:	e8 c9 fc ff ff       	call   807e5f <htons>
  808196:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80819a:	8b 47 04             	mov    0x4(%edi),%eax
  80819d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8081a0:	8b 51 08             	mov    0x8(%ecx),%edx
  8081a3:	0f b6 12             	movzbl (%edx),%edx
  8081a6:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  8081a9:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  8081af:	8d 46 04             	lea    0x4(%esi),%eax
  8081b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8081b5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8081b9:	89 44 24 10          	mov    %eax,0x10(%esp)
  8081bd:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  8081c4:	00 
  8081c5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8081c8:	89 54 24 08          	mov    %edx,0x8(%esp)
  8081cc:	89 74 24 04          	mov    %esi,0x4(%esp)
  8081d0:	89 3c 24             	mov    %edi,(%esp)
  8081d3:	e8 a0 f9 ff ff       	call   807b78 <inet_chksum_pseudo>
  8081d8:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  8081dc:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  8081e3:	00 
  8081e4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8081eb:	00 
  8081ec:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  8081f0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8081f4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8081f7:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8081fb:	89 74 24 04          	mov    %esi,0x4(%esp)
  8081ff:	89 3c 24             	mov    %edi,(%esp)
  808202:	e8 8c eb ff ff       	call   806d93 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808207:	89 3c 24             	mov    %edi,(%esp)
  80820a:	e8 15 d0 ff ff       	call   805224 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80820f:	83 c4 3c             	add    $0x3c,%esp
  808212:	5b                   	pop    %ebx
  808213:	5e                   	pop    %esi
  808214:	5f                   	pop    %edi
  808215:	5d                   	pop    %ebp
  808216:	c3                   	ret    

00808217 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  808217:	55                   	push   %ebp
  808218:	89 e5                	mov    %esp,%ebp
  80821a:	57                   	push   %edi
  80821b:	56                   	push   %esi
  80821c:	53                   	push   %ebx
  80821d:	83 ec 3c             	sub    $0x3c,%esp
  808220:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808223:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80822a:	00 
  80822b:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808232:	00 
  808233:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80823a:	e8 a0 d2 ff ff       	call   8054df <pbuf_alloc>
  80823f:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808241:	85 c0                	test   %eax,%eax
  808243:	0f 84 1b 01 00 00    	je     808364 <tcp_keepalive+0x14d>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808249:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80824e:	77 1c                	ja     80826c <tcp_keepalive+0x55>
  808250:	c7 44 24 08 04 22 81 	movl   $0x812204,0x8(%esp)
  808257:	00 
  808258:	c7 44 24 04 3a 03 00 	movl   $0x33a,0x4(%esp)
  80825f:	00 
  808260:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  808267:	e8 80 6f 00 00       	call   80f1ec <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80826c:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80826f:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808273:	89 04 24             	mov    %eax,(%esp)
  808276:	e8 e4 fb ff ff       	call   807e5f <htons>
  80827b:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80827e:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808282:	89 04 24             	mov    %eax,(%esp)
  808285:	e8 d5 fb ff ff       	call   807e5f <htons>
  80828a:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  80828e:	8b 46 54             	mov    0x54(%esi),%eax
  808291:	83 e8 01             	sub    $0x1,%eax
  808294:	89 04 24             	mov    %eax,(%esp)
  808297:	e8 e4 fb ff ff       	call   807e80 <htonl>
  80829c:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80829f:	8b 46 24             	mov    0x24(%esi),%eax
  8082a2:	89 04 24             	mov    %eax,(%esp)
  8082a5:	e8 d6 fb ff ff       	call   807e80 <htonl>
  8082aa:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8082ad:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8082b1:	89 04 24             	mov    %eax,(%esp)
  8082b4:	e8 b3 fb ff ff       	call   807e6c <ntohs>
  8082b9:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8082be:	89 04 24             	mov    %eax,(%esp)
  8082c1:	e8 99 fb ff ff       	call   807e5f <htons>
  8082c6:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8082ca:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  8082ce:	89 04 24             	mov    %eax,(%esp)
  8082d1:	e8 89 fb ff ff       	call   807e5f <htons>
  8082d6:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  8082da:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  8082e0:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8082e4:	89 04 24             	mov    %eax,(%esp)
  8082e7:	e8 80 fb ff ff       	call   807e6c <ntohs>
  8082ec:	83 e0 3f             	and    $0x3f,%eax
  8082ef:	80 cc 50             	or     $0x50,%ah
  8082f2:	89 04 24             	mov    %eax,(%esp)
  8082f5:	e8 65 fb ff ff       	call   807e5f <htons>
  8082fa:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  8082fe:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808304:	8d 46 04             	lea    0x4(%esi),%eax
  808307:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80830a:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80830e:	89 44 24 10          	mov    %eax,0x10(%esp)
  808312:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808319:	00 
  80831a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80831d:	89 44 24 08          	mov    %eax,0x8(%esp)
  808321:	89 74 24 04          	mov    %esi,0x4(%esp)
  808325:	89 3c 24             	mov    %edi,(%esp)
  808328:	e8 4b f8 ff ff       	call   807b78 <inet_chksum_pseudo>
  80832d:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808331:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808338:	00 
  808339:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808340:	00 
  808341:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808345:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808349:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80834c:	89 44 24 08          	mov    %eax,0x8(%esp)
  808350:	89 74 24 04          	mov    %esi,0x4(%esp)
  808354:	89 3c 24             	mov    %edi,(%esp)
  808357:	e8 37 ea ff ff       	call   806d93 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80835c:	89 3c 24             	mov    %edi,(%esp)
  80835f:	e8 c0 ce ff ff       	call   805224 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808364:	83 c4 3c             	add    $0x3c,%esp
  808367:	5b                   	pop    %ebx
  808368:	5e                   	pop    %esi
  808369:	5f                   	pop    %edi
  80836a:	5d                   	pop    %ebp
  80836b:	c3                   	ret    

0080836c <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  80836c:	55                   	push   %ebp
  80836d:	89 e5                	mov    %esp,%ebp
  80836f:	57                   	push   %edi
  808370:	56                   	push   %esi
  808371:	53                   	push   %ebx
  808372:	83 ec 3c             	sub    $0x3c,%esp
  808375:	8b 7d 14             	mov    0x14(%ebp),%edi
  808378:	0f b7 45 18          	movzwl 0x18(%ebp),%eax
  80837c:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  808380:	0f b7 45 1c          	movzwl 0x1c(%ebp),%eax
  808384:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808388:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80838f:	00 
  808390:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808397:	00 
  808398:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80839f:	e8 3b d1 ff ff       	call   8054df <pbuf_alloc>
  8083a4:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  8083a6:	85 c0                	test   %eax,%eax
  8083a8:	0f 84 15 01 00 00    	je     8084c3 <tcp_rst+0x157>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8083ae:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8083b3:	77 1c                	ja     8083d1 <tcp_rst+0x65>
  8083b5:	c7 44 24 08 04 22 81 	movl   $0x812204,0x8(%esp)
  8083bc:	00 
  8083bd:	c7 44 24 04 be 02 00 	movl   $0x2be,0x4(%esp)
  8083c4:	00 
  8083c5:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  8083cc:	e8 1b 6e 00 00       	call   80f1ec <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8083d1:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  8083d4:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8083d8:	89 04 24             	mov    %eax,(%esp)
  8083db:	e8 7f fa ff ff       	call   807e5f <htons>
  8083e0:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  8083e3:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8083e7:	89 04 24             	mov    %eax,(%esp)
  8083ea:	e8 70 fa ff ff       	call   807e5f <htons>
  8083ef:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  8083f3:	8b 45 08             	mov    0x8(%ebp),%eax
  8083f6:	89 04 24             	mov    %eax,(%esp)
  8083f9:	e8 82 fa ff ff       	call   807e80 <htonl>
  8083fe:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  808401:	8b 45 0c             	mov    0xc(%ebp),%eax
  808404:	89 04 24             	mov    %eax,(%esp)
  808407:	e8 74 fa ff ff       	call   807e80 <htonl>
  80840c:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  80840f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808413:	89 04 24             	mov    %eax,(%esp)
  808416:	e8 51 fa ff ff       	call   807e6c <ntohs>
  80841b:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808420:	83 c8 14             	or     $0x14,%eax
  808423:	89 04 24             	mov    %eax,(%esp)
  808426:	e8 34 fa ff ff       	call   807e5f <htons>
  80842b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  80842f:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  808436:	e8 24 fa ff ff       	call   807e5f <htons>
  80843b:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80843f:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808445:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808449:	89 04 24             	mov    %eax,(%esp)
  80844c:	e8 1b fa ff ff       	call   807e6c <ntohs>
  808451:	83 e0 3f             	and    $0x3f,%eax
  808454:	80 cc 50             	or     $0x50,%ah
  808457:	89 04 24             	mov    %eax,(%esp)
  80845a:	e8 00 fa ff ff       	call   807e5f <htons>
  80845f:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808463:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808469:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80846d:	89 44 24 10          	mov    %eax,0x10(%esp)
  808471:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808478:	00 
  808479:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80847d:	8b 45 10             	mov    0x10(%ebp),%eax
  808480:	89 44 24 04          	mov    %eax,0x4(%esp)
  808484:	89 34 24             	mov    %esi,(%esp)
  808487:	e8 ec f6 ff ff       	call   807b78 <inet_chksum_pseudo>
  80848c:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  808490:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808497:	00 
  808498:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80849f:	00 
  8084a0:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  8084a7:	00 
  8084a8:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8084ac:	8b 45 10             	mov    0x10(%ebp),%eax
  8084af:	89 44 24 04          	mov    %eax,0x4(%esp)
  8084b3:	89 34 24             	mov    %esi,(%esp)
  8084b6:	e8 d8 e8 ff ff       	call   806d93 <ip_output>
  pbuf_free(p);
  8084bb:	89 34 24             	mov    %esi,(%esp)
  8084be:	e8 61 cd ff ff       	call   805224 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  8084c3:	83 c4 3c             	add    $0x3c,%esp
  8084c6:	5b                   	pop    %ebx
  8084c7:	5e                   	pop    %esi
  8084c8:	5f                   	pop    %edi
  8084c9:	5d                   	pop    %ebp
  8084ca:	c3                   	ret    

008084cb <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  8084cb:	55                   	push   %ebp
  8084cc:	89 e5                	mov    %esp,%ebp
  8084ce:	57                   	push   %edi
  8084cf:	56                   	push   %esi
  8084d0:	53                   	push   %ebx
  8084d1:	83 ec 4c             	sub    $0x4c,%esp
  8084d4:	8b 75 08             	mov    0x8(%ebp),%esi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  8084d7:	b8 00 00 00 00       	mov    $0x0,%eax
  8084dc:	39 35 58 b2 b3 00    	cmp    %esi,0xb3b258
  8084e2:	0f 84 69 04 00 00    	je     808951 <tcp_output+0x486>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  8084e8:	0f b7 46 4e          	movzwl 0x4e(%esi),%eax
  8084ec:	66 39 46 5c          	cmp    %ax,0x5c(%esi)
  8084f0:	66 0f 46 46 5c       	cmovbe 0x5c(%esi),%ax
  8084f5:	0f b7 c0             	movzwl %ax,%eax
  8084f8:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  seg = pcb->unsent;
  8084fb:	8b 5e 74             	mov    0x74(%esi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  8084fe:	8b 7e 78             	mov    0x78(%esi),%edi
  if (useg != NULL) {
  808501:	85 ff                	test   %edi,%edi
  808503:	74 0a                	je     80850f <tcp_output+0x44>
    for (; useg->next != NULL; useg = useg->next);
  808505:	8b 07                	mov    (%edi),%eax
  808507:	85 c0                	test   %eax,%eax
  808509:	74 04                	je     80850f <tcp_output+0x44>
  80850b:	89 c7                	mov    %eax,%edi
  80850d:	eb f6                	jmp    808505 <tcp_output+0x3a>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80850f:	f6 46 20 02          	testb  $0x2,0x20(%esi)
  808513:	74 21                	je     808536 <tcp_output+0x6b>
  808515:	85 db                	test   %ebx,%ebx
  808517:	74 2e                	je     808547 <tcp_output+0x7c>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  808519:	8b 43 10             	mov    0x10(%ebx),%eax
  80851c:	8b 40 04             	mov    0x4(%eax),%eax
  80851f:	89 04 24             	mov    %eax,(%esp)
  808522:	e8 65 fb ff ff       	call   80808c <ntohl>
  808527:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80852b:	2b 56 48             	sub    0x48(%esi),%edx
  80852e:	8d 04 02             	lea    (%edx,%eax,1),%eax
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  808531:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  808534:	72 11                	jb     808547 <tcp_output+0x7c>
  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  808536:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    netif = ip_route(&(pcb->remote_ip));
  808539:	8d 46 04             	lea    0x4(%esi),%eax
  80853c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80853f:	89 7d d8             	mov    %edi,-0x28(%ebp)
  808542:	e9 a3 03 00 00       	jmp    8088ea <tcp_output+0x41f>
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808547:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80854e:	00 
  80854f:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808556:	00 
  808557:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80855e:	e8 7c cf ff ff       	call   8054df <pbuf_alloc>
  808563:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  808565:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80856a:	85 ff                	test   %edi,%edi
  80856c:	0f 84 df 03 00 00    	je     808951 <tcp_output+0x486>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808572:	80 66 20 fc          	andb   $0xfc,0x20(%esi)

    tcphdr = p->payload;
  808576:	8b 5f 04             	mov    0x4(%edi),%ebx
    tcphdr->src = htons(pcb->local_port);
  808579:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80857d:	89 04 24             	mov    %eax,(%esp)
  808580:	e8 da f8 ff ff       	call   807e5f <htons>
  808585:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  808588:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80858c:	89 04 24             	mov    %eax,(%esp)
  80858f:	e8 cb f8 ff ff       	call   807e5f <htons>
  808594:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  808598:	8b 46 54             	mov    0x54(%esi),%eax
  80859b:	89 04 24             	mov    %eax,(%esp)
  80859e:	e8 dd f8 ff ff       	call   807e80 <htonl>
  8085a3:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  8085a6:	8b 46 24             	mov    0x24(%esi),%eax
  8085a9:	89 04 24             	mov    %eax,(%esp)
  8085ac:	e8 cf f8 ff ff       	call   807e80 <htonl>
  8085b1:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  8085b4:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8085b8:	89 04 24             	mov    %eax,(%esp)
  8085bb:	e8 ac f8 ff ff       	call   807e6c <ntohs>
  8085c0:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8085c5:	83 c8 10             	or     $0x10,%eax
  8085c8:	89 04 24             	mov    %eax,(%esp)
  8085cb:	e8 8f f8 ff ff       	call   807e5f <htons>
  8085d0:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8085d4:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  8085d8:	89 04 24             	mov    %eax,(%esp)
  8085db:	e8 7f f8 ff ff       	call   807e5f <htons>
  8085e0:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  8085e4:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  8085ea:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8085ee:	89 04 24             	mov    %eax,(%esp)
  8085f1:	e8 76 f8 ff ff       	call   807e6c <ntohs>
  8085f6:	83 e0 3f             	and    $0x3f,%eax
  8085f9:	80 cc 50             	or     $0x50,%ah
  8085fc:	89 04 24             	mov    %eax,(%esp)
  8085ff:	e8 5b f8 ff ff       	call   807e5f <htons>
  808604:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  808608:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80860e:	8d 56 04             	lea    0x4(%esi),%edx
  808611:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808614:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808618:	89 44 24 10          	mov    %eax,0x10(%esp)
  80861c:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808623:	00 
  808624:	89 54 24 08          	mov    %edx,0x8(%esp)
  808628:	89 74 24 04          	mov    %esi,0x4(%esp)
  80862c:	89 3c 24             	mov    %edi,(%esp)
  80862f:	e8 44 f5 ff ff       	call   807b78 <inet_chksum_pseudo>
  808634:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808638:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80863f:	00 
  808640:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  808644:	89 44 24 10          	mov    %eax,0x10(%esp)
  808648:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80864c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808650:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808653:	89 44 24 08          	mov    %eax,0x8(%esp)
  808657:	89 74 24 04          	mov    %esi,0x4(%esp)
  80865b:	89 3c 24             	mov    %edi,(%esp)
  80865e:	e8 30 e7 ff ff       	call   806d93 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  808663:	89 3c 24             	mov    %edi,(%esp)
  808666:	e8 b9 cb ff ff       	call   805224 <pbuf_free>
  80866b:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
  808670:	e9 dc 02 00 00       	jmp    808951 <tcp_output+0x486>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  808675:	8b 43 10             	mov    0x10(%ebx),%eax
  808678:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80867c:	89 04 24             	mov    %eax,(%esp)
  80867f:	e8 e8 f7 ff ff       	call   807e6c <ntohs>
  808684:	a8 04                	test   $0x4,%al
  808686:	74 1c                	je     8086a4 <tcp_output+0x1d9>
  808688:	c7 44 24 08 c0 23 81 	movl   $0x8123c0,0x8(%esp)
  80868f:	00 
  808690:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
  808697:	00 
  808698:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  80869f:	e8 48 6b 00 00       	call   80f1ec <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  8086a4:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  8086a8:	74 1c                	je     8086c6 <tcp_output+0x1fb>
  8086aa:	0f b6 46 20          	movzbl 0x20(%esi),%eax
  8086ae:	a8 40                	test   $0x40,%al
  8086b0:	75 14                	jne    8086c6 <tcp_output+0x1fb>
  8086b2:	8b 56 74             	mov    0x74(%esi),%edx
  8086b5:	85 d2                	test   %edx,%edx
  8086b7:	0f 84 9c 02 00 00    	je     808959 <tcp_output+0x48e>
  8086bd:	83 3a 00             	cmpl   $0x0,(%edx)
  8086c0:	0f 84 93 02 00 00    	je     808959 <tcp_output+0x48e>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  8086c6:	8b 03                	mov    (%ebx),%eax
  8086c8:	89 46 74             	mov    %eax,0x74(%esi)

    if (pcb->state != SYN_SENT) {
  8086cb:	83 7e 10 02          	cmpl   $0x2,0x10(%esi)
  8086cf:	74 25                	je     8086f6 <tcp_output+0x22b>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  8086d1:	8b 7b 10             	mov    0x10(%ebx),%edi
  8086d4:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  8086d8:	89 04 24             	mov    %eax,(%esp)
  8086db:	e8 8c f7 ff ff       	call   807e6c <ntohs>
  8086e0:	83 c8 10             	or     $0x10,%eax
  8086e3:	0f b7 c0             	movzwl %ax,%eax
  8086e6:	89 04 24             	mov    %eax,(%esp)
  8086e9:	e8 71 f7 ff ff       	call   807e5f <htons>
  8086ee:	66 89 47 0c          	mov    %ax,0xc(%edi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8086f2:	80 66 20 fc          	andb   $0xfc,0x20(%esi)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  8086f6:	8b 7b 10             	mov    0x10(%ebx),%edi
  8086f9:	8b 46 24             	mov    0x24(%esi),%eax
  8086fc:	89 04 24             	mov    %eax,(%esp)
  8086ff:	e8 7c f7 ff ff       	call   807e80 <htonl>
  808704:	89 47 08             	mov    %eax,0x8(%edi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808707:	8b 7b 10             	mov    0x10(%ebx),%edi
  80870a:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80870e:	89 04 24             	mov    %eax,(%esp)
  808711:	e8 49 f7 ff ff       	call   807e5f <htons>
  808716:	66 89 47 0e          	mov    %ax,0xe(%edi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80871a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80871e:	74 05                	je     808725 <tcp_output+0x25a>
  808720:	83 3e 00             	cmpl   $0x0,(%esi)
  808723:	75 22                	jne    808747 <tcp_output+0x27c>
    netif = ip_route(&(pcb->remote_ip));
  808725:	8b 55 e0             	mov    -0x20(%ebp),%edx
  808728:	89 14 24             	mov    %edx,(%esp)
  80872b:	e8 11 e6 ff ff       	call   806d41 <ip_route>
    if (netif == NULL) {
  808730:	85 c0                	test   %eax,%eax
  808732:	0f 84 c3 00 00 00    	je     8087fb <tcp_output+0x330>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  808738:	ba 00 00 00 00       	mov    $0x0,%edx
  80873d:	83 f8 fc             	cmp    $0xfffffffc,%eax
  808740:	74 03                	je     808745 <tcp_output+0x27a>
  808742:	8b 50 04             	mov    0x4(%eax),%edx
  808745:	89 16                	mov    %edx,(%esi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  808747:	66 83 7e 32 ff       	cmpw   $0xffffffff,0x32(%esi)
  80874c:	75 06                	jne    808754 <tcp_output+0x289>
    pcb->rtime = 0;
  80874e:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)

  if (pcb->rttest == 0) {
  808754:	83 7e 38 00          	cmpl   $0x0,0x38(%esi)
  808758:	75 19                	jne    808773 <tcp_output+0x2a8>
    pcb->rttest = tcp_ticks;
  80875a:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80875f:	89 46 38             	mov    %eax,0x38(%esi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  808762:	8b 43 10             	mov    0x10(%ebx),%eax
  808765:	8b 40 04             	mov    0x4(%eax),%eax
  808768:	89 04 24             	mov    %eax,(%esp)
  80876b:	e8 1c f9 ff ff       	call   80808c <ntohl>
  808770:	89 46 3c             	mov    %eax,0x3c(%esi)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  808773:	8b 43 04             	mov    0x4(%ebx),%eax
  808776:	8b 53 10             	mov    0x10(%ebx),%edx
  808779:	66 2b 50 04          	sub    0x4(%eax),%dx

  seg->p->len -= len;
  80877d:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  808781:	8b 43 04             	mov    0x4(%ebx),%eax
  808784:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  808788:	8b 43 04             	mov    0x4(%ebx),%eax
  80878b:	8b 53 10             	mov    0x10(%ebx),%edx
  80878e:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  808791:	8b 43 10             	mov    0x10(%ebx),%eax
  808794:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80879a:	8b 7b 10             	mov    0x10(%ebx),%edi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  80879d:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8087a0:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  8087a4:	89 54 24 10          	mov    %edx,0x10(%esp)
  8087a8:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  8087af:	00 
  8087b0:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8087b3:	89 54 24 08          	mov    %edx,0x8(%esp)
  8087b7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8087ba:	89 54 24 04          	mov    %edx,0x4(%esp)
  8087be:	89 04 24             	mov    %eax,(%esp)
  8087c1:	e8 b2 f3 ff ff       	call   807b78 <inet_chksum_pseudo>
  8087c6:	66 89 47 10          	mov    %ax,0x10(%edi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  8087ca:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  8087d1:	00 
  8087d2:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  8087d6:	89 44 24 10          	mov    %eax,0x10(%esp)
  8087da:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  8087de:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8087e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8087e5:	89 44 24 08          	mov    %eax,0x8(%esp)
  8087e9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8087ec:	89 54 24 04          	mov    %edx,0x4(%esp)
  8087f0:	8b 43 04             	mov    0x4(%ebx),%eax
  8087f3:	89 04 24             	mov    %eax,(%esp)
  8087f6:	e8 98 e5 ff ff       	call   806d93 <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8087fb:	8b 43 10             	mov    0x10(%ebx),%eax
  8087fe:	8b 40 04             	mov    0x4(%eax),%eax
  808801:	89 04 24             	mov    %eax,(%esp)
  808804:	e8 83 f8 ff ff       	call   80808c <ntohl>
  808809:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80880c:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  808810:	8b 43 10             	mov    0x10(%ebx),%eax
  808813:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808817:	89 04 24             	mov    %eax,(%esp)
  80881a:	e8 4d f6 ff ff       	call   807e6c <ntohs>
  80881f:	a8 01                	test   $0x1,%al
  808821:	75 1b                	jne    80883e <tcp_output+0x373>
  808823:	8b 43 10             	mov    0x10(%ebx),%eax
  808826:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80882a:	89 04 24             	mov    %eax,(%esp)
  80882d:	e8 3a f6 ff ff       	call   807e6c <ntohs>
  808832:	89 c2                	mov    %eax,%edx
  808834:	b8 00 00 00 00       	mov    $0x0,%eax
  808839:	f6 c2 02             	test   $0x2,%dl
  80883c:	74 05                	je     808843 <tcp_output+0x378>
  80883e:	b8 01 00 00 00       	mov    $0x1,%eax
  808843:	0f b7 ff             	movzwl %di,%edi
  808846:	8d 3c 38             	lea    (%eax,%edi,1),%edi
  808849:	03 7d dc             	add    -0x24(%ebp),%edi
  80884c:	89 7e 54             	mov    %edi,0x54(%esi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  80884f:	39 7e 58             	cmp    %edi,0x58(%esi)
  808852:	79 03                	jns    808857 <tcp_output+0x38c>
      pcb->snd_max = pcb->snd_nxt;
  808854:	89 7e 58             	mov    %edi,0x58(%esi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  808857:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80885b:	8b 43 10             	mov    0x10(%ebx),%eax
  80885e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808862:	89 04 24             	mov    %eax,(%esp)
  808865:	e8 02 f6 ff ff       	call   807e6c <ntohs>
  80886a:	a8 01                	test   $0x1,%al
  80886c:	75 18                	jne    808886 <tcp_output+0x3bb>
  80886e:	8b 43 10             	mov    0x10(%ebx),%eax
  808871:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808875:	89 04 24             	mov    %eax,(%esp)
  808878:	e8 ef f5 ff ff       	call   807e6c <ntohs>
  80887d:	ba 00 00 00 00       	mov    $0x0,%edx
  808882:	a8 02                	test   $0x2,%al
  808884:	74 05                	je     80888b <tcp_output+0x3c0>
  808886:	ba 01 00 00 00       	mov    $0x1,%edx
  80888b:	0f b7 ff             	movzwl %di,%edi
  80888e:	01 fa                	add    %edi,%edx
  808890:	74 4d                	je     8088df <tcp_output+0x414>
      seg->next = NULL;
  808892:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  808898:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80889c:	75 08                	jne    8088a6 <tcp_output+0x3db>
        pcb->unacked = seg;
  80889e:	89 5e 78             	mov    %ebx,0x78(%esi)
  8088a1:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  8088a4:	eb 41                	jmp    8088e7 <tcp_output+0x41c>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  8088a6:	8b 43 10             	mov    0x10(%ebx),%eax
  8088a9:	8b 40 04             	mov    0x4(%eax),%eax
  8088ac:	89 04 24             	mov    %eax,(%esp)
  8088af:	e8 d8 f7 ff ff       	call   80808c <ntohl>
  8088b4:	89 c7                	mov    %eax,%edi
  8088b6:	8b 55 d8             	mov    -0x28(%ebp),%edx
  8088b9:	8b 42 10             	mov    0x10(%edx),%eax
  8088bc:	8b 40 04             	mov    0x4(%eax),%eax
  8088bf:	89 04 24             	mov    %eax,(%esp)
  8088c2:	e8 c5 f7 ff ff       	call   80808c <ntohl>
  8088c7:	39 c7                	cmp    %eax,%edi
  8088c9:	79 0a                	jns    8088d5 <tcp_output+0x40a>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  8088cb:	8b 46 78             	mov    0x78(%esi),%eax
  8088ce:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  8088d0:	89 5e 78             	mov    %ebx,0x78(%esi)
  8088d3:	eb 12                	jmp    8088e7 <tcp_output+0x41c>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  8088d5:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8088d8:	89 18                	mov    %ebx,(%eax)
  8088da:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  8088dd:	eb 08                	jmp    8088e7 <tcp_output+0x41c>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  8088df:	89 1c 24             	mov    %ebx,(%esp)
  8088e2:	e8 3b d4 ff ff       	call   805d22 <tcp_seg_free>
    }
    seg = pcb->unsent;
  8088e7:	8b 5e 74             	mov    0x74(%esi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  8088ea:	85 db                	test   %ebx,%ebx
  8088ec:	74 5a                	je     808948 <tcp_output+0x47d>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  8088ee:	8b 43 10             	mov    0x10(%ebx),%eax
  8088f1:	8b 40 04             	mov    0x4(%eax),%eax
  8088f4:	89 04 24             	mov    %eax,(%esp)
  8088f7:	e8 90 f7 ff ff       	call   80808c <ntohl>
  8088fc:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808900:	2b 56 48             	sub    0x48(%esi),%edx
  808903:	8d 04 02             	lea    (%edx,%eax,1),%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  808906:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  808909:	0f 83 66 fd ff ff    	jae    808675 <tcp_output+0x1aa>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80890f:	80 be a4 00 00 00 00 	cmpb   $0x0,0xa4(%esi)
  808916:	75 30                	jne    808948 <tcp_output+0x47d>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808918:	8b 43 10             	mov    0x10(%ebx),%eax
  80891b:	8b 40 04             	mov    0x4(%eax),%eax
  80891e:	89 04 24             	mov    %eax,(%esp)
  808921:	e8 66 f7 ff ff       	call   80808c <ntohl>
  808926:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80892a:	2b 56 48             	sub    0x48(%esi),%edx
  80892d:	01 c2                	add    %eax,%edx
  80892f:	0f b7 46 5c          	movzwl 0x5c(%esi),%eax
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808933:	39 c2                	cmp    %eax,%edx
  808935:	76 11                	jbe    808948 <tcp_output+0x47d>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  808937:	c7 86 a0 00 00 00 00 	movl   $0x0,0xa0(%esi)
  80893e:	00 00 00 
    pcb->persist_backoff = 1;
  808941:	c6 86 a4 00 00 00 01 	movb   $0x1,0xa4(%esi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  808948:	80 66 20 7f          	andb   $0x7f,0x20(%esi)
  80894c:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  808951:	83 c4 4c             	add    $0x4c,%esp
  808954:	5b                   	pop    %ebx
  808955:	5e                   	pop    %esi
  808956:	5f                   	pop    %edi
  808957:	5d                   	pop    %ebp
  808958:	c3                   	ret    
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808959:	a8 a0                	test   $0xa0,%al
  80895b:	0f 85 65 fd ff ff    	jne    8086c6 <tcp_output+0x1fb>
  808961:	eb ac                	jmp    80890f <tcp_output+0x444>

00808963 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808963:	55                   	push   %ebp
  808964:	89 e5                	mov    %esp,%ebp
  808966:	53                   	push   %ebx
  808967:	83 ec 14             	sub    $0x14,%esp
  80896a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80896d:	8b 43 78             	mov    0x78(%ebx),%eax
  808970:	85 c0                	test   %eax,%eax
  808972:	74 34                	je     8089a8 <tcp_rexmit+0x45>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808974:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808976:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808979:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  80897b:	8b 43 78             	mov    0x78(%ebx),%eax
  80897e:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  808981:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808984:	8b 40 10             	mov    0x10(%eax),%eax
  808987:	8b 40 04             	mov    0x4(%eax),%eax
  80898a:	89 04 24             	mov    %eax,(%esp)
  80898d:	e8 fa f6 ff ff       	call   80808c <ntohl>
  808992:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808995:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808999:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  8089a0:	89 1c 24             	mov    %ebx,(%esp)
  8089a3:	e8 23 fb ff ff       	call   8084cb <tcp_output>
}
  8089a8:	83 c4 14             	add    $0x14,%esp
  8089ab:	5b                   	pop    %ebx
  8089ac:	5d                   	pop    %ebp
  8089ad:	c3                   	ret    

008089ae <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  8089ae:	55                   	push   %ebp
  8089af:	89 e5                	mov    %esp,%ebp
  8089b1:	53                   	push   %ebx
  8089b2:	83 ec 14             	sub    $0x14,%esp
  8089b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8089b8:	8b 43 78             	mov    0x78(%ebx),%eax
  8089bb:	85 c0                	test   %eax,%eax
  8089bd:	74 3e                	je     8089fd <tcp_rexmit_rto+0x4f>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  8089bf:	89 c2                	mov    %eax,%edx
  8089c1:	8b 00                	mov    (%eax),%eax
  8089c3:	85 c0                	test   %eax,%eax
  8089c5:	75 f8                	jne    8089bf <tcp_rexmit_rto+0x11>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  8089c7:	8b 43 74             	mov    0x74(%ebx),%eax
  8089ca:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  8089cc:	8b 43 78             	mov    0x78(%ebx),%eax
  8089cf:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  8089d2:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8089d9:	8b 40 10             	mov    0x10(%eax),%eax
  8089dc:	8b 40 04             	mov    0x4(%eax),%eax
  8089df:	89 04 24             	mov    %eax,(%esp)
  8089e2:	e8 a5 f6 ff ff       	call   80808c <ntohl>
  8089e7:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8089ea:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  8089ee:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  8089f5:	89 1c 24             	mov    %ebx,(%esp)
  8089f8:	e8 ce fa ff ff       	call   8084cb <tcp_output>
}
  8089fd:	83 c4 14             	add    $0x14,%esp
  808a00:	5b                   	pop    %ebx
  808a01:	5d                   	pop    %ebp
  808a02:	c3                   	ret    

00808a03 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  808a03:	55                   	push   %ebp
  808a04:	89 e5                	mov    %esp,%ebp
  808a06:	57                   	push   %edi
  808a07:	56                   	push   %esi
  808a08:	53                   	push   %ebx
  808a09:	83 ec 6c             	sub    $0x6c,%esp
  808a0c:	8b 55 0c             	mov    0xc(%ebp),%edx
  808a0f:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  808a13:	66 89 45 b6          	mov    %ax,-0x4a(%ebp)
  808a17:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  808a1b:	88 4d ae             	mov    %cl,-0x52(%ebp)
  808a1e:	0f b6 5d 18          	movzbl 0x18(%ebp),%ebx
  808a22:	88 5d 98             	mov    %bl,-0x68(%ebp)
  808a25:	0f b6 45 20          	movzbl 0x20(%ebp),%eax
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  808a29:	66 83 7d b6 00       	cmpw   $0x0,-0x4a(%ebp)
  808a2e:	74 20                	je     808a50 <tcp_enqueue+0x4d>
  808a30:	84 c0                	test   %al,%al
  808a32:	74 1c                	je     808a50 <tcp_enqueue+0x4d>
  808a34:	c7 44 24 08 34 22 81 	movl   $0x812234,0x8(%esp)
  808a3b:	00 
  808a3c:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  808a43:	00 
  808a44:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  808a4b:	e8 9c 67 00 00       	call   80f1ec <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  808a50:	85 d2                	test   %edx,%edx
  808a52:	0f 95 45 af          	setne  -0x51(%ebp)
  808a56:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  808a5a:	0f 95 45 bf          	setne  -0x41(%ebp)
  808a5e:	80 7d af 00          	cmpb   $0x0,-0x51(%ebp)
  808a62:	74 22                	je     808a86 <tcp_enqueue+0x83>
  808a64:	80 7d bf 00          	cmpb   $0x0,-0x41(%ebp)
  808a68:	74 1c                	je     808a86 <tcp_enqueue+0x83>
  808a6a:	c7 44 24 08 74 22 81 	movl   $0x812274,0x8(%esp)
  808a71:	00 
  808a72:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
  808a79:	00 
  808a7a:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  808a81:	e8 66 67 00 00       	call   80f1ec <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  808a86:	0f b7 5d b6          	movzwl -0x4a(%ebp),%ebx
  808a8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808a8d:	66 3b 59 6e          	cmp    0x6e(%ecx),%bx
  808a91:	76 0e                	jbe    808aa1 <tcp_enqueue+0x9e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  808a93:	80 49 20 80          	orb    $0x80,0x20(%ecx)
  808a97:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  808a9c:	e9 cd 05 00 00       	jmp    80906e <tcp_enqueue+0x66b>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  808aa1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808aa4:	8b 49 68             	mov    0x68(%ecx),%ecx
  808aa7:	89 4d d0             	mov    %ecx,-0x30(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  808aaa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808aad:	0f b7 5b 70          	movzwl 0x70(%ebx),%ebx
  808ab1:	66 89 5d d6          	mov    %bx,-0x2a(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  808ab5:	66 83 fb 1f          	cmp    $0x1f,%bx
  808ab9:	76 11                	jbe    808acc <tcp_enqueue+0xc9>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  808abb:	8b 45 08             	mov    0x8(%ebp),%eax
  808abe:	80 48 20 80          	orb    $0x80,0x20(%eax)
  808ac2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  808ac7:	e9 a2 05 00 00       	jmp    80906e <tcp_enqueue+0x66b>
  }
  if (queuelen != 0) {
  808acc:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
  808ad1:	74 33                	je     808b06 <tcp_enqueue+0x103>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  808ad3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808ad6:	83 79 78 00          	cmpl   $0x0,0x78(%ecx)
  808ada:	0f 85 a0 05 00 00    	jne    809080 <tcp_enqueue+0x67d>
  808ae0:	83 79 74 00          	cmpl   $0x0,0x74(%ecx)
  808ae4:	0f 85 96 05 00 00    	jne    809080 <tcp_enqueue+0x67d>
  808aea:	c7 44 24 08 bc 22 81 	movl   $0x8122bc,0x8(%esp)
  808af1:	00 
  808af2:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  808af9:	00 
  808afa:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  808b01:	e8 e6 66 00 00       	call   80f1ec <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  808b06:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808b09:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  808b0d:	75 0a                	jne    808b19 <tcp_enqueue+0x116>
  808b0f:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  808b13:	0f 84 67 05 00 00    	je     809080 <tcp_enqueue+0x67d>
  808b19:	c7 44 24 08 f8 22 81 	movl   $0x8122f8,0x8(%esp)
  808b20:	00 
  808b21:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  808b28:	00 
  808b29:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  808b30:	e8 b7 66 00 00       	call   80f1ec <_panic>
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  808b35:	0f b7 f6             	movzwl %si,%esi
  808b38:	01 75 d0             	add    %esi,-0x30(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  808b3b:	01 75 cc             	add    %esi,-0x34(%ebp)
  808b3e:	89 df                	mov    %ebx,%edi
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  808b40:	8b 45 08             	mov    0x8(%ebp),%eax
  808b43:	0f b7 70 34          	movzwl 0x34(%eax),%esi

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  808b47:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808b4e:	e8 b5 bf ff ff       	call   804b08 <memp_malloc>
  808b53:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  808b55:	85 c0                	test   %eax,%eax
  808b57:	0f 84 bb 04 00 00    	je     809018 <tcp_enqueue+0x615>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  808b5d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  808b63:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  808b6a:	80 7d cb 00          	cmpb   $0x0,-0x35(%ebp)
  808b6e:	74 05                	je     808b75 <tcp_enqueue+0x172>
  808b70:	89 45 c0             	mov    %eax,-0x40(%ebp)
  808b73:	eb 22                	jmp    808b97 <tcp_enqueue+0x194>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  808b75:	85 ff                	test   %edi,%edi
  808b77:	75 1c                	jne    808b95 <tcp_enqueue+0x192>
  808b79:	c7 44 24 08 d7 23 81 	movl   $0x8123d7,0x8(%esp)
  808b80:	00 
  808b81:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  808b88:	00 
  808b89:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  808b90:	e8 57 66 00 00       	call   80f1ec <_panic>
      useg->next = seg;
  808b95:	89 07                	mov    %eax,(%edi)
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  808b97:	66 39 75 d8          	cmp    %si,-0x28(%ebp)
  808b9b:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  808b9f:	0f 46 f2             	cmovbe %edx,%esi
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  808ba2:	80 7d bf 00          	cmpb   $0x0,-0x41(%ebp)
  808ba6:	74 69                	je     808c11 <tcp_enqueue+0x20e>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  808ba8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808baf:	00 
  808bb0:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  808bb3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  808bb7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808bbe:	e8 1c c9 ff ff       	call   8054df <pbuf_alloc>
  808bc3:	89 43 04             	mov    %eax,0x4(%ebx)
  808bc6:	85 c0                	test   %eax,%eax
  808bc8:	0f 84 4a 04 00 00    	je     809018 <tcp_enqueue+0x615>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  808bce:	0f b7 55 b8          	movzwl -0x48(%ebp),%edx
  808bd2:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  808bd6:	73 1c                	jae    808bf4 <tcp_enqueue+0x1f1>
  808bd8:	c7 44 24 08 2c 23 81 	movl   $0x81232c,0x8(%esp)
  808bdf:	00 
  808be0:	c7 44 24 04 df 00 00 	movl   $0xdf,0x4(%esp)
  808be7:	00 
  808be8:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  808bef:	e8 f8 65 00 00       	call   80f1ec <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  808bf4:	89 04 24             	mov    %eax,(%esp)
  808bf7:	e8 e4 c1 ff ff       	call   804de0 <pbuf_clen>
  808bfc:	0f b6 c0             	movzbl %al,%eax
  808bff:	66 01 45 d6          	add    %ax,-0x2a(%ebp)
      seg->dataptr = seg->p->payload;
  808c03:	8b 43 04             	mov    0x4(%ebx),%eax
  808c06:	8b 40 04             	mov    0x4(%eax),%eax
  808c09:	89 43 08             	mov    %eax,0x8(%ebx)
  808c0c:	e9 19 01 00 00       	jmp    808d2a <tcp_enqueue+0x327>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  808c11:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  808c15:	0f 84 8b 00 00 00    	je     808ca6 <tcp_enqueue+0x2a3>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  808c1b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808c22:	00 
  808c23:	0f b7 c6             	movzwl %si,%eax
  808c26:	89 44 24 04          	mov    %eax,0x4(%esp)
  808c2a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808c31:	e8 a9 c8 ff ff       	call   8054df <pbuf_alloc>
  808c36:	89 43 04             	mov    %eax,0x4(%ebx)
  808c39:	85 c0                	test   %eax,%eax
  808c3b:	0f 84 d7 03 00 00    	je     809018 <tcp_enqueue+0x615>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  808c41:	66 3b 70 0a          	cmp    0xa(%eax),%si
  808c45:	76 1c                	jbe    808c63 <tcp_enqueue+0x260>
  808c47:	c7 44 24 08 54 23 81 	movl   $0x812354,0x8(%esp)
  808c4e:	00 
  808c4f:	c7 44 24 04 ea 00 00 	movl   $0xea,0x4(%esp)
  808c56:	00 
  808c57:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  808c5e:	e8 89 65 00 00       	call   80f1ec <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  808c63:	89 04 24             	mov    %eax,(%esp)
  808c66:	e8 75 c1 ff ff       	call   804de0 <pbuf_clen>
  808c6b:	89 c7                	mov    %eax,%edi
      if (arg != NULL) {
  808c6d:	80 7d af 00          	cmpb   $0x0,-0x51(%ebp)
  808c71:	74 1c                	je     808c8f <tcp_enqueue+0x28c>
        MEMCPY(seg->p->payload, ptr, seglen);
  808c73:	0f b7 c6             	movzwl %si,%eax
  808c76:	89 44 24 08          	mov    %eax,0x8(%esp)
  808c7a:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  808c7d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  808c81:	8b 43 04             	mov    0x4(%ebx),%eax
  808c84:	8b 40 04             	mov    0x4(%eax),%eax
  808c87:	89 04 24             	mov    %eax,(%esp)
  808c8a:	e8 9c 6e 00 00       	call   80fb2b <memcpy>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  808c8f:	89 fa                	mov    %edi,%edx
  808c91:	0f b6 c2             	movzbl %dl,%eax
  808c94:	66 01 45 d6          	add    %ax,-0x2a(%ebp)
      if (arg != NULL) {
        MEMCPY(seg->p->payload, ptr, seglen);
      }
      seg->dataptr = seg->p->payload;
  808c98:	8b 43 04             	mov    0x4(%ebx),%eax
  808c9b:	8b 40 04             	mov    0x4(%eax),%eax
  808c9e:	89 43 08             	mov    %eax,0x8(%ebx)
  808ca1:	e9 84 00 00 00       	jmp    808d2a <tcp_enqueue+0x327>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  808ca6:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  808cad:	00 
  808cae:	0f b7 c6             	movzwl %si,%eax
  808cb1:	89 44 24 04          	mov    %eax,0x4(%esp)
  808cb5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808cbc:	e8 1e c8 ff ff       	call   8054df <pbuf_alloc>
  808cc1:	89 c7                	mov    %eax,%edi
  808cc3:	85 c0                	test   %eax,%eax
  808cc5:	0f 84 4d 03 00 00    	je     809018 <tcp_enqueue+0x615>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
      /* reference the non-volatile payload data */
      p->payload = ptr;
  808ccb:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  808cce:	89 48 04             	mov    %ecx,0x4(%eax)
      seg->dataptr = ptr;
  808cd1:	89 4b 08             	mov    %ecx,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  808cd4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808cdb:	00 
  808cdc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808ce3:	00 
  808ce4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808ceb:	e8 ef c7 ff ff       	call   8054df <pbuf_alloc>
  808cf0:	89 43 04             	mov    %eax,0x4(%ebx)
  808cf3:	85 c0                	test   %eax,%eax
  808cf5:	75 0d                	jne    808d04 <tcp_enqueue+0x301>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  808cf7:	89 3c 24             	mov    %edi,(%esp)
  808cfa:	e8 25 c5 ff ff       	call   805224 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  808cff:	e9 14 03 00 00       	jmp    809018 <tcp_enqueue+0x615>
      }
      queuelen += pbuf_clen(seg->p);
  808d04:	89 04 24             	mov    %eax,(%esp)
  808d07:	e8 d4 c0 ff ff       	call   804de0 <pbuf_clen>
  808d0c:	0f b6 c0             	movzbl %al,%eax
  808d0f:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
  808d13:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  808d17:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  808d1b:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808d1f:	8b 43 04             	mov    0x4(%ebx),%eax
  808d22:	89 04 24             	mov    %eax,(%esp)
  808d25:	e8 df c0 ff ff       	call   804e09 <pbuf_cat>
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  808d2a:	66 83 7d d6 20       	cmpw   $0x20,-0x2a(%ebp)
  808d2f:	0f 87 e3 02 00 00    	ja     809018 <tcp_enqueue+0x615>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  808d35:	66 89 73 0c          	mov    %si,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  808d39:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808d40:	00 
  808d41:	8b 43 04             	mov    0x4(%ebx),%eax
  808d44:	89 04 24             	mov    %eax,(%esp)
  808d47:	e8 7b c1 ff ff       	call   804ec7 <pbuf_header>
  808d4c:	84 c0                	test   %al,%al
  808d4e:	0f 85 c4 02 00 00    	jne    809018 <tcp_enqueue+0x615>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  808d54:	8b 43 04             	mov    0x4(%ebx),%eax
  808d57:	8b 78 04             	mov    0x4(%eax),%edi
  808d5a:	89 7b 10             	mov    %edi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  808d5d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808d60:	0f b7 41 1c          	movzwl 0x1c(%ecx),%eax
  808d64:	89 04 24             	mov    %eax,(%esp)
  808d67:	e8 f3 f0 ff ff       	call   807e5f <htons>
  808d6c:	66 89 07             	mov    %ax,(%edi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  808d6f:	8b 7b 10             	mov    0x10(%ebx),%edi
  808d72:	8b 55 08             	mov    0x8(%ebp),%edx
  808d75:	0f b7 42 1e          	movzwl 0x1e(%edx),%eax
  808d79:	89 04 24             	mov    %eax,(%esp)
  808d7c:	e8 de f0 ff ff       	call   807e5f <htons>
  808d81:	66 89 47 02          	mov    %ax,0x2(%edi)
    seg->tcphdr->seqno = htonl(seqno);
  808d85:	8b 7b 10             	mov    0x10(%ebx),%edi
  808d88:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  808d8b:	89 0c 24             	mov    %ecx,(%esp)
  808d8e:	e8 ed f0 ff ff       	call   807e80 <htonl>
  808d93:	89 47 04             	mov    %eax,0x4(%edi)
    seg->tcphdr->urgp = 0;
  808d96:	8b 43 10             	mov    0x10(%ebx),%eax
  808d99:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  808d9f:	8b 7b 10             	mov    0x10(%ebx),%edi
  808da2:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  808da6:	89 04 24             	mov    %eax,(%esp)
  808da9:	e8 be f0 ff ff       	call   807e6c <ntohs>
  808dae:	83 e0 c0             	and    $0xffffffc0,%eax
  808db1:	66 0b 45 bc          	or     -0x44(%ebp),%ax
  808db5:	0f b7 c0             	movzwl %ax,%eax
  808db8:	89 04 24             	mov    %eax,(%esp)
  808dbb:	e8 9f f0 ff ff       	call   807e5f <htons>
  808dc0:	66 89 47 0c          	mov    %ax,0xc(%edi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  808dc4:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  808dc8:	75 23                	jne    808ded <tcp_enqueue+0x3ea>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  808dca:	8b 7b 10             	mov    0x10(%ebx),%edi
  808dcd:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  808dd1:	89 04 24             	mov    %eax,(%esp)
  808dd4:	e8 93 f0 ff ff       	call   807e6c <ntohs>
  808dd9:	83 e0 3f             	and    $0x3f,%eax
  808ddc:	80 cc 50             	or     $0x50,%ah
  808ddf:	89 04 24             	mov    %eax,(%esp)
  808de2:	e8 78 f0 ff ff       	call   807e5f <htons>
  808de7:	66 89 47 0c          	mov    %ax,0xc(%edi)
  808deb:	eb 3e                	jmp    808e2b <tcp_enqueue+0x428>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  808ded:	8b 7b 10             	mov    0x10(%ebx),%edi
  808df0:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  808df4:	89 04 24             	mov    %eax,(%esp)
  808df7:	e8 70 f0 ff ff       	call   807e6c <ntohs>
  808dfc:	83 e0 3f             	and    $0x3f,%eax
  808dff:	66 0b 45 ba          	or     -0x46(%ebp),%ax
  808e03:	0f b7 c0             	movzwl %ax,%eax
  808e06:	89 04 24             	mov    %eax,(%esp)
  808e09:	e8 51 f0 ff ff       	call   807e5f <htons>
  808e0e:	66 89 47 0c          	mov    %ax,0xc(%edi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  808e12:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  808e15:	89 44 24 08          	mov    %eax,0x8(%esp)
  808e19:	8b 55 1c             	mov    0x1c(%ebp),%edx
  808e1c:	89 54 24 04          	mov    %edx,0x4(%esp)
  808e20:	8b 43 08             	mov    0x8(%ebx),%eax
  808e23:	89 04 24             	mov    %eax,(%esp)
  808e26:	e8 00 6d 00 00       	call   80fb2b <memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  808e2b:	66 29 75 d8          	sub    %si,-0x28(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  808e2f:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  808e33:	0f 94 45 cb          	sete   -0x35(%ebp)
  808e37:	0f 84 f8 fc ff ff    	je     808b35 <tcp_enqueue+0x132>
  808e3d:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
  808e42:	0f 85 ed fc ff ff    	jne    808b35 <tcp_enqueue+0x132>
  808e48:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  808e4b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808e4e:	8b 79 74             	mov    0x74(%ecx),%edi
  808e51:	85 ff                	test   %edi,%edi
  808e53:	0f 84 0c 01 00 00    	je     808f65 <tcp_enqueue+0x562>
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  808e59:	89 f8                	mov    %edi,%eax
  808e5b:	8b 3f                	mov    (%edi),%edi
  808e5d:	85 ff                	test   %edi,%edi
  808e5f:	75 f8                	jne    808e59 <tcp_enqueue+0x456>
  808e61:	89 c7                	mov    %eax,%edi
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  808e63:	85 c0                	test   %eax,%eax
  808e65:	0f 84 fa 00 00 00    	je     808f65 <tcp_enqueue+0x562>
    TCP_TCPLEN(useg) != 0 &&
  808e6b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808e6f:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
  808e73:	8b 47 10             	mov    0x10(%edi),%eax
  808e76:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808e7a:	89 04 24             	mov    %eax,(%esp)
  808e7d:	e8 ea ef ff ff       	call   807e6c <ntohs>
  808e82:	a8 01                	test   $0x1,%al
  808e84:	75 18                	jne    808e9e <tcp_enqueue+0x49b>
  808e86:	8b 47 10             	mov    0x10(%edi),%eax
  808e89:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808e8d:	89 04 24             	mov    %eax,(%esp)
  808e90:	e8 d7 ef ff ff       	call   807e6c <ntohs>
  808e95:	ba 00 00 00 00       	mov    $0x0,%edx
  808e9a:	a8 02                	test   $0x2,%al
  808e9c:	74 05                	je     808ea3 <tcp_enqueue+0x4a0>
  808e9e:	ba 01 00 00 00       	mov    $0x1,%edx
  808ea3:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  808ea7:	01 c2                	add    %eax,%edx
  808ea9:	0f 84 c7 01 00 00    	je     809076 <tcp_enqueue+0x673>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  808eaf:	8b 47 10             	mov    0x10(%edi),%eax
  808eb2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808eb6:	89 04 24             	mov    %eax,(%esp)
  808eb9:	e8 ae ef ff ff       	call   807e6c <ntohs>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  808ebe:	a8 03                	test   $0x3,%al
  808ec0:	0f 85 b0 01 00 00    	jne    809076 <tcp_enqueue+0x673>
  808ec6:	f6 45 ae 03          	testb  $0x3,-0x52(%ebp)
  808eca:	0f 85 a6 01 00 00    	jne    809076 <tcp_enqueue+0x673>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  808ed0:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  808ed3:	0f b7 51 0c          	movzwl 0xc(%ecx),%edx
  808ed7:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  808edb:	01 c2                	add    %eax,%edx
  808edd:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808ee0:	0f b7 41 34          	movzwl 0x34(%ecx),%eax
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  808ee4:	39 c2                	cmp    %eax,%edx
  808ee6:	0f 8f 8a 01 00 00    	jg     809076 <tcp_enqueue+0x673>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  808eec:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  808ef3:	ff 
  808ef4:	8b 55 c0             	mov    -0x40(%ebp),%edx
  808ef7:	8b 42 04             	mov    0x4(%edx),%eax
  808efa:	89 04 24             	mov    %eax,(%esp)
  808efd:	e8 c5 bf ff ff       	call   804ec7 <pbuf_header>
  808f02:	84 c0                	test   %al,%al
  808f04:	74 1c                	je     808f22 <tcp_enqueue+0x51f>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808f06:	c7 44 24 08 e4 23 81 	movl   $0x8123e4,0x8(%esp)
  808f0d:	00 
  808f0e:	c7 44 24 04 52 01 00 	movl   $0x152,0x4(%esp)
  808f15:	00 
  808f16:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  808f1d:	e8 ca 62 00 00       	call   80f1ec <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  808f22:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  808f25:	8b 41 04             	mov    0x4(%ecx),%eax
  808f28:	89 44 24 04          	mov    %eax,0x4(%esp)
  808f2c:	8b 47 04             	mov    0x4(%edi),%eax
  808f2f:	89 04 24             	mov    %eax,(%esp)
  808f32:	e8 d2 be ff ff       	call   804e09 <pbuf_cat>
    useg->len += queue->len;
  808f37:	8b 55 c0             	mov    -0x40(%ebp),%edx
  808f3a:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  808f3e:	66 01 47 0c          	add    %ax,0xc(%edi)
    useg->next = queue->next;
  808f42:	8b 02                	mov    (%edx),%eax
  808f44:	89 07                	mov    %eax,(%edi)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  808f46:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  808f49:	39 ca                	cmp    %ecx,%edx
  808f4b:	b8 00 00 00 00       	mov    $0x0,%eax
  808f50:	0f 44 d8             	cmove  %eax,%ebx
      seg = NULL;
    }
    memp_free(MEMP_TCP_SEG, queue);
  808f53:	89 54 24 04          	mov    %edx,0x4(%esp)
  808f57:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808f5e:	e8 61 bb ff ff       	call   804ac4 <memp_free>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  808f63:	eb 09                	jmp    808f6e <tcp_enqueue+0x56b>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  808f65:	8b 55 c0             	mov    -0x40(%ebp),%edx
  808f68:	8b 45 08             	mov    0x8(%ebp),%eax
  808f6b:	89 50 74             	mov    %edx,0x74(%eax)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  808f6e:	f6 45 ae 02          	testb  $0x2,-0x52(%ebp)
  808f72:	75 0c                	jne    808f80 <tcp_enqueue+0x57d>
  808f74:	f6 45 ae 01          	testb  $0x1,-0x52(%ebp)
  808f78:	0f 85 52 01 00 00    	jne    8090d0 <tcp_enqueue+0x6cd>
  808f7e:	eb 12                	jmp    808f92 <tcp_enqueue+0x58f>
    ++len;
  808f80:	66 83 45 b6 01       	addw   $0x1,-0x4a(%ebp)
  }
  if (flags & TCP_FIN) {
  808f85:	f6 45 ae 01          	testb  $0x1,-0x52(%ebp)
  808f89:	74 07                	je     808f92 <tcp_enqueue+0x58f>
    pcb->flags |= TF_FIN;
  808f8b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808f8e:	80 49 20 20          	orb    $0x20,0x20(%ecx)
  }
  pcb->snd_lbb += len;
  808f92:	0f b7 45 b6          	movzwl -0x4a(%ebp),%eax
  808f96:	8b 55 08             	mov    0x8(%ebp),%edx
  808f99:	01 42 68             	add    %eax,0x68(%edx)

  pcb->snd_buf -= len;
  808f9c:	0f b7 4d b6          	movzwl -0x4a(%ebp),%ecx
  808fa0:	66 29 4a 6e          	sub    %cx,0x6e(%edx)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  808fa4:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  808fa8:	66 89 42 70          	mov    %ax,0x70(%edx)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  808fac:	66 85 c0             	test   %ax,%ax
  808faf:	74 28                	je     808fd9 <tcp_enqueue+0x5d6>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  808fb1:	83 7a 78 00          	cmpl   $0x0,0x78(%edx)
  808fb5:	75 22                	jne    808fd9 <tcp_enqueue+0x5d6>
  808fb7:	83 7a 74 00          	cmpl   $0x0,0x74(%edx)
  808fbb:	75 1c                	jne    808fd9 <tcp_enqueue+0x5d6>
  808fbd:	c7 44 24 08 88 23 81 	movl   $0x812388,0x8(%esp)
  808fc4:	00 
  808fc5:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
  808fcc:	00 
  808fcd:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  808fd4:	e8 13 62 00 00       	call   80f1ec <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  808fd9:	85 db                	test   %ebx,%ebx
  808fdb:	0f 84 81 00 00 00    	je     809062 <tcp_enqueue+0x65f>
  808fe1:	66 85 f6             	test   %si,%si
  808fe4:	74 7c                	je     809062 <tcp_enqueue+0x65f>
  808fe6:	8b 5b 10             	mov    0x10(%ebx),%ebx
  808fe9:	85 db                	test   %ebx,%ebx
  808feb:	74 75                	je     809062 <tcp_enqueue+0x65f>
  808fed:	f6 45 98 02          	testb  $0x2,-0x68(%ebp)
  808ff1:	75 6f                	jne    809062 <tcp_enqueue+0x65f>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  808ff3:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808ff7:	89 04 24             	mov    %eax,(%esp)
  808ffa:	e8 6d ee ff ff       	call   807e6c <ntohs>
  808fff:	83 c8 08             	or     $0x8,%eax
  809002:	0f b7 c0             	movzwl %ax,%eax
  809005:	89 04 24             	mov    %eax,(%esp)
  809008:	e8 52 ee ff ff       	call   807e5f <htons>
  80900d:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  809011:	b8 00 00 00 00       	mov    $0x0,%eax
  809016:	eb 56                	jmp    80906e <tcp_enqueue+0x66b>
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  809018:	8b 55 08             	mov    0x8(%ebp),%edx
  80901b:	80 4a 20 80          	orb    $0x80,0x20(%edx)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  80901f:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  809023:	74 0b                	je     809030 <tcp_enqueue+0x62d>
    tcp_segs_free(queue);
  809025:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  809028:	89 0c 24             	mov    %ecx,(%esp)
  80902b:	e8 37 cd ff ff       	call   805d67 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  809030:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809033:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  809038:	74 2f                	je     809069 <tcp_enqueue+0x666>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  80903a:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80903e:	75 29                	jne    809069 <tcp_enqueue+0x666>
  809040:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  809044:	75 23                	jne    809069 <tcp_enqueue+0x666>
  809046:	c7 44 24 08 88 23 81 	movl   $0x812388,0x8(%esp)
  80904d:	00 
  80904e:	c7 44 24 04 8d 01 00 	movl   $0x18d,0x4(%esp)
  809055:	00 
  809056:	c7 04 24 a8 23 81 00 	movl   $0x8123a8,(%esp)
  80905d:	e8 8a 61 00 00       	call   80f1ec <_panic>
  809062:	b8 00 00 00 00       	mov    $0x0,%eax
  809067:	eb 05                	jmp    80906e <tcp_enqueue+0x66b>
  809069:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  80906e:	83 c4 6c             	add    $0x6c,%esp
  809071:	5b                   	pop    %ebx
  809072:	5e                   	pop    %esi
  809073:	5f                   	pop    %edi
  809074:	5d                   	pop    %ebp
  809075:	c3                   	ret    
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  809076:	8b 45 c0             	mov    -0x40(%ebp),%eax
  809079:	89 07                	mov    %eax,(%edi)
  80907b:	e9 ee fe ff ff       	jmp    808f6e <tcp_enqueue+0x56b>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  809080:	89 c1                	mov    %eax,%ecx
  809082:	c0 e9 02             	shr    $0x2,%cl
  809085:	c1 e1 0c             	shl    $0xc,%ecx
  809088:	66 81 c1 00 50       	add    $0x5000,%cx
  80908d:	66 89 4d ba          	mov    %cx,-0x46(%ebp)
  809091:	89 55 cc             	mov    %edx,-0x34(%ebp)
  809094:	0f b7 55 b6          	movzwl -0x4a(%ebp),%edx
  809098:	66 89 55 d8          	mov    %dx,-0x28(%ebp)
  80909c:	c6 45 cb 01          	movb   $0x1,-0x35(%ebp)
  8090a0:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  8090a7:	bf 00 00 00 00       	mov    $0x0,%edi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  8090ac:	0f b6 4d 98          	movzbl -0x68(%ebp),%ecx
  8090b0:	83 e1 01             	and    $0x1,%ecx
  8090b3:	89 4d b0             	mov    %ecx,-0x50(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  8090b6:	0f b6 d8             	movzbl %al,%ebx
  8090b9:	89 5d c4             	mov    %ebx,-0x3c(%ebp)
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  8090bc:	0f b6 c0             	movzbl %al,%eax
  8090bf:	66 89 45 b8          	mov    %ax,-0x48(%ebp)
    seg->tcphdr = seg->p->payload;
    seg->tcphdr->src = htons(pcb->local_port);
    seg->tcphdr->dest = htons(pcb->remote_port);
    seg->tcphdr->seqno = htonl(seqno);
    seg->tcphdr->urgp = 0;
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  8090c3:	0f b6 45 ae          	movzbl -0x52(%ebp),%eax
  8090c7:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
  8090cb:	e9 70 fa ff ff       	jmp    808b40 <tcp_enqueue+0x13d>
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    ++len;
  8090d0:	66 83 45 b6 01       	addw   $0x1,-0x4a(%ebp)
  8090d5:	e9 b1 fe ff ff       	jmp    808f8b <tcp_enqueue+0x588>

008090da <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  8090da:	55                   	push   %ebp
  8090db:	89 e5                	mov    %esp,%ebp
  8090dd:	83 ec 28             	sub    $0x28,%esp
  8090e0:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8090e3:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8090e6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8090e9:	0f b7 5d 10          	movzwl 0x10(%ebp),%ebx
  8090ed:	0f b6 75 14          	movzbl 0x14(%ebp),%esi
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  8090f1:	8b 51 10             	mov    0x10(%ecx),%edx
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  8090f4:	83 fa 04             	cmp    $0x4,%edx
  8090f7:	74 14                	je     80910d <tcp_write+0x33>
  8090f9:	83 fa 07             	cmp    $0x7,%edx
  8090fc:	74 0f                	je     80910d <tcp_write+0x33>
  8090fe:	83 fa 02             	cmp    $0x2,%edx
  809101:	74 0a                	je     80910d <tcp_write+0x33>
  809103:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  809108:	83 fa 03             	cmp    $0x3,%edx
  80910b:	75 42                	jne    80914f <tcp_write+0x75>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  80910d:	b8 00 00 00 00       	mov    $0x0,%eax
  809112:	66 85 db             	test   %bx,%bx
  809115:	74 38                	je     80914f <tcp_write+0x75>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  809117:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80911e:	00 
  80911f:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  809126:	00 
  809127:	81 e6 ff 00 00 00    	and    $0xff,%esi
  80912d:	89 74 24 10          	mov    %esi,0x10(%esp)
  809131:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  809138:	00 
  809139:	0f b7 db             	movzwl %bx,%ebx
  80913c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  809140:	8b 45 0c             	mov    0xc(%ebp),%eax
  809143:	89 44 24 04          	mov    %eax,0x4(%esp)
  809147:	89 0c 24             	mov    %ecx,(%esp)
  80914a:	e8 b4 f8 ff ff       	call   808a03 <tcp_enqueue>
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  }
}
  80914f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  809152:	8b 75 fc             	mov    -0x4(%ebp),%esi
  809155:	89 ec                	mov    %ebp,%esp
  809157:	5d                   	pop    %ebp
  809158:	c3                   	ret    

00809159 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  809159:	55                   	push   %ebp
  80915a:	89 e5                	mov    %esp,%ebp
  80915c:	83 ec 28             	sub    $0x28,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  80915f:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  809166:	00 
  809167:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80916e:	00 
  80916f:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  809176:	00 
  809177:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80917b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80917f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809186:	00 
  809187:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80918e:	00 
  80918f:	8b 45 08             	mov    0x8(%ebp),%eax
  809192:	89 04 24             	mov    %eax,(%esp)
  809195:	e8 69 f8 ff ff       	call   808a03 <tcp_enqueue>
}
  80919a:	c9                   	leave  
  80919b:	c3                   	ret    
  80919c:	00 00                	add    %al,(%eax)
	...

008091a0 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  8091a0:	55                   	push   %ebp
  8091a1:	89 e5                	mov    %esp,%ebp
  8091a3:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  8091a6:	8b 15 64 20 81 00    	mov    0x812064,%edx
  8091ac:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  8091af:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  8091b5:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  8091b9:	5d                   	pop    %ebp
  8091ba:	c3                   	ret    

008091bb <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  8091bb:	55                   	push   %ebp
  8091bc:	89 e5                	mov    %esp,%ebp
  8091be:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  8091c1:	8b 55 0c             	mov    0xc(%ebp),%edx
  8091c4:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  8091c7:	8b 55 10             	mov    0x10(%ebp),%edx
  8091ca:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  8091cd:	5d                   	pop    %ebp
  8091ce:	c3                   	ret    

008091cf <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  8091cf:	55                   	push   %ebp
  8091d0:	89 e5                	mov    %esp,%ebp
  8091d2:	53                   	push   %ebx
  8091d3:	83 ec 14             	sub    $0x14,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  8091d6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8091dd:	e8 26 b9 ff ff       	call   804b08 <memp_malloc>
  8091e2:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  8091e4:	85 c0                	test   %eax,%eax
  8091e6:	74 1c                	je     809204 <udp_new+0x35>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  8091e8:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  8091ef:	00 
  8091f0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8091f7:	00 
  8091f8:	89 04 24             	mov    %eax,(%esp)
  8091fb:	e8 50 68 00 00       	call   80fa50 <memset>
    pcb->ttl = UDP_TTL;
  809200:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  }
  return pcb;
}
  809204:	89 d8                	mov    %ebx,%eax
  809206:	83 c4 14             	add    $0x14,%esp
  809209:	5b                   	pop    %ebx
  80920a:	5d                   	pop    %ebp
  80920b:	c3                   	ret    

0080920c <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  80920c:	55                   	push   %ebp
  80920d:	89 e5                	mov    %esp,%ebp
  80920f:	83 ec 18             	sub    $0x18,%esp
  809212:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  809215:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  80921a:	39 c8                	cmp    %ecx,%eax
  80921c:	75 1e                	jne    80923c <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  80921e:	8b 40 0c             	mov    0xc(%eax),%eax
  809221:	a3 54 b2 b3 00       	mov    %eax,0xb3b254
  809226:	eb 18                	jmp    809240 <udp_remove+0x34>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  809228:	8b 50 0c             	mov    0xc(%eax),%edx
  80922b:	85 d2                	test   %edx,%edx
  80922d:	74 0a                	je     809239 <udp_remove+0x2d>
  80922f:	39 d1                	cmp    %edx,%ecx
  809231:	75 06                	jne    809239 <udp_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  809233:	8b 51 0c             	mov    0xc(%ecx),%edx
  809236:	89 50 0c             	mov    %edx,0xc(%eax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  809239:	8b 40 0c             	mov    0xc(%eax),%eax
  80923c:	85 c0                	test   %eax,%eax
  80923e:	75 e8                	jne    809228 <udp_remove+0x1c>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  809240:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  809244:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80924b:	e8 74 b8 ff ff       	call   804ac4 <memp_free>
}
  809250:	c9                   	leave  
  809251:	c3                   	ret    

00809252 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  809252:	55                   	push   %ebp
  809253:	89 e5                	mov    %esp,%ebp
  809255:	57                   	push   %edi
  809256:	56                   	push   %esi
  809257:	53                   	push   %ebx
  809258:	83 ec 1c             	sub    $0x1c,%esp
  80925b:	8b 55 08             	mov    0x8(%ebp),%edx
  80925e:	8b 7d 0c             	mov    0xc(%ebp),%edi
  809261:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809265:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  80926a:	b9 00 00 00 00       	mov    $0x0,%ecx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80926f:	bb 01 00 00 00       	mov    $0x1,%ebx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809274:	eb 29                	jmp    80929f <udp_bind+0x4d>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  809276:	39 c2                	cmp    %eax,%edx
  809278:	75 22                	jne    80929c <udp_bind+0x4a>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80927a:	84 c9                	test   %cl,%cl
  80927c:	74 1c                	je     80929a <udp_bind+0x48>
  80927e:	c7 44 24 08 f8 23 81 	movl   $0x8123f8,0x8(%esp)
  809285:	00 
  809286:	c7 44 24 04 41 02 00 	movl   $0x241,0x4(%esp)
  80928d:	00 
  80928e:	c7 04 24 04 24 81 00 	movl   $0x812404,(%esp)
  809295:	e8 52 5f 00 00       	call   80f1ec <_panic>
  80929a:	89 d9                	mov    %ebx,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80929c:	8b 40 0c             	mov    0xc(%eax),%eax
  80929f:	85 c0                	test   %eax,%eax
  8092a1:	75 d3                	jne    809276 <udp_bind+0x24>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  8092a3:	85 ff                	test   %edi,%edi
  8092a5:	74 02                	je     8092a9 <udp_bind+0x57>
  8092a7:	8b 07                	mov    (%edi),%eax
  8092a9:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  8092ab:	66 85 f6             	test   %si,%si
  8092ae:	75 39                	jne    8092e9 <udp_bind+0x97>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  8092b0:	8b 3d 54 b2 b3 00    	mov    0xb3b254,%edi
  8092b6:	89 f8                	mov    %edi,%eax
  8092b8:	be 00 10 00 00       	mov    $0x1000,%esi
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  8092bd:	eb 13                	jmp    8092d2 <udp_bind+0x80>
      if (ipcb->local_port == port) {
  8092bf:	0f b7 58 12          	movzwl 0x12(%eax),%ebx
  8092c3:	66 39 f3             	cmp    %si,%bx
  8092c6:	75 07                	jne    8092cf <udp_bind+0x7d>
        /* port is already used by another udp_pcb */
        port++;
  8092c8:	8d 73 01             	lea    0x1(%ebx),%esi
  8092cb:	89 f8                	mov    %edi,%eax
  8092cd:	eb 03                	jmp    8092d2 <udp_bind+0x80>
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  8092cf:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  8092d2:	85 c0                	test   %eax,%eax
  8092d4:	0f 95 c3             	setne  %bl
  8092d7:	74 07                	je     8092e0 <udp_bind+0x8e>
  8092d9:	66 81 fe ff 7f       	cmp    $0x7fff,%si
  8092de:	75 df                	jne    8092bf <udp_bind+0x6d>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  8092e0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8092e5:	84 db                	test   %bl,%bl
  8092e7:	75 20                	jne    809309 <udp_bind+0xb7>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  8092e9:	66 89 72 12          	mov    %si,0x12(%edx)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  8092ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8092f2:	84 c9                	test   %cl,%cl
  8092f4:	75 13                	jne    809309 <udp_bind+0xb7>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  8092f6:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  8092fb:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  8092fe:	89 15 54 b2 b3 00    	mov    %edx,0xb3b254
  809304:	b8 00 00 00 00       	mov    $0x0,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  809309:	83 c4 1c             	add    $0x1c,%esp
  80930c:	5b                   	pop    %ebx
  80930d:	5e                   	pop    %esi
  80930e:	5f                   	pop    %edi
  80930f:	5d                   	pop    %ebp
  809310:	c3                   	ret    

00809311 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  809311:	55                   	push   %ebp
  809312:	89 e5                	mov    %esp,%ebp
  809314:	57                   	push   %edi
  809315:	56                   	push   %esi
  809316:	53                   	push   %ebx
  809317:	83 ec 1c             	sub    $0x1c,%esp
  80931a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80931d:	8b 7d 0c             	mov    0xc(%ebp),%edi
  809320:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  809324:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  809329:	75 18                	jne    809343 <udp_connect+0x32>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80932b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809332:	00 
  809333:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809337:	89 1c 24             	mov    %ebx,(%esp)
  80933a:	e8 13 ff ff ff       	call   809252 <udp_bind>
    if (err != ERR_OK)
  80933f:	84 c0                	test   %al,%al
  809341:	75 3b                	jne    80937e <udp_connect+0x6d>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  809343:	b8 00 00 00 00       	mov    $0x0,%eax
  809348:	85 ff                	test   %edi,%edi
  80934a:	74 02                	je     80934e <udp_connect+0x3d>
  80934c:	8b 07                	mov    (%edi),%eax
  80934e:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  809351:	66 89 73 14          	mov    %si,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  809355:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809359:	8b 15 54 b2 b3 00    	mov    0xb3b254,%edx
  80935f:	89 d0                	mov    %edx,%eax
  809361:	eb 0e                	jmp    809371 <udp_connect+0x60>
    if (pcb == ipcb) {
  809363:	39 c3                	cmp    %eax,%ebx
  809365:	75 07                	jne    80936e <udp_connect+0x5d>
  809367:	b8 00 00 00 00       	mov    $0x0,%eax
  80936c:	eb 10                	jmp    80937e <udp_connect+0x6d>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80936e:	8b 40 0c             	mov    0xc(%eax),%eax
  809371:	85 c0                	test   %eax,%eax
  809373:	75 ee                	jne    809363 <udp_connect+0x52>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  809375:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  809378:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  return ERR_OK;
}
  80937e:	83 c4 1c             	add    $0x1c,%esp
  809381:	5b                   	pop    %ebx
  809382:	5e                   	pop    %esi
  809383:	5f                   	pop    %edi
  809384:	5d                   	pop    %ebp
  809385:	c3                   	ret    

00809386 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  809386:	55                   	push   %ebp
  809387:	89 e5                	mov    %esp,%ebp
  809389:	57                   	push   %edi
  80938a:	56                   	push   %esi
  80938b:	53                   	push   %ebx
  80938c:	83 ec 3c             	sub    $0x3c,%esp
  80938f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809392:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  809396:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  80939a:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80939f:	75 1e                	jne    8093bf <udp_sendto_if+0x39>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  8093a1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8093a8:	00 
  8093a9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8093ad:	89 1c 24             	mov    %ebx,(%esp)
  8093b0:	e8 9d fe ff ff       	call   809252 <udp_bind>
  8093b5:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  8093b7:	84 c0                	test   %al,%al
  8093b9:	0f 85 6b 01 00 00    	jne    80952a <udp_sendto_if+0x1a4>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  8093bf:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  8093c6:	00 
  8093c7:	8b 55 0c             	mov    0xc(%ebp),%edx
  8093ca:	89 14 24             	mov    %edx,(%esp)
  8093cd:	e8 f5 ba ff ff       	call   804ec7 <pbuf_header>
  8093d2:	84 c0                	test   %al,%al
  8093d4:	75 05                	jne    8093db <udp_sendto_if+0x55>
  8093d6:	8b 75 0c             	mov    0xc(%ebp),%esi
  8093d9:	eb 3a                	jmp    809415 <udp_sendto_if+0x8f>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  8093db:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8093e2:	00 
  8093e3:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  8093ea:	00 
  8093eb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8093f2:	e8 e8 c0 ff ff       	call   8054df <pbuf_alloc>
  8093f7:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  8093f9:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  8093fe:	85 c0                	test   %eax,%eax
  809400:	0f 84 24 01 00 00    	je     80952a <udp_sendto_if+0x1a4>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  809406:	8b 45 0c             	mov    0xc(%ebp),%eax
  809409:	89 44 24 04          	mov    %eax,0x4(%esp)
  80940d:	89 34 24             	mov    %esi,(%esp)
  809410:	e8 8b ba ff ff       	call   804ea0 <pbuf_chain>
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  809415:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  80941a:	77 1c                	ja     809438 <udp_sendto_if+0xb2>
  80941c:	c7 44 24 08 2c 24 81 	movl   $0x81242c,0x8(%esp)
  809423:	00 
  809424:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80942b:	00 
  80942c:	c7 04 24 04 24 81 00 	movl   $0x812404,(%esp)
  809433:	e8 b4 5d 00 00       	call   80f1ec <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  809438:	8b 7e 04             	mov    0x4(%esi),%edi
  udphdr->src = htons(pcb->local_port);
  80943b:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  80943f:	89 04 24             	mov    %eax,(%esp)
  809442:	e8 18 ea ff ff       	call   807e5f <htons>
  809447:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  80944a:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80944e:	89 04 24             	mov    %eax,(%esp)
  809451:	e8 09 ea ff ff       	call   807e5f <htons>
  809456:	66 89 47 02          	mov    %ax,0x2(%edi)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  80945a:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  809460:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  809463:	85 db                	test   %ebx,%ebx
  809465:	74 06                	je     80946d <udp_sendto_if+0xe7>
  809467:	8b 03                	mov    (%ebx),%eax
  809469:	85 c0                	test   %eax,%eax
  80946b:	75 0b                	jne    809478 <udp_sendto_if+0xf2>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80946d:	8b 55 18             	mov    0x18(%ebp),%edx
  809470:	83 c2 04             	add    $0x4,%edx
  809473:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  udphdr->dest = htons(dst_port);
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  809476:	eb 23                	jmp    80949b <udp_sendto_if+0x115>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  809478:	8b 55 18             	mov    0x18(%ebp),%edx
  80947b:	3b 42 04             	cmp    0x4(%edx),%eax
  80947e:	74 1b                	je     80949b <udp_sendto_if+0x115>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  809480:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
  809485:	3b 75 0c             	cmp    0xc(%ebp),%esi
  809488:	0f 84 9c 00 00 00    	je     80952a <udp_sendto_if+0x1a4>
        /* free the header pbuf */
        pbuf_free(q);
  80948e:	89 34 24             	mov    %esi,(%esp)
  809491:	e8 8e bd ff ff       	call   805224 <pbuf_free>
  809496:	e9 8f 00 00 00       	jmp    80952a <udp_sendto_if+0x1a4>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  80949b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80949f:	89 04 24             	mov    %eax,(%esp)
  8094a2:	e8 b8 e9 ff ff       	call   807e5f <htons>
  8094a7:	66 89 47 04          	mov    %ax,0x4(%edi)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  8094ab:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  8094af:	75 35                	jne    8094e6 <udp_sendto_if+0x160>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  8094b1:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8094b5:	89 44 24 10          	mov    %eax,0x10(%esp)
  8094b9:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  8094c0:	00 
  8094c1:	8b 45 10             	mov    0x10(%ebp),%eax
  8094c4:	89 44 24 08          	mov    %eax,0x8(%esp)
  8094c8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8094cb:	89 54 24 04          	mov    %edx,0x4(%esp)
  8094cf:	89 34 24             	mov    %esi,(%esp)
  8094d2:	e8 a1 e6 ff ff       	call   807b78 <inet_chksum_pseudo>
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  8094d7:	66 85 c0             	test   %ax,%ax
  8094da:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8094df:	0f 44 c2             	cmove  %edx,%eax
  8094e2:	66 89 47 06          	mov    %ax,0x6(%edi)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  8094e6:	8b 45 18             	mov    0x18(%ebp),%eax
  8094e9:	89 44 24 18          	mov    %eax,0x18(%esp)
  8094ed:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  8094f4:	00 
  8094f5:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  8094f9:	89 44 24 10          	mov    %eax,0x10(%esp)
  8094fd:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  809501:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809505:	8b 55 10             	mov    0x10(%ebp),%edx
  809508:	89 54 24 08          	mov    %edx,0x8(%esp)
  80950c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80950f:	89 44 24 04          	mov    %eax,0x4(%esp)
  809513:	89 34 24             	mov    %esi,(%esp)
  809516:	e8 75 d6 ff ff       	call   806b90 <ip_output_if>
  80951b:	89 c7                	mov    %eax,%edi
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  80951d:	3b 75 0c             	cmp    0xc(%ebp),%esi
  809520:	74 08                	je     80952a <udp_sendto_if+0x1a4>
    /* free the header pbuf */
    pbuf_free(q);
  809522:	89 34 24             	mov    %esi,(%esp)
  809525:	e8 fa bc ff ff       	call   805224 <pbuf_free>
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  80952a:	89 f8                	mov    %edi,%eax
  80952c:	83 c4 3c             	add    $0x3c,%esp
  80952f:	5b                   	pop    %ebx
  809530:	5e                   	pop    %esi
  809531:	5f                   	pop    %edi
  809532:	5d                   	pop    %ebp
  809533:	c3                   	ret    

00809534 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  809534:	55                   	push   %ebp
  809535:	89 e5                	mov    %esp,%ebp
  809537:	83 ec 28             	sub    $0x28,%esp
  80953a:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80953d:	89 75 fc             	mov    %esi,-0x4(%ebp)
  809540:	8b 5d 10             	mov    0x10(%ebp),%ebx
  809543:	0f b7 75 14          	movzwl 0x14(%ebp),%esi

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  809547:	89 1c 24             	mov    %ebx,(%esp)
  80954a:	e8 f2 d7 ff ff       	call   806d41 <ip_route>
  80954f:	89 c2                	mov    %eax,%edx
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  809551:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809556:	85 d2                	test   %edx,%edx
  809558:	74 21                	je     80957b <udp_sendto+0x47>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  80955a:	89 54 24 10          	mov    %edx,0x10(%esp)
  80955e:	0f b7 f6             	movzwl %si,%esi
  809561:	89 74 24 0c          	mov    %esi,0xc(%esp)
  809565:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  809569:	8b 45 0c             	mov    0xc(%ebp),%eax
  80956c:	89 44 24 04          	mov    %eax,0x4(%esp)
  809570:	8b 45 08             	mov    0x8(%ebp),%eax
  809573:	89 04 24             	mov    %eax,(%esp)
  809576:	e8 0b fe ff ff       	call   809386 <udp_sendto_if>
}
  80957b:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80957e:	8b 75 fc             	mov    -0x4(%ebp),%esi
  809581:	89 ec                	mov    %ebp,%esp
  809583:	5d                   	pop    %ebp
  809584:	c3                   	ret    

00809585 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  809585:	55                   	push   %ebp
  809586:	89 e5                	mov    %esp,%ebp
  809588:	83 ec 18             	sub    $0x18,%esp
  80958b:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  80958e:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  809592:	89 54 24 0c          	mov    %edx,0xc(%esp)
  809596:	8d 50 04             	lea    0x4(%eax),%edx
  809599:	89 54 24 08          	mov    %edx,0x8(%esp)
  80959d:	8b 55 0c             	mov    0xc(%ebp),%edx
  8095a0:	89 54 24 04          	mov    %edx,0x4(%esp)
  8095a4:	89 04 24             	mov    %eax,(%esp)
  8095a7:	e8 88 ff ff ff       	call   809534 <udp_sendto>
}
  8095ac:	c9                   	leave  
  8095ad:	c3                   	ret    

008095ae <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  8095ae:	55                   	push   %ebp
  8095af:	89 e5                	mov    %esp,%ebp
  8095b1:	57                   	push   %edi
  8095b2:	56                   	push   %esi
  8095b3:	53                   	push   %ebx
  8095b4:	83 ec 4c             	sub    $0x4c,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  8095b7:	8b 45 08             	mov    0x8(%ebp),%eax
  8095ba:	8b 40 04             	mov    0x4(%eax),%eax
  8095bd:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  8095c0:	8b 55 08             	mov    0x8(%ebp),%edx
  8095c3:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  8095c7:	0f b7 00             	movzwl (%eax),%eax
  8095ca:	89 04 24             	mov    %eax,(%esp)
  8095cd:	e8 9a e8 ff ff       	call   807e6c <ntohs>
  8095d2:	0f b6 c4             	movzbl %ah,%eax
  8095d5:	83 e0 0f             	and    $0xf,%eax
  8095d8:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  8095df:	39 c3                	cmp    %eax,%ebx
  8095e1:	7c 2b                	jl     80960e <udp_input+0x60>
  8095e3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8095e6:	0f b7 02             	movzwl (%edx),%eax
  8095e9:	89 04 24             	mov    %eax,(%esp)
  8095ec:	e8 7b e8 ff ff       	call   807e6c <ntohs>
  8095f1:	66 c1 e8 06          	shr    $0x6,%ax
  8095f5:	83 e0 3c             	and    $0x3c,%eax
  8095f8:	f7 d8                	neg    %eax
  8095fa:	98                   	cwtl   
  8095fb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8095ff:	8b 45 08             	mov    0x8(%ebp),%eax
  809602:	89 04 24             	mov    %eax,(%esp)
  809605:	e8 bd b8 ff ff       	call   804ec7 <pbuf_header>
  80960a:	84 c0                	test   %al,%al
  80960c:	74 10                	je     80961e <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  80960e:	8b 55 08             	mov    0x8(%ebp),%edx
  809611:	89 14 24             	mov    %edx,(%esp)
  809614:	e8 0b bc ff ff       	call   805224 <pbuf_free>
    goto end;
  809619:	e9 e9 02 00 00       	jmp    809907 <udp_input+0x359>
  }

  udphdr = (struct udp_hdr *)p->payload;
  80961e:	8b 45 08             	mov    0x8(%ebp),%eax
  809621:	8b 40 04             	mov    0x4(%eax),%eax
  809624:	89 45 d8             	mov    %eax,-0x28(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  809627:	0f b7 00             	movzwl (%eax),%eax
  80962a:	89 04 24             	mov    %eax,(%esp)
  80962d:	e8 3a e8 ff ff       	call   807e6c <ntohs>
  809632:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  dest = ntohs(udphdr->dest);
  809636:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809639:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80963d:	89 04 24             	mov    %eax,(%esp)
  809640:	e8 27 e8 ff ff       	call   807e6c <ntohs>
  809645:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  809647:	66 83 f8 44          	cmp    $0x44,%ax
  80964b:	75 49                	jne    809696 <udp_input+0xe8>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  80964d:	66 83 7d de 43       	cmpw   $0x43,-0x22(%ebp)
  809652:	0f 85 eb 00 00 00    	jne    809743 <udp_input+0x195>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  809658:	8b 55 0c             	mov    0xc(%ebp),%edx
  80965b:	8b 42 20             	mov    0x20(%edx),%eax
  80965e:	85 c0                	test   %eax,%eax
  809660:	0f 84 dd 00 00 00    	je     809743 <udp_input+0x195>
  809666:	8b 58 08             	mov    0x8(%eax),%ebx
  809669:	85 db                	test   %ebx,%ebx
  80966b:	0f 84 d7 00 00 00    	je     809748 <udp_input+0x19a>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  809671:	83 fb fc             	cmp    $0xfffffffc,%ebx
  809674:	0f 84 e0 00 00 00    	je     80975a <udp_input+0x1ac>
  80967a:	8b 43 04             	mov    0x4(%ebx),%eax
  80967d:	85 c0                	test   %eax,%eax
  80967f:	0f 84 d5 00 00 00    	je     80975a <udp_input+0x1ac>
  809685:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809688:	3b 42 0c             	cmp    0xc(%edx),%eax
  80968b:	0f 85 b2 00 00 00    	jne    809743 <udp_input+0x195>
  809691:	e9 c4 00 00 00       	jmp    80975a <udp_input+0x1ac>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  809696:	8b 1d 54 b2 b3 00    	mov    0xb3b254,%ebx
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80969c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80969f:	83 c0 10             	add    $0x10,%eax
  8096a2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8096a5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  8096ac:	bf 00 00 00 00       	mov    $0x0,%edi
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8096b1:	eb 7e                	jmp    809731 <udp_input+0x183>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8096b3:	66 3b 73 12          	cmp    0x12(%ebx),%si
  8096b7:	75 73                	jne    80972c <udp_input+0x17e>
  8096b9:	85 db                	test   %ebx,%ebx
  8096bb:	74 24                	je     8096e1 <udp_input+0x133>
          (ip_addr_isany(&pcb->local_ip) ||
  8096bd:	8b 03                	mov    (%ebx),%eax
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8096bf:	85 c0                	test   %eax,%eax
  8096c1:	74 1e                	je     8096e1 <udp_input+0x133>
  8096c3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8096c6:	3b 42 10             	cmp    0x10(%edx),%eax
  8096c9:	74 16                	je     8096e1 <udp_input+0x133>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8096cb:	8b 45 0c             	mov    0xc(%ebp),%eax
  8096ce:	89 44 24 04          	mov    %eax,0x4(%esp)
  8096d2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8096d5:	89 14 24             	mov    %edx,(%esp)
  8096d8:	e8 63 d4 ff ff       	call   806b40 <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8096dd:	84 c0                	test   %al,%al
  8096df:	74 4b                	je     80972c <udp_input+0x17e>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  8096e1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  8096e5:	0f 85 f7 01 00 00    	jne    8098e2 <udp_input+0x334>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  8096eb:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  8096ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8096f2:	0f 44 c3             	cmove  %ebx,%eax
  8096f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8096f8:	e9 e5 01 00 00       	jmp    8098e2 <udp_input+0x334>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  8096fd:	83 fb fc             	cmp    $0xfffffffc,%ebx
  809700:	74 0f                	je     809711 <udp_input+0x163>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  809702:	8b 43 04             	mov    0x4(%ebx),%eax
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  809705:	85 c0                	test   %eax,%eax
  809707:	74 08                	je     809711 <udp_input+0x163>
  809709:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80970c:	3b 42 0c             	cmp    0xc(%edx),%eax
  80970f:	75 1b                	jne    80972c <udp_input+0x17e>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  809711:	85 ff                	test   %edi,%edi
  809713:	74 45                	je     80975a <udp_input+0x1ac>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  809715:	8b 53 0c             	mov    0xc(%ebx),%edx
  809718:	89 57 0c             	mov    %edx,0xc(%edi)
          pcb->next = udp_pcbs;
  80971b:	8b 15 54 b2 b3 00    	mov    0xb3b254,%edx
  809721:	89 53 0c             	mov    %edx,0xc(%ebx)
          udp_pcbs = pcb;
  809724:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  80972a:	eb 2e                	jmp    80975a <udp_input+0x1ac>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80972c:	89 df                	mov    %ebx,%edi
  80972e:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  809731:	85 db                	test   %ebx,%ebx
  809733:	0f 85 7a ff ff ff    	jne    8096b3 <udp_input+0x105>
  809739:	e9 b7 01 00 00       	jmp    8098f5 <udp_input+0x347>
  80973e:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  809741:	eb 05                	jmp    809748 <udp_input+0x19a>
  809743:	bb 00 00 00 00       	mov    $0x0,%ebx
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  809748:	8b 55 0c             	mov    0xc(%ebp),%edx
  80974b:	8b 42 04             	mov    0x4(%edx),%eax
  80974e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809751:	3b 42 10             	cmp    0x10(%edx),%eax
  809754:	0f 85 7a 01 00 00    	jne    8098d4 <udp_input+0x326>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  80975a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80975d:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  809762:	74 44                	je     8097a8 <udp_input+0x1fa>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  809764:	8b 55 08             	mov    0x8(%ebp),%edx
  809767:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80976b:	89 44 24 10          	mov    %eax,0x10(%esp)
  80976f:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  809776:	00 
  809777:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80977a:	83 c0 10             	add    $0x10,%eax
  80977d:	89 44 24 08          	mov    %eax,0x8(%esp)
  809781:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809784:	83 c0 0c             	add    $0xc,%eax
  809787:	89 44 24 04          	mov    %eax,0x4(%esp)
  80978b:	89 14 24             	mov    %edx,(%esp)
  80978e:	e8 e5 e3 ff ff       	call   807b78 <inet_chksum_pseudo>
  809793:	66 85 c0             	test   %ax,%ax
  809796:	74 10                	je     8097a8 <udp_input+0x1fa>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  809798:	8b 45 08             	mov    0x8(%ebp),%eax
  80979b:	89 04 24             	mov    %eax,(%esp)
  80979e:	e8 81 ba ff ff       	call   805224 <pbuf_free>
          goto end;
  8097a3:	e9 5f 01 00 00       	jmp    809907 <udp_input+0x359>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  8097a8:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  8097af:	ff 
  8097b0:	8b 55 08             	mov    0x8(%ebp),%edx
  8097b3:	89 14 24             	mov    %edx,(%esp)
  8097b6:	e8 0c b7 ff ff       	call   804ec7 <pbuf_header>
  8097bb:	84 c0                	test   %al,%al
  8097bd:	74 1c                	je     8097db <udp_input+0x22d>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8097bf:	c7 44 24 08 e4 23 81 	movl   $0x8123e4,0x8(%esp)
  8097c6:	00 
  8097c7:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  8097ce:	00 
  8097cf:	c7 04 24 04 24 81 00 	movl   $0x812404,(%esp)
  8097d6:	e8 11 5a 00 00       	call   80f1ec <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  8097db:	85 db                	test   %ebx,%ebx
  8097dd:	74 41                	je     809820 <udp_input+0x272>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  8097df:	8b 43 18             	mov    0x18(%ebx),%eax
  8097e2:	85 c0                	test   %eax,%eax
  8097e4:	74 2a                	je     809810 <udp_input+0x262>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  8097e6:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  8097ea:	89 54 24 10          	mov    %edx,0x10(%esp)
  8097ee:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8097f1:	83 c2 0c             	add    $0xc,%edx
  8097f4:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8097f8:	8b 55 08             	mov    0x8(%ebp),%edx
  8097fb:	89 54 24 08          	mov    %edx,0x8(%esp)
  8097ff:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809803:	8b 53 1c             	mov    0x1c(%ebx),%edx
  809806:	89 14 24             	mov    %edx,(%esp)
  809809:	ff d0                	call   *%eax
  80980b:	e9 f7 00 00 00       	jmp    809907 <udp_input+0x359>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  809810:	8b 45 08             	mov    0x8(%ebp),%eax
  809813:	89 04 24             	mov    %eax,(%esp)
  809816:	e8 09 ba ff ff       	call   805224 <pbuf_free>
        goto end;
  80981b:	e9 e7 00 00 00       	jmp    809907 <udp_input+0x359>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  809820:	8b 55 0c             	mov    0xc(%ebp),%edx
  809823:	89 54 24 04          	mov    %edx,0x4(%esp)
  809827:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80982a:	83 c0 10             	add    $0x10,%eax
  80982d:	89 04 24             	mov    %eax,(%esp)
  809830:	e8 0b d3 ff ff       	call   806b40 <ip_addr_isbroadcast>
  809835:	84 c0                	test   %al,%al
  809837:	0f 85 8a 00 00 00    	jne    8098c7 <udp_input+0x319>
          !ip_addr_ismulticast(&iphdr->dest)) {
  80983d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809840:	8b 70 10             	mov    0x10(%eax),%esi
  809843:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80984a:	e8 3d e8 ff ff       	call   80808c <ntohl>
  80984f:	89 c3                	mov    %eax,%ebx
  809851:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809858:	e8 2f e8 ff ff       	call   80808c <ntohl>
  80985d:	21 f3                	and    %esi,%ebx
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80985f:	39 c3                	cmp    %eax,%ebx
  809861:	74 64                	je     8098c7 <udp_input+0x319>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  809863:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809866:	0f b7 02             	movzwl (%edx),%eax
  809869:	89 04 24             	mov    %eax,(%esp)
  80986c:	e8 fb e5 ff ff       	call   807e6c <ntohs>
  809871:	0f b6 c4             	movzbl %ah,%eax
  809874:	83 e0 0f             	and    $0xf,%eax
  809877:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80987e:	89 44 24 04          	mov    %eax,0x4(%esp)
  809882:	8b 45 08             	mov    0x8(%ebp),%eax
  809885:	89 04 24             	mov    %eax,(%esp)
  809888:	e8 3a b6 ff ff       	call   804ec7 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  80988d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809890:	8b 55 08             	mov    0x8(%ebp),%edx
  809893:	39 42 04             	cmp    %eax,0x4(%edx)
  809896:	74 1c                	je     8098b4 <udp_input+0x306>
  809898:	c7 44 24 08 18 24 81 	movl   $0x812418,0x8(%esp)
  80989f:	00 
  8098a0:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  8098a7:	00 
  8098a8:	c7 04 24 04 24 81 00 	movl   $0x812404,(%esp)
  8098af:	e8 38 59 00 00       	call   80f1ec <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  8098b4:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  8098bb:	00 
  8098bc:	8b 55 08             	mov    0x8(%ebp),%edx
  8098bf:	89 14 24             	mov    %edx,(%esp)
  8098c2:	e8 5b 54 00 00       	call   80ed22 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  8098c7:	8b 45 08             	mov    0x8(%ebp),%eax
  8098ca:	89 04 24             	mov    %eax,(%esp)
  8098cd:	e8 52 b9 ff ff       	call   805224 <pbuf_free>
  8098d2:	eb 33                	jmp    809907 <udp_input+0x359>
    }
  } else {
    pbuf_free(p);
  8098d4:	8b 55 08             	mov    0x8(%ebp),%edx
  8098d7:	89 14 24             	mov    %edx,(%esp)
  8098da:	e8 45 b9 ff ff       	call   805224 <pbuf_free>
  8098df:	90                   	nop
  8098e0:	eb 25                	jmp    809907 <udp_input+0x359>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  8098e2:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  8098e6:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  8098ea:	0f 85 3c fe ff ff    	jne    80972c <udp_input+0x17e>
  8098f0:	e9 08 fe ff ff       	jmp    8096fd <udp_input+0x14f>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  8098f5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  8098f9:	0f 84 3f fe ff ff    	je     80973e <udp_input+0x190>
  8098ff:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  809902:	e9 53 fe ff ff       	jmp    80975a <udp_input+0x1ac>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  809907:	83 c4 4c             	add    $0x4c,%esp
  80990a:	5b                   	pop    %ebx
  80990b:	5e                   	pop    %esi
  80990c:	5f                   	pop    %edi
  80990d:	5d                   	pop    %ebp
  80990e:	c3                   	ret    
	...

00809910 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  809910:	55                   	push   %ebp
  809911:	89 e5                	mov    %esp,%ebp
  809913:	57                   	push   %edi
  809914:	56                   	push   %esi
  809915:	53                   	push   %ebx
  809916:	83 ec 2c             	sub    $0x2c,%esp
  809919:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80991c:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80991f:	89 ce                	mov    %ecx,%esi
  809921:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  809924:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809927:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80992b:	74 1c                	je     809949 <etharp_send_ip+0x39>
  80992d:	c7 44 24 08 5c 24 81 	movl   $0x81245c,0x8(%esp)
  809934:	00 
  809935:	c7 44 24 04 b3 01 00 	movl   $0x1b3,0x4(%esp)
  80993c:	00 
  80993d:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  809944:	e8 a3 58 00 00       	call   80f1ec <_panic>
  809949:	ba 06 00 00 00       	mov    $0x6,%edx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  80994e:	83 ea 01             	sub    $0x1,%edx
    ethhdr->dest.addr[k] = dst->addr[k];
  809951:	0f b6 c2             	movzbl %dl,%eax
  809954:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  809958:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  80995b:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80995f:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  809963:	84 d2                	test   %dl,%dl
  809965:	75 e7                	jne    80994e <etharp_send_ip+0x3e>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  809967:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80996e:	e8 ec e4 ff ff       	call   807e5f <htons>
  809973:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  809977:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80997a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80997e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809981:	89 14 24             	mov    %edx,(%esp)
  809984:	ff 52 18             	call   *0x18(%edx)
}
  809987:	83 c4 2c             	add    $0x2c,%esp
  80998a:	5b                   	pop    %ebx
  80998b:	5e                   	pop    %esi
  80998c:	5f                   	pop    %edi
  80998d:	5d                   	pop    %ebp
  80998e:	c3                   	ret    

0080998f <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80998f:	55                   	push   %ebp
  809990:	89 e5                	mov    %esp,%ebp
  809992:	57                   	push   %edi
  809993:	56                   	push   %esi
  809994:	53                   	push   %ebx
  809995:	83 ec 3c             	sub    $0x3c,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  809998:	8b 75 08             	mov    0x8(%ebp),%esi
  80999b:	83 c6 25             	add    $0x25,%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  80999e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8099a5:	00 
  8099a6:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  8099ad:	00 
  8099ae:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8099b5:	e8 25 bb ff ff       	call   8054df <pbuf_alloc>
  8099ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  8099bd:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  8099c2:	85 c0                	test   %eax,%eax
  8099c4:	0f 84 02 01 00 00    	je     809acc <etharp_request+0x13d>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  8099ca:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  8099cf:	77 1c                	ja     8099ed <etharp_request+0x5e>
  8099d1:	c7 44 24 08 a0 24 81 	movl   $0x8124a0,0x8(%esp)
  8099d8:	00 
  8099d9:	c7 44 24 04 1c 04 00 	movl   $0x41c,0x4(%esp)
  8099e0:	00 
  8099e1:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  8099e8:	e8 ff 57 00 00       	call   80f1ec <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  8099ed:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8099f0:	8b 5a 04             	mov    0x4(%edx),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  8099f3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8099fa:	e8 60 e4 ff ff       	call   807e5f <htons>
  8099ff:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809a03:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809a06:	80 79 24 06          	cmpb   $0x6,0x24(%ecx)
  809a0a:	74 1c                	je     809a28 <etharp_request+0x99>
  809a0c:	c7 44 24 08 5c 24 81 	movl   $0x81245c,0x8(%esp)
  809a13:	00 
  809a14:	c7 44 24 04 23 04 00 	movl   $0x423,0x4(%esp)
  809a1b:	00 
  809a1c:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  809a23:	e8 c4 57 00 00       	call   80f1ec <_panic>
  809a28:	ba 06 00 00 00       	mov    $0x6,%edx
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  809a2d:	bf c1 25 81 00       	mov    $0x8125c1,%edi
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  809a32:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  809a35:	0f b6 c2             	movzbl %dl,%eax
  809a38:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  809a3c:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  809a40:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  809a44:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  809a48:	0f b6 88 bb 25 81 00 	movzbl 0x8125bb(%eax),%ecx
  809a4f:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  809a52:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  809a56:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  809a5a:	84 d2                	test   %dl,%dl
  809a5c:	75 d4                	jne    809a32 <etharp_request+0xa3>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  809a5e:	8b 55 08             	mov    0x8(%ebp),%edx
  809a61:	8b 42 04             	mov    0x4(%edx),%eax
  809a64:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  809a67:	8b 45 0c             	mov    0xc(%ebp),%eax
  809a6a:	8b 00                	mov    (%eax),%eax
  809a6c:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  809a6f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809a76:	e8 e4 e3 ff ff       	call   807e5f <htons>
  809a7b:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  809a7f:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809a86:	e8 d4 e3 ff ff       	call   807e5f <htons>
  809a8b:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  809a8f:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809a96:	e8 c4 e3 ff ff       	call   807e5f <htons>
  809a9b:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  809a9f:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809aa6:	e8 b4 e3 ff ff       	call   807e5f <htons>
  809aab:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  809aaf:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809ab2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  809ab6:	8b 45 08             	mov    0x8(%ebp),%eax
  809ab9:	89 04 24             	mov    %eax,(%esp)
  809abc:	ff 50 18             	call   *0x18(%eax)
  809abf:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  809ac1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809ac4:	89 0c 24             	mov    %ecx,(%esp)
  809ac7:	e8 58 b7 ff ff       	call   805224 <pbuf_free>
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  809acc:	89 d8                	mov    %ebx,%eax
  809ace:	83 c4 3c             	add    $0x3c,%esp
  809ad1:	5b                   	pop    %ebx
  809ad2:	5e                   	pop    %esi
  809ad3:	5f                   	pop    %edi
  809ad4:	5d                   	pop    %ebp
  809ad5:	c3                   	ret    

00809ad6 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  809ad6:	55                   	push   %ebp
  809ad7:	89 e5                	mov    %esp,%ebp
  809ad9:	56                   	push   %esi
  809ada:	53                   	push   %ebx
  809adb:	83 ec 10             	sub    $0x10,%esp
  809ade:	89 c3                	mov    %eax,%ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  809ae0:	85 c0                	test   %eax,%eax
  809ae2:	75 1c                	jne    809b00 <free_etharp_q+0x2a>
  809ae4:	c7 44 24 08 0f 1d 81 	movl   $0x811d0f,0x8(%esp)
  809aeb:	00 
  809aec:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  809af3:	00 
  809af4:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  809afb:	e8 ec 56 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  809b00:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  809b04:	75 1e                	jne    809b24 <free_etharp_q+0x4e>
  809b06:	c7 44 24 08 5d 25 81 	movl   $0x81255d,0x8(%esp)
  809b0d:	00 
  809b0e:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
  809b15:	00 
  809b16:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  809b1d:	e8 ca 56 00 00       	call   80f1ec <_panic>
  809b22:	89 f3                	mov    %esi,%ebx
  while (q) {
    r = q;
    q = q->next;
  809b24:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  809b26:	8b 43 04             	mov    0x4(%ebx),%eax
  809b29:	85 c0                	test   %eax,%eax
  809b2b:	75 1c                	jne    809b49 <free_etharp_q+0x73>
  809b2d:	c7 44 24 08 6a 25 81 	movl   $0x81256a,0x8(%esp)
  809b34:	00 
  809b35:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  809b3c:	00 
  809b3d:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  809b44:	e8 a3 56 00 00       	call   80f1ec <_panic>
    pbuf_free(r->p);
  809b49:	89 04 24             	mov    %eax,(%esp)
  809b4c:	e8 d3 b6 ff ff       	call   805224 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  809b51:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809b55:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  809b5c:	e8 63 af ff ff       	call   804ac4 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  809b61:	85 f6                	test   %esi,%esi
  809b63:	75 bd                	jne    809b22 <free_etharp_q+0x4c>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  809b65:	83 c4 10             	add    $0x10,%esp
  809b68:	5b                   	pop    %ebx
  809b69:	5e                   	pop    %esi
  809b6a:	5d                   	pop    %ebp
  809b6b:	c3                   	ret    

00809b6c <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809b6c:	55                   	push   %ebp
  809b6d:	89 e5                	mov    %esp,%ebp
  809b6f:	57                   	push   %edi
  809b70:	56                   	push   %esi
  809b71:	53                   	push   %ebx
  809b72:	83 ec 3c             	sub    $0x3c,%esp
  809b75:	89 45 e0             	mov    %eax,-0x20(%ebp)
  809b78:	88 55 dd             	mov    %dl,-0x23(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809b7b:	85 c0                	test   %eax,%eax
  809b7d:	74 29                	je     809ba8 <find_entry+0x3c>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809b7f:	0f b6 05 38 4b b3 00 	movzbl 0xb34b38,%eax
  809b86:	0f b6 d0             	movzbl %al,%edx
  809b89:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  809b8c:	83 b9 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ecx)
  809b93:	75 13                	jne    809ba8 <find_entry+0x3c>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  809b95:	89 ca                	mov    %ecx,%edx
  809b97:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  809b9a:	8b 0b                	mov    (%ebx),%ecx
  809b9c:	3b 8a 24 4a b3 00    	cmp    0xb34a24(%edx),%ecx
  809ba2:	0f 84 ea 01 00 00    	je     809d92 <find_entry+0x226>
  809ba8:	ba 34 4a b3 00       	mov    $0xb34a34,%edx
  809bad:	be 00 00 00 00       	mov    $0x0,%esi
  809bb2:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  809bb6:	bf 00 00 00 00       	mov    $0x0,%edi
  809bbb:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809bbf:	b8 00 00 00 00       	mov    $0x0,%eax
  809bc4:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809bc8:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  809bcc:	c6 45 dc 0a          	movb   $0xa,-0x24(%ebp)
  809bd0:	eb 0d                	jmp    809bdf <find_entry+0x73>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  809bd2:	89 ce                	mov    %ecx,%esi
  809bd4:	0f b6 7d d7          	movzbl -0x29(%ebp),%edi
  809bd8:	0f b6 4d e6          	movzbl -0x1a(%ebp),%ecx
  809bdc:	88 4d e7             	mov    %cl,-0x19(%ebp)
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  809bdf:	80 7d e5 0a          	cmpb   $0xa,-0x1b(%ebp)
  809be3:	75 1c                	jne    809c01 <find_entry+0x95>
  809be5:	83 7a fc 00          	cmpl   $0x0,-0x4(%edx)
  809be9:	75 16                	jne    809c01 <find_entry+0x95>
  809beb:	88 45 e5             	mov    %al,-0x1b(%ebp)
  809bee:	89 f1                	mov    %esi,%ecx
  809bf0:	89 fb                	mov    %edi,%ebx
  809bf2:	88 5d d7             	mov    %bl,-0x29(%ebp)
  809bf5:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  809bf9:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  809bfc:	e9 a3 00 00 00       	jmp    809ca4 <find_entry+0x138>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809c01:	8b 4a fc             	mov    -0x4(%edx),%ecx
  809c04:	83 f9 01             	cmp    $0x1,%ecx
  809c07:	75 54                	jne    809c5d <find_entry+0xf1>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809c09:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  809c0d:	74 14                	je     809c23 <find_entry+0xb7>
  809c0f:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  809c12:	8b 0b                	mov    (%ebx),%ecx
  809c14:	3b 4a f0             	cmp    -0x10(%edx),%ecx
  809c17:	75 0a                	jne    809c23 <find_entry+0xb7>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  809c19:	a2 38 4b b3 00       	mov    %al,0xb34b38
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  809c1e:	e9 6f 01 00 00       	jmp    809d92 <find_entry+0x226>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  809c23:	83 7a ec 00          	cmpl   $0x0,-0x14(%edx)
  809c27:	74 1a                	je     809c43 <find_entry+0xd7>
        if (arp_table[i].ctime >= age_queue) {
  809c29:	0f b6 0a             	movzbl (%edx),%ecx
  809c2c:	89 f3                	mov    %esi,%ebx
  809c2e:	38 d9                	cmp    %bl,%cl
  809c30:	72 64                	jb     809c96 <find_entry+0x12a>
  809c32:	88 45 df             	mov    %al,-0x21(%ebp)
  809c35:	89 fb                	mov    %edi,%ebx
  809c37:	88 5d d7             	mov    %bl,-0x29(%ebp)
  809c3a:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  809c3e:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  809c41:	eb 61                	jmp    809ca4 <find_entry+0x138>
          age_queue = arp_table[i].ctime;
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  809c43:	0f b6 0a             	movzbl (%edx),%ecx
  809c46:	88 4d e6             	mov    %cl,-0x1a(%ebp)
  809c49:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  809c4d:	38 d9                	cmp    %bl,%cl
  809c4f:	72 45                	jb     809c96 <find_entry+0x12a>
  809c51:	88 45 dc             	mov    %al,-0x24(%ebp)
  809c54:	89 f1                	mov    %esi,%ecx
  809c56:	89 fb                	mov    %edi,%ebx
  809c58:	88 5d d7             	mov    %bl,-0x29(%ebp)
  809c5b:	eb 47                	jmp    809ca4 <find_entry+0x138>
          age_pending = arp_table[i].ctime;
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809c5d:	83 f9 02             	cmp    $0x2,%ecx
  809c60:	75 34                	jne    809c96 <find_entry+0x12a>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809c62:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  809c66:	74 14                	je     809c7c <find_entry+0x110>
  809c68:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  809c6b:	8b 0b                	mov    (%ebx),%ecx
  809c6d:	3b 4a f0             	cmp    -0x10(%edx),%ecx
  809c70:	75 0a                	jne    809c7c <find_entry+0x110>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  809c72:	a2 38 4b b3 00       	mov    %al,0xb34b38
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  809c77:	e9 16 01 00 00       	jmp    809d92 <find_entry+0x226>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  809c7c:	0f b6 0a             	movzbl (%edx),%ecx
  809c7f:	88 4d d7             	mov    %cl,-0x29(%ebp)
  809c82:	89 fb                	mov    %edi,%ebx
  809c84:	38 d9                	cmp    %bl,%cl
  809c86:	72 0e                	jb     809c96 <find_entry+0x12a>
  809c88:	88 45 de             	mov    %al,-0x22(%ebp)
  809c8b:	89 f1                	mov    %esi,%ecx
  809c8d:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  809c91:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  809c94:	eb 0e                	jmp    809ca4 <find_entry+0x138>
  809c96:	89 f1                	mov    %esi,%ecx
  809c98:	89 fb                	mov    %edi,%ebx
  809c9a:	88 5d d7             	mov    %bl,-0x29(%ebp)
  809c9d:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  809ca1:	88 5d e6             	mov    %bl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809ca4:	83 c0 01             	add    $0x1,%eax
  809ca7:	83 c2 1c             	add    $0x1c,%edx
  809caa:	3c 0a                	cmp    $0xa,%al
  809cac:	0f 85 20 ff ff ff    	jne    809bd2 <find_entry+0x66>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  809cb2:	80 7d e5 0a          	cmpb   $0xa,-0x1b(%ebp)
  809cb6:	75 0a                	jne    809cc2 <find_entry+0x156>
  809cb8:	f6 45 dd 01          	testb  $0x1,-0x23(%ebp)
  809cbc:	0f 84 cb 00 00 00    	je     809d8d <find_entry+0x221>
  809cc2:	f6 45 dd 02          	testb  $0x2,-0x23(%ebp)
  809cc6:	0f 85 c1 00 00 00    	jne    809d8d <find_entry+0x221>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  809ccc:	0f b6 5d e5          	movzbl -0x1b(%ebp),%ebx
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  809cd0:	80 fb 09             	cmp    $0x9,%bl
  809cd3:	7e 62                	jle    809d37 <find_entry+0x1cb>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  809cd5:	80 7d de 09          	cmpb   $0x9,-0x22(%ebp)
  809cd9:	7f 2f                	jg     809d0a <find_entry+0x19e>
    /* recycle oldest stable*/
    i = old_stable;
  809cdb:	0f b6 5d de          	movzbl -0x22(%ebp),%ebx
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  809cdf:	0f b6 c3             	movzbl %bl,%eax
  809ce2:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809ce5:	83 b8 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%eax)
  809cec:	74 49                	je     809d37 <find_entry+0x1cb>
  809cee:	c7 44 24 08 77 25 81 	movl   $0x812577,0x8(%esp)
  809cf5:	00 
  809cf6:	c7 44 24 04 75 01 00 	movl   $0x175,0x4(%esp)
  809cfd:	00 
  809cfe:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  809d05:	e8 e2 54 00 00       	call   80f1ec <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
    /* recycle oldest pending */
    i = old_pending;
  809d0a:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  809d0e:	80 fb 09             	cmp    $0x9,%bl
  809d11:	7e 24                	jle    809d37 <find_entry+0x1cb>
    /* recycle oldest pending */
    i = old_pending;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  809d13:	80 7d df 09          	cmpb   $0x9,-0x21(%ebp)
  809d17:	7f 74                	jg     809d8d <find_entry+0x221>
    /* recycle oldest pending */
    i = old_queue;
  809d19:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  809d1d:	0f b6 f3             	movzbl %bl,%esi
  809d20:	bf 20 4a b3 00       	mov    $0xb34a20,%edi
  809d25:	6b f6 1c             	imul   $0x1c,%esi,%esi
  809d28:	8b 04 3e             	mov    (%esi,%edi,1),%eax
  809d2b:	e8 a6 fd ff ff       	call   809ad6 <free_etharp_q>
    arp_table[i].q = NULL;
  809d30:	c7 04 3e 00 00 00 00 	movl   $0x0,(%esi,%edi,1)
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  809d37:	80 fb 09             	cmp    $0x9,%bl
  809d3a:	76 1c                	jbe    809d58 <find_entry+0x1ec>
  809d3c:	c7 44 24 08 8e 25 81 	movl   $0x81258e,0x8(%esp)
  809d43:	00 
  809d44:	c7 44 24 04 8b 01 00 	movl   $0x18b,0x4(%esp)
  809d4b:	00 
  809d4c:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  809d53:	e8 94 54 00 00       	call   80f1ec <_panic>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  809d58:	0f b6 c3             	movzbl %bl,%eax
  809d5b:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809d5e:	c7 82 30 4a b3 00 00 	movl   $0x0,0xb34a30(%edx)
  809d65:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  809d68:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  809d6c:	74 0b                	je     809d79 <find_entry+0x20d>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809d6e:	8b 75 e0             	mov    -0x20(%ebp),%esi
  809d71:	8b 0e                	mov    (%esi),%ecx
  809d73:	89 8a 24 4a b3 00    	mov    %ecx,0xb34a24(%edx)
  }
  arp_table[i].ctime = 0;
  809d79:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809d7c:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809d83:	88 1d 38 4b b3 00    	mov    %bl,0xb34b38
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  809d89:	89 d8                	mov    %ebx,%eax
  809d8b:	eb 05                	jmp    809d92 <find_entry+0x226>
  809d8d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  809d92:	83 c4 3c             	add    $0x3c,%esp
  809d95:	5b                   	pop    %ebx
  809d96:	5e                   	pop    %esi
  809d97:	5f                   	pop    %edi
  809d98:	5d                   	pop    %ebp
  809d99:	c3                   	ret    

00809d9a <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  809d9a:	55                   	push   %ebp
  809d9b:	89 e5                	mov    %esp,%ebp
  809d9d:	83 ec 38             	sub    $0x38,%esp
  809da0:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809da3:	89 75 f8             	mov    %esi,-0x8(%ebp)
  809da6:	89 7d fc             	mov    %edi,-0x4(%ebp)
  809da9:	8b 75 08             	mov    0x8(%ebp),%esi
  809dac:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  809daf:	89 74 24 04          	mov    %esi,0x4(%esp)
  809db3:	89 1c 24             	mov    %ebx,(%esp)
  809db6:	e8 85 cd ff ff       	call   806b40 <ip_addr_isbroadcast>
  809dbb:	84 c0                	test   %al,%al
  809dbd:	0f 85 c5 01 00 00    	jne    809f88 <etharp_query+0x1ee>
      ip_addr_ismulticast(ipaddr) ||
  809dc3:	8b 03                	mov    (%ebx),%eax
  809dc5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809dc8:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809dcf:	e8 b8 e2 ff ff       	call   80808c <ntohl>
  809dd4:	89 c7                	mov    %eax,%edi
  809dd6:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809ddd:	e8 aa e2 ff ff       	call   80808c <ntohl>
  809de2:	23 7d e4             	and    -0x1c(%ebp),%edi
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  809de5:	39 c7                	cmp    %eax,%edi
  809de7:	0f 84 9b 01 00 00    	je     809f88 <etharp_query+0x1ee>
  809ded:	85 db                	test   %ebx,%ebx
  809def:	0f 84 93 01 00 00    	je     809f88 <etharp_query+0x1ee>
  809df5:	83 3b 00             	cmpl   $0x0,(%ebx)
  809df8:	0f 84 8a 01 00 00    	je     809f88 <etharp_query+0x1ee>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  809dfe:	ba 01 00 00 00       	mov    $0x1,%edx
  809e03:	89 d8                	mov    %ebx,%eax
  809e05:	e8 62 fd ff ff       	call   809b6c <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  809e0a:	84 c0                	test   %al,%al
  809e0c:	0f 88 81 01 00 00    	js     809f93 <etharp_query+0x1f9>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  809e12:	0f be f8             	movsbl %al,%edi
  809e15:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809e18:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809e1e:	85 c0                	test   %eax,%eax
  809e20:	75 0f                	jne    809e31 <etharp_query+0x97>
    arp_table[i].state = ETHARP_STATE_PENDING;
  809e22:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809e25:	c7 80 30 4a b3 00 01 	movl   $0x1,0xb34a30(%eax)
  809e2c:	00 00 00 
  809e2f:	eb 33                	jmp    809e64 <etharp_query+0xca>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809e31:	8d 50 ff             	lea    -0x1(%eax),%edx
  809e34:	83 fa 01             	cmp    $0x1,%edx
  809e37:	76 1c                	jbe    809e55 <etharp_query+0xbb>
  809e39:	c7 44 24 08 d4 24 81 	movl   $0x8124d4,0x8(%esp)
  809e40:	00 
  809e41:	c7 44 24 04 92 03 00 	movl   $0x392,0x4(%esp)
  809e48:	00 
  809e49:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  809e50:	e8 97 53 00 00       	call   80f1ec <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809e55:	83 f8 01             	cmp    $0x1,%eax
  809e58:	74 0a                	je     809e64 <etharp_query+0xca>
  809e5a:	c6 45 e4 ff          	movb   $0xff,-0x1c(%ebp)
  809e5e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809e62:	75 0f                	jne    809e73 <etharp_query+0xd9>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  809e64:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809e68:	89 34 24             	mov    %esi,(%esp)
  809e6b:	e8 1f fb ff ff       	call   80998f <etharp_request>
  809e70:	88 45 e4             	mov    %al,-0x1c(%ebp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  809e73:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809e77:	0f 84 12 01 00 00    	je     809f8f <etharp_query+0x1f5>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809e7d:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809e80:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809e86:	83 f8 02             	cmp    $0x2,%eax
  809e89:	75 1d                	jne    809ea8 <etharp_query+0x10e>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  809e8b:	8d 4e 25             	lea    0x25(%esi),%ecx
  809e8e:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809e91:	05 28 4a b3 00       	add    $0xb34a28,%eax
  809e96:	89 04 24             	mov    %eax,(%esp)
  809e99:	8b 55 10             	mov    0x10(%ebp),%edx
  809e9c:	89 f0                	mov    %esi,%eax
  809e9e:	e8 6d fa ff ff       	call   809910 <etharp_send_ip>
  809ea3:	e9 eb 00 00 00       	jmp    809f93 <etharp_query+0x1f9>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809ea8:	83 f8 01             	cmp    $0x1,%eax
  809eab:	0f 85 de 00 00 00    	jne    809f8f <etharp_query+0x1f5>
  809eb1:	8b 45 10             	mov    0x10(%ebp),%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809eb4:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  809eb8:	66 3b 50 08          	cmp    0x8(%eax),%dx
  809ebc:	75 21                	jne    809edf <etharp_query+0x145>
  809ebe:	83 38 00             	cmpl   $0x0,(%eax)
  809ec1:	74 1c                	je     809edf <etharp_query+0x145>
  809ec3:	c7 44 24 08 a1 25 81 	movl   $0x8125a1,0x8(%esp)
  809eca:	00 
  809ecb:	c7 44 24 04 b1 03 00 	movl   $0x3b1,0x4(%esp)
  809ed2:	00 
  809ed3:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  809eda:	e8 0d 53 00 00       	call   80f1ec <_panic>
        if(p->type != PBUF_ROM) {
  809edf:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809ee3:	75 0b                	jne    809ef0 <etharp_query+0x156>
          copy_needed = 1;
          break;
        }
        p = p->next;
  809ee5:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  809ee7:	85 c0                	test   %eax,%eax
  809ee9:	75 c9                	jne    809eb4 <etharp_query+0x11a>
  809eeb:	e9 b0 00 00 00       	jmp    809fa0 <etharp_query+0x206>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809ef0:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  809ef4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809efb:	00 
  809efc:	89 44 24 04          	mov    %eax,0x4(%esp)
  809f00:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  809f07:	e8 d3 b5 ff ff       	call   8054df <pbuf_alloc>
  809f0c:	89 c3                	mov    %eax,%ebx
        if(p != NULL) {
  809f0e:	85 c0                	test   %eax,%eax
  809f10:	74 7d                	je     809f8f <etharp_query+0x1f5>
          if (pbuf_copy(p, q) != ERR_OK) {
  809f12:	8b 45 10             	mov    0x10(%ebp),%eax
  809f15:	89 44 24 04          	mov    %eax,0x4(%esp)
  809f19:	89 1c 24             	mov    %ebx,(%esp)
  809f1c:	e8 64 b1 ff ff       	call   805085 <pbuf_copy>
  809f21:	84 c0                	test   %al,%al
  809f23:	74 0e                	je     809f33 <etharp_query+0x199>
            pbuf_free(p);
  809f25:	89 1c 24             	mov    %ebx,(%esp)
  809f28:	e8 f7 b2 ff ff       	call   805224 <pbuf_free>
  809f2d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  809f31:	eb 60                	jmp    809f93 <etharp_query+0x1f9>
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809f33:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  809f3a:	e8 c9 ab ff ff       	call   804b08 <memp_malloc>
        if (new_entry != NULL) {
  809f3f:	85 c0                	test   %eax,%eax
  809f41:	74 37                	je     809f7a <etharp_query+0x1e0>
          new_entry->next = 0;
  809f43:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  809f49:	89 58 04             	mov    %ebx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  809f4c:	6b d7 1c             	imul   $0x1c,%edi,%edx
  809f4f:	8b 92 20 4a b3 00    	mov    0xb34a20(%edx),%edx
  809f55:	85 d2                	test   %edx,%edx
  809f57:	74 11                	je     809f6a <etharp_query+0x1d0>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  809f59:	89 d1                	mov    %edx,%ecx
  809f5b:	8b 12                	mov    (%edx),%edx
  809f5d:	85 d2                	test   %edx,%edx
  809f5f:	75 f8                	jne    809f59 <etharp_query+0x1bf>
              r = r->next;
            }
            r->next = new_entry;
  809f61:	89 01                	mov    %eax,(%ecx)
  809f63:	b8 00 00 00 00       	mov    $0x0,%eax
  809f68:	eb 29                	jmp    809f93 <etharp_query+0x1f9>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  809f6a:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809f6d:	89 87 20 4a b3 00    	mov    %eax,0xb34a20(%edi)
  809f73:	b8 00 00 00 00       	mov    $0x0,%eax
  809f78:	eb 19                	jmp    809f93 <etharp_query+0x1f9>
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  809f7a:	89 1c 24             	mov    %ebx,(%esp)
  809f7d:	e8 a2 b2 ff ff       	call   805224 <pbuf_free>
  809f82:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
  809f86:	eb 0b                	jmp    809f93 <etharp_query+0x1f9>
  809f88:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809f8d:	eb 04                	jmp    809f93 <etharp_query+0x1f9>
  809f8f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  809f93:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809f96:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809f99:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809f9c:	89 ec                	mov    %ebp,%esp
  809f9e:	5d                   	pop    %ebp
  809f9f:	c3                   	ret    
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  809fa0:	8b 45 10             	mov    0x10(%ebp),%eax
  809fa3:	89 04 24             	mov    %eax,(%esp)
  809fa6:	e8 4d ae ff ff       	call   804df8 <pbuf_ref>
  809fab:	8b 5d 10             	mov    0x10(%ebp),%ebx
  809fae:	eb 83                	jmp    809f33 <etharp_query+0x199>

00809fb0 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  809fb0:	55                   	push   %ebp
  809fb1:	89 e5                	mov    %esp,%ebp
  809fb3:	83 ec 48             	sub    $0x48,%esp
  809fb6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809fb9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  809fbc:	89 7d fc             	mov    %edi,-0x4(%ebp)
  809fbf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809fc2:	8b 75 0c             	mov    0xc(%ebp),%esi
  809fc5:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809fc8:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  809fcf:	00 
  809fd0:	89 34 24             	mov    %esi,(%esp)
  809fd3:	e8 ef ae ff ff       	call   804ec7 <pbuf_header>
  809fd8:	89 c2                	mov    %eax,%edx
  809fda:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809fdf:	84 d2                	test   %dl,%dl
  809fe1:	0f 85 bd 00 00 00    	jne    80a0a4 <etharp_output+0xf4>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809fe7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809feb:	89 3c 24             	mov    %edi,(%esp)
  809fee:	e8 4d cb ff ff       	call   806b40 <ip_addr_isbroadcast>
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  809ff3:	ba bb 25 81 00       	mov    $0x8125bb,%edx
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809ff8:	84 c0                	test   %al,%al
  809ffa:	0f 85 95 00 00 00    	jne    80a095 <etharp_output+0xe5>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80a000:	8b 07                	mov    (%edi),%eax
  80a002:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80a005:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80a00c:	e8 7b e0 ff ff       	call   80808c <ntohl>
  80a011:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80a014:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80a01b:	e8 6c e0 ff ff       	call   80808c <ntohl>
  80a020:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80a023:	23 55 d0             	and    -0x30(%ebp),%edx
  80a026:	39 c2                	cmp    %eax,%edx
  80a028:	75 41                	jne    80a06b <etharp_output+0xbb>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80a02a:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  80a02e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80a032:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80a036:	8b 07                	mov    (%edi),%eax
  80a038:	89 04 24             	mov    %eax,(%esp)
  80a03b:	e8 4c e0 ff ff       	call   80808c <ntohl>
  80a040:	c1 e8 10             	shr    $0x10,%eax
  80a043:	83 e0 7f             	and    $0x7f,%eax
  80a046:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80a049:	8b 07                	mov    (%edi),%eax
  80a04b:	89 04 24             	mov    %eax,(%esp)
  80a04e:	e8 39 e0 ff ff       	call   80808c <ntohl>
  80a053:	c1 e8 08             	shr    $0x8,%eax
  80a056:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80a059:	8b 07                	mov    (%edi),%eax
  80a05b:	89 04 24             	mov    %eax,(%esp)
  80a05e:	e8 29 e0 ff ff       	call   80808c <ntohl>
  80a063:	88 45 e7             	mov    %al,-0x19(%ebp)
  80a066:	8d 55 e2             	lea    -0x1e(%ebp),%edx
  80a069:	eb 2a                	jmp    80a095 <etharp_output+0xe5>
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80a06b:	8b 43 04             	mov    0x4(%ebx),%eax
  80a06e:	33 07                	xor    (%edi),%eax
  80a070:	85 43 08             	test   %eax,0x8(%ebx)
  80a073:	74 0e                	je     80a083 <etharp_output+0xd3>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  80a075:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a07a:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80a07e:	74 24                	je     80a0a4 <etharp_output+0xf4>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  80a080:	8d 7b 0c             	lea    0xc(%ebx),%edi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80a083:	89 74 24 08          	mov    %esi,0x8(%esp)
  80a087:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a08b:	89 1c 24             	mov    %ebx,(%esp)
  80a08e:	e8 07 fd ff ff       	call   809d9a <etharp_query>
  80a093:	eb 0f                	jmp    80a0a4 <etharp_output+0xf4>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80a095:	8d 4b 25             	lea    0x25(%ebx),%ecx
  80a098:	89 14 24             	mov    %edx,(%esp)
  80a09b:	89 f2                	mov    %esi,%edx
  80a09d:	89 d8                	mov    %ebx,%eax
  80a09f:	e8 6c f8 ff ff       	call   809910 <etharp_send_ip>
}
  80a0a4:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80a0a7:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80a0aa:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80a0ad:	89 ec                	mov    %ebp,%esp
  80a0af:	5d                   	pop    %ebp
  80a0b0:	c3                   	ret    

0080a0b1 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  80a0b1:	55                   	push   %ebp
  80a0b2:	89 e5                	mov    %esp,%ebp
  80a0b4:	53                   	push   %ebx
  80a0b5:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  80a0b8:	ba 02 00 00 00       	mov    $0x2,%edx
  80a0bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a0c0:	e8 a7 fa ff ff       	call   809b6c <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  80a0c5:	84 c0                	test   %al,%al
  80a0c7:	78 29                	js     80a0f2 <etharp_find_addr+0x41>
  80a0c9:	0f be d0             	movsbl %al,%edx
  80a0cc:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80a0cf:	83 b9 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ecx)
  80a0d6:	75 1a                	jne    80a0f2 <etharp_find_addr+0x41>
      *eth_ret = &arp_table[i].ethaddr;
  80a0d8:	89 ca                	mov    %ecx,%edx
  80a0da:	81 c2 20 4a b3 00    	add    $0xb34a20,%edx
  80a0e0:	8d 5a 08             	lea    0x8(%edx),%ebx
  80a0e3:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80a0e6:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  80a0e8:	83 c2 04             	add    $0x4,%edx
  80a0eb:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80a0ee:	89 11                	mov    %edx,(%ecx)
      return i;
  80a0f0:	eb 05                	jmp    80a0f7 <etharp_find_addr+0x46>
  80a0f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }
  return -1;
}
  80a0f7:	83 c4 04             	add    $0x4,%esp
  80a0fa:	5b                   	pop    %ebx
  80a0fb:	5d                   	pop    %ebp
  80a0fc:	c3                   	ret    

0080a0fd <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  80a0fd:	55                   	push   %ebp
  80a0fe:	89 e5                	mov    %esp,%ebp
  80a100:	57                   	push   %edi
  80a101:	56                   	push   %esi
  80a102:	53                   	push   %ebx
  80a103:	83 ec 0c             	sub    $0xc,%esp
  80a106:	bb 00 00 00 00       	mov    $0x0,%ebx
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80a10b:	be 34 4a b3 00       	mov    $0xb34a34,%esi
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80a110:	bf 30 4a b3 00       	mov    $0xb34a30,%edi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80a115:	0f b6 14 1e          	movzbl (%esi,%ebx,1),%edx
  80a119:	83 c2 01             	add    $0x1,%edx
  80a11c:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80a11f:	8b 04 1f             	mov    (%edi,%ebx,1),%eax
  80a122:	83 f8 02             	cmp    $0x2,%eax
  80a125:	75 07                	jne    80a12e <etharp_tmr+0x31>
  80a127:	80 fa ef             	cmp    $0xef,%dl
  80a12a:	77 0c                	ja     80a138 <etharp_tmr+0x3b>
  80a12c:	eb 2a                	jmp    80a158 <etharp_tmr+0x5b>
  80a12e:	83 f8 01             	cmp    $0x1,%eax
  80a131:	75 25                	jne    80a158 <etharp_tmr+0x5b>
  80a133:	80 fa 01             	cmp    $0x1,%dl
  80a136:	76 20                	jbe    80a158 <etharp_tmr+0x5b>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  80a138:	8b 83 20 4a b3 00    	mov    0xb34a20(%ebx),%eax
  80a13e:	85 c0                	test   %eax,%eax
  80a140:	74 0f                	je     80a151 <etharp_tmr+0x54>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  80a142:	e8 8f f9 ff ff       	call   809ad6 <free_etharp_q>
        arp_table[i].q = NULL;
  80a147:	c7 83 20 4a b3 00 00 	movl   $0x0,0xb34a20(%ebx)
  80a14e:	00 00 00 
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  80a151:	c7 04 1f 00 00 00 00 	movl   $0x0,(%edi,%ebx,1)
  80a158:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80a15b:	81 fb 18 01 00 00    	cmp    $0x118,%ebx
  80a161:	75 b2                	jne    80a115 <etharp_tmr+0x18>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  80a163:	83 c4 0c             	add    $0xc,%esp
  80a166:	5b                   	pop    %ebx
  80a167:	5e                   	pop    %esi
  80a168:	5f                   	pop    %edi
  80a169:	5d                   	pop    %ebp
  80a16a:	c3                   	ret    

0080a16b <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80a16b:	55                   	push   %ebp
  80a16c:	89 e5                	mov    %esp,%ebp
  80a16e:	83 ec 38             	sub    $0x38,%esp
  80a171:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80a174:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80a177:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80a17a:	89 c6                	mov    %eax,%esi
  80a17c:	89 d3                	mov    %edx,%ebx
  80a17e:	89 cf                	mov    %ecx,%edi
  80a180:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
  80a184:	88 45 e4             	mov    %al,-0x1c(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80a187:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80a18b:	74 1c                	je     80a1a9 <update_arp_entry+0x3e>
  80a18d:	c7 44 24 08 fc 24 81 	movl   $0x8124fc,0x8(%esp)
  80a194:	00 
  80a195:	c7 44 24 04 d9 01 00 	movl   $0x1d9,0x4(%esp)
  80a19c:	00 
  80a19d:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  80a1a4:	e8 43 50 00 00       	call   80f1ec <_panic>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80a1a9:	85 d2                	test   %edx,%edx
  80a1ab:	0f 84 14 01 00 00    	je     80a2c5 <update_arp_entry+0x15a>
  80a1b1:	83 3a 00             	cmpl   $0x0,(%edx)
  80a1b4:	0f 84 0b 01 00 00    	je     80a2c5 <update_arp_entry+0x15a>
      ip_addr_isbroadcast(ipaddr, netif) ||
  80a1ba:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a1be:	89 14 24             	mov    %edx,(%esp)
  80a1c1:	e8 7a c9 ff ff       	call   806b40 <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80a1c6:	84 c0                	test   %al,%al
  80a1c8:	0f 85 f7 00 00 00    	jne    80a2c5 <update_arp_entry+0x15a>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  80a1ce:	8b 13                	mov    (%ebx),%edx
  80a1d0:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80a1d3:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80a1da:	e8 ad de ff ff       	call   80808c <ntohl>
  80a1df:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80a1e2:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80a1e9:	e8 9e de ff ff       	call   80808c <ntohl>
  80a1ee:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80a1f1:	23 55 e0             	and    -0x20(%ebp),%edx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80a1f4:	39 c2                	cmp    %eax,%edx
  80a1f6:	0f 84 c9 00 00 00    	je     80a2c5 <update_arp_entry+0x15a>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  80a1fc:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
  80a200:	89 d8                	mov    %ebx,%eax
  80a202:	e8 65 f9 ff ff       	call   809b6c <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  80a207:	84 c0                	test   %al,%al
  80a209:	0f 88 bb 00 00 00    	js     80a2ca <update_arp_entry+0x15f>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  80a20f:	0f be c0             	movsbl %al,%eax
  80a212:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80a215:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80a218:	c7 80 30 4a b3 00 02 	movl   $0x2,0xb34a30(%eax)
  80a21f:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  80a222:	89 b0 38 4a b3 00    	mov    %esi,0xb34a38(%eax)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80a228:	0f b6 5f 05          	movzbl 0x5(%edi),%ebx
  80a22c:	88 98 2d 4a b3 00    	mov    %bl,0xb34a2d(%eax)
  80a232:	6b 4d e0 07          	imul   $0x7,-0x20(%ebp),%ecx
  80a236:	bb 20 4a b3 00       	mov    $0xb34a20,%ebx
  80a23b:	0f b6 57 04          	movzbl 0x4(%edi),%edx
  80a23f:	88 54 8b 0c          	mov    %dl,0xc(%ebx,%ecx,4)
  80a243:	0f b6 4f 03          	movzbl 0x3(%edi),%ecx
  80a247:	88 88 2b 4a b3 00    	mov    %cl,0xb34a2b(%eax)
  80a24d:	6b 4d e0 0e          	imul   $0xe,-0x20(%ebp),%ecx
  80a251:	0f b6 57 02          	movzbl 0x2(%edi),%edx
  80a255:	88 54 4b 0a          	mov    %dl,0xa(%ebx,%ecx,2)
  80a259:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
  80a25d:	88 88 29 4a b3 00    	mov    %cl,0xb34a29(%eax)
  80a263:	0f b6 0f             	movzbl (%edi),%ecx
  80a266:	88 4c 18 08          	mov    %cl,0x8(%eax,%ebx,1)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  80a26a:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80a271:	8d 4e 25             	lea    0x25(%esi),%ecx
  80a274:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80a277:	6b 45 e0 1c          	imul   $0x1c,-0x20(%ebp),%eax
  80a27b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80a27e:	eb 39                	jmp    80a2b9 <update_arp_entry+0x14e>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  80a280:	8b 10                	mov    (%eax),%edx
  80a282:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80a285:	89 14 19             	mov    %edx,(%ecx,%ebx,1)
    /* get the packet pointer */
    p = q->p;
  80a288:	8b 50 04             	mov    0x4(%eax),%edx
  80a28b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  80a28e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a292:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80a299:	e8 26 a8 ff ff       	call   804ac4 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80a29e:	89 3c 24             	mov    %edi,(%esp)
  80a2a1:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80a2a4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a2a7:	89 f0                	mov    %esi,%eax
  80a2a9:	e8 62 f6 ff ff       	call   809910 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  80a2ae:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80a2b1:	89 0c 24             	mov    %ecx,(%esp)
  80a2b4:	e8 6b af ff ff       	call   805224 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80a2b9:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a2bc:	8b 04 1a             	mov    (%edx,%ebx,1),%eax
  80a2bf:	85 c0                	test   %eax,%eax
  80a2c1:	75 bd                	jne    80a280 <update_arp_entry+0x115>
  80a2c3:	eb 05                	jmp    80a2ca <update_arp_entry+0x15f>
  80a2c5:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  80a2ca:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80a2cd:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80a2d0:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80a2d3:	89 ec                	mov    %ebp,%esp
  80a2d5:	5d                   	pop    %ebp
  80a2d6:	c3                   	ret    

0080a2d7 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  80a2d7:	55                   	push   %ebp
  80a2d8:	89 e5                	mov    %esp,%ebp
  80a2da:	83 ec 18             	sub    $0x18,%esp
  80a2dd:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80a2e0:	85 c0                	test   %eax,%eax
  80a2e2:	75 1c                	jne    80a300 <etharp_ip_input+0x29>
  80a2e4:	c7 44 24 08 bb 17 81 	movl   $0x8117bb,0x8(%esp)
  80a2eb:	00 
  80a2ec:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  80a2f3:	00 
  80a2f4:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  80a2fb:	e8 ec 4e 00 00       	call   80f1ec <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  80a300:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a303:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80a306:	8b 48 04             	mov    0x4(%eax),%ecx
  80a309:	33 4a 1c             	xor    0x1c(%edx),%ecx
  80a30c:	85 48 08             	test   %ecx,0x8(%eax)
  80a30f:	75 12                	jne    80a323 <etharp_ip_input+0x4c>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80a311:	8d 4a 06             	lea    0x6(%edx),%ecx
  80a314:	83 c2 1c             	add    $0x1c,%edx
  80a317:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80a31e:	e8 48 fe ff ff       	call   80a16b <update_arp_entry>
}
  80a323:	c9                   	leave  
  80a324:	c3                   	ret    

0080a325 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  80a325:	55                   	push   %ebp
  80a326:	89 e5                	mov    %esp,%ebp
  80a328:	83 ec 38             	sub    $0x38,%esp
  80a32b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80a32e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80a331:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80a334:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80a337:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80a33b:	75 1c                	jne    80a359 <etharp_arp_input+0x34>
  80a33d:	c7 44 24 08 bb 17 81 	movl   $0x8117bb,0x8(%esp)
  80a344:	00 
  80a345:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80a34c:	00 
  80a34d:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  80a354:	e8 93 4e 00 00       	call   80f1ec <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  80a359:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  80a35e:	77 0d                	ja     80a36d <etharp_arp_input+0x48>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80a360:	89 1c 24             	mov    %ebx,(%esp)
  80a363:	e8 bc ae ff ff       	call   805224 <pbuf_free>
    return;
  80a368:	e9 a4 01 00 00       	jmp    80a511 <etharp_arp_input+0x1ec>
  }

  hdr = p->payload;
  80a36d:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80a370:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  80a374:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80a37b:	e8 df da ff ff       	call   807e5f <htons>
  80a380:	66 39 c7             	cmp    %ax,%di
  80a383:	75 3f                	jne    80a3c4 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  80a385:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  80a389:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80a390:	e8 ca da ff ff       	call   807e5f <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80a395:	66 39 c7             	cmp    %ax,%di
  80a398:	75 2a                	jne    80a3c4 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80a39a:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  80a39e:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80a3a5:	e8 b5 da ff ff       	call   807e5f <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80a3aa:	66 39 c7             	cmp    %ax,%di
  80a3ad:	75 15                	jne    80a3c4 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  80a3af:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  80a3b3:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80a3ba:	e8 a0 da ff ff       	call   807e5f <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80a3bf:	66 39 c7             	cmp    %ax,%di
  80a3c2:	74 0d                	je     80a3d1 <etharp_arp_input+0xac>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80a3c4:	89 1c 24             	mov    %ebx,(%esp)
  80a3c7:	e8 58 ae ff ff       	call   805224 <pbuf_free>
    return;
  80a3cc:	e9 40 01 00 00       	jmp    80a511 <etharp_arp_input+0x1ec>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80a3d1:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80a3d8:	00 
  80a3d9:	8d 46 1c             	lea    0x1c(%esi),%eax
  80a3dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a3e0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80a3e3:	89 04 24             	mov    %eax,(%esp)
  80a3e6:	e8 40 57 00 00       	call   80fb2b <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80a3eb:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80a3f2:	00 
  80a3f3:	8d 46 26             	lea    0x26(%esi),%eax
  80a3f6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a3fa:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80a3fd:	89 04 24             	mov    %eax,(%esp)
  80a400:	e8 26 57 00 00       	call   80fb2b <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80a405:	8b 55 08             	mov    0x8(%ebp),%edx
  80a408:	8b 42 04             	mov    0x4(%edx),%eax

  /* ARP message directed to us? */
  if (for_us) {
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80a40b:	bf 00 00 00 00       	mov    $0x0,%edi
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80a410:	85 c0                	test   %eax,%eax
  80a412:	74 21                	je     80a435 <etharp_arp_input+0x110>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  80a414:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  }

  /* ARP message directed to us? */
  if (for_us) {
  80a417:	0f 94 c0             	sete   %al
  80a41a:	89 c7                	mov    %eax,%edi
  80a41c:	75 17                	jne    80a435 <etharp_arp_input+0x110>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80a41e:	8d 4e 16             	lea    0x16(%esi),%ecx
  80a421:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80a424:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80a42b:	8b 45 08             	mov    0x8(%ebp),%eax
  80a42e:	e8 38 fd ff ff       	call   80a16b <update_arp_entry>
  80a433:	eb 15                	jmp    80a44a <etharp_arp_input+0x125>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  80a435:	8d 4e 16             	lea    0x16(%esi),%ecx
  80a438:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80a43b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80a442:	8b 45 08             	mov    0x8(%ebp),%eax
  80a445:	e8 21 fd ff ff       	call   80a16b <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  80a44a:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  80a44e:	89 04 24             	mov    %eax,(%esp)
  80a451:	e8 09 da ff ff       	call   807e5f <htons>
  80a456:	66 83 f8 01          	cmp    $0x1,%ax
  80a45a:	74 0f                	je     80a46b <etharp_arp_input+0x146>
  80a45c:	66 83 f8 02          	cmp    $0x2,%ax
  80a460:	0f 85 a3 00 00 00    	jne    80a509 <etharp_arp_input+0x1e4>
  80a466:	e9 8c 00 00 00       	jmp    80a4f7 <etharp_arp_input+0x1d2>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  80a46b:	89 fa                	mov    %edi,%edx
  80a46d:	84 d2                	test   %dl,%dl
  80a46f:	90                   	nop
  80a470:	0f 84 93 00 00 00    	je     80a509 <etharp_arp_input+0x1e4>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  80a476:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80a47d:	e8 dd d9 ff ff       	call   807e5f <htons>
  80a482:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  80a486:	8b 46 1c             	mov    0x1c(%esi),%eax
  80a489:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  80a48c:	8b 55 08             	mov    0x8(%ebp),%edx
  80a48f:	8b 42 04             	mov    0x4(%edx),%eax
  80a492:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80a495:	ba 06 00 00 00       	mov    $0x6,%edx
  80a49a:	8b 45 08             	mov    0x8(%ebp),%eax
  80a49d:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80a4a1:	74 1c                	je     80a4bf <etharp_arp_input+0x19a>
  80a4a3:	c7 44 24 08 5c 24 81 	movl   $0x81245c,0x8(%esp)
  80a4aa:	00 
  80a4ab:	c7 44 24 04 c7 02 00 	movl   $0x2c7,0x4(%esp)
  80a4b2:	00 
  80a4b3:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  80a4ba:	e8 2d 4d 00 00       	call   80f1ec <_panic>
  80a4bf:	8b 7d 0c             	mov    0xc(%ebp),%edi
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  80a4c2:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  80a4c5:	0f b6 c2             	movzbl %dl,%eax
  80a4c8:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  80a4cd:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  80a4d1:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80a4d4:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80a4d8:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  80a4dc:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80a4e0:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  80a4e4:	84 d2                	test   %dl,%dl
  80a4e6:	75 da                	jne    80a4c2 <etharp_arp_input+0x19d>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  80a4e8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a4ec:	8b 55 08             	mov    0x8(%ebp),%edx
  80a4ef:	89 14 24             	mov    %edx,(%esp)
  80a4f2:	ff 52 18             	call   *0x18(%edx)
  80a4f5:	eb 12                	jmp    80a509 <etharp_arp_input+0x1e4>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  80a4f7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80a4fa:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a4fe:	8b 45 08             	mov    0x8(%ebp),%eax
  80a501:	89 04 24             	mov    %eax,(%esp)
  80a504:	e8 5e 93 ff ff       	call   803867 <dhcp_arp_reply>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  80a509:	89 1c 24             	mov    %ebx,(%esp)
  80a50c:	e8 13 ad ff ff       	call   805224 <pbuf_free>
}
  80a511:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80a514:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80a517:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80a51a:	89 ec                	mov    %ebp,%esp
  80a51c:	5d                   	pop    %ebp
  80a51d:	c3                   	ret    

0080a51e <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80a51e:	55                   	push   %ebp
  80a51f:	89 e5                	mov    %esp,%ebp
  80a521:	83 ec 18             	sub    $0x18,%esp
  80a524:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80a527:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80a52a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a52d:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80a530:	8b 43 04             	mov    0x4(%ebx),%eax
  80a533:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80a537:	89 04 24             	mov    %eax,(%esp)
  80a53a:	e8 20 d9 ff ff       	call   807e5f <htons>
  80a53f:	66 3d 00 08          	cmp    $0x800,%ax
  80a543:	74 08                	je     80a54d <ethernet_input+0x2f>
  80a545:	66 3d 06 08          	cmp    $0x806,%ax
  80a549:	75 61                	jne    80a5ac <ethernet_input+0x8e>
  80a54b:	eb 4a                	jmp    80a597 <ethernet_input+0x79>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80a54d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a551:	89 34 24             	mov    %esi,(%esp)
  80a554:	e8 7e fd ff ff       	call   80a2d7 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80a559:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80a560:	ff 
  80a561:	89 1c 24             	mov    %ebx,(%esp)
  80a564:	e8 5e a9 ff ff       	call   804ec7 <pbuf_header>
  80a569:	84 c0                	test   %al,%al
  80a56b:	74 1c                	je     80a589 <ethernet_input+0x6b>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80a56d:	c7 44 24 08 24 25 81 	movl   $0x812524,0x8(%esp)
  80a574:	00 
  80a575:	c7 44 24 04 7e 04 00 	movl   $0x47e,0x4(%esp)
  80a57c:	00 
  80a57d:	c7 04 24 45 25 81 00 	movl   $0x812545,(%esp)
  80a584:	e8 63 4c 00 00       	call   80f1ec <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80a589:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a58d:	89 1c 24             	mov    %ebx,(%esp)
  80a590:	e8 75 c8 ff ff       	call   806e0a <ip_input>
      }
      break;
  80a595:	eb 1d                	jmp    80a5b4 <ethernet_input+0x96>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80a597:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80a59b:	8d 46 25             	lea    0x25(%esi),%eax
  80a59e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a5a2:	89 34 24             	mov    %esi,(%esp)
  80a5a5:	e8 7b fd ff ff       	call   80a325 <etharp_arp_input>
      break;
  80a5aa:	eb 08                	jmp    80a5b4 <ethernet_input+0x96>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80a5ac:	89 1c 24             	mov    %ebx,(%esp)
  80a5af:	e8 70 ac ff ff       	call   805224 <pbuf_free>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80a5b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80a5b9:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80a5bc:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80a5bf:	89 ec                	mov    %ebp,%esp
  80a5c1:	5d                   	pop    %ebp
  80a5c2:	c3                   	ret    
	...

0080a5d0 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80a5d0:	55                   	push   %ebp
  80a5d1:	89 e5                	mov    %esp,%ebp
  80a5d3:	56                   	push   %esi
  80a5d4:	53                   	push   %ebx
  80a5d5:	b8 40 4b b3 00       	mov    $0xb34b40,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80a5da:	be 40 5f b3 00       	mov    $0xb35f40,%esi
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80a5df:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  80a5e5:	89 c1                	mov    %eax,%ecx
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a5e7:	8b 15 40 5f b3 00    	mov    0xb35f40,%edx
  80a5ed:	89 50 0c             	mov    %edx,0xc(%eax)
  80a5f0:	85 d2                	test   %edx,%edx
  80a5f2:	74 06                	je     80a5fa <sys_init+0x2a>
  80a5f4:	8d 58 0c             	lea    0xc(%eax),%ebx
  80a5f7:	89 5a 10             	mov    %ebx,0x10(%edx)
  80a5fa:	89 0d 40 5f b3 00    	mov    %ecx,0xb35f40
  80a600:	c7 40 10 40 5f b3 00 	movl   $0xb35f40,0x10(%eax)
  80a607:	83 c0 14             	add    $0x14,%eax

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80a60a:	39 f0                	cmp    %esi,%eax
  80a60c:	75 d1                	jne    80a5df <sys_init+0xf>
  80a60e:	eb 3f                	jmp    80a64f <sys_init+0x7f>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80a610:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  80a616:	89 c1                	mov    %eax,%ecx
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a618:	8b 15 60 ad b3 00    	mov    0xb3ad60,%edx
  80a61e:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  80a624:	85 d2                	test   %edx,%edx
  80a626:	74 0c                	je     80a634 <sys_init+0x64>
  80a628:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  80a62e:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  80a634:	89 0d 60 ad b3 00    	mov    %ecx,0xb3ad60
  80a63a:	c7 80 98 00 00 00 60 	movl   $0xb3ad60,0x98(%eax)
  80a641:	ad b3 00 
  80a644:	05 9c 00 00 00       	add    $0x9c,%eax
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  80a649:	39 f0                	cmp    %esi,%eax
  80a64b:	75 c3                	jne    80a610 <sys_init+0x40>
  80a64d:	eb 0c                	jmp    80a65b <sys_init+0x8b>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  80a64f:	b8 60 5f b3 00       	mov    $0xb35f60,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80a654:	be 60 ad b3 00       	mov    $0xb3ad60,%esi
  80a659:	eb b5                	jmp    80a610 <sys_init+0x40>

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  80a65b:	5b                   	pop    %ebx
  80a65c:	5e                   	pop    %esi
  80a65d:	5d                   	pop    %ebp
  80a65e:	c3                   	ret    

0080a65f <lwip_core_lock>:
    return &t->tmo;
}

void
lwip_core_lock(void)
{
  80a65f:	55                   	push   %ebp
  80a660:	89 e5                	mov    %esp,%ebp
}
  80a662:	5d                   	pop    %ebp
  80a663:	c3                   	ret    

0080a664 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80a664:	55                   	push   %ebp
  80a665:	89 e5                	mov    %esp,%ebp
}
  80a667:	5d                   	pop    %ebp
  80a668:	c3                   	ret    

0080a669 <sys_sem_free>:
    return se - &sems[0];
}

void
sys_sem_free(sys_sem_t sem)
{
  80a669:	55                   	push   %ebp
  80a66a:	89 e5                	mov    %esp,%ebp
  80a66c:	53                   	push   %ebx
  80a66d:	83 ec 14             	sub    $0x14,%esp
  80a670:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a673:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a676:	83 3c 95 40 4b b3 00 	cmpl   $0x0,0xb34b40(,%edx,4)
  80a67d:	00 
  80a67e:	74 24                	je     80a6a4 <sys_sem_free+0x3b>
  80a680:	c7 44 24 0c c7 25 81 	movl   $0x8125c7,0xc(%esp)
  80a687:	00 
  80a688:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  80a68f:	00 
  80a690:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80a697:	00 
  80a698:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80a69f:	e8 48 4b 00 00       	call   80f1ec <_panic>
    sems[sem].freed = 1;
  80a6a4:	b9 40 4b b3 00       	mov    $0xb34b40,%ecx
  80a6a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a6b0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  80a6b3:	c7 04 99 01 00 00 00 	movl   $0x1,(%ecx,%ebx,4)
    sems[sem].gen++;
  80a6ba:	83 44 99 04 01       	addl   $0x1,0x4(%ecx,%ebx,4)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80a6bf:	8d 04 9d 40 4b b3 00 	lea    0xb34b40(,%ebx,4),%eax
  80a6c6:	8b 15 40 5f b3 00    	mov    0xb35f40,%edx
  80a6cc:	89 50 0c             	mov    %edx,0xc(%eax)
  80a6cf:	85 d2                	test   %edx,%edx
  80a6d1:	74 06                	je     80a6d9 <sys_sem_free+0x70>
  80a6d3:	8d 48 0c             	lea    0xc(%eax),%ecx
  80a6d6:	89 4a 10             	mov    %ecx,0x10(%edx)
  80a6d9:	a3 40 5f b3 00       	mov    %eax,0xb35f40
  80a6de:	c7 40 10 40 5f b3 00 	movl   $0xb35f40,0x10(%eax)
}
  80a6e5:	83 c4 14             	add    $0x14,%esp
  80a6e8:	5b                   	pop    %ebx
  80a6e9:	5d                   	pop    %ebp
  80a6ea:	c3                   	ret    

0080a6eb <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  80a6eb:	55                   	push   %ebp
  80a6ec:	89 e5                	mov    %esp,%ebp
  80a6ee:	56                   	push   %esi
  80a6ef:	53                   	push   %ebx
  80a6f0:	83 ec 10             	sub    $0x10,%esp
  80a6f3:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80a6f6:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80a6fc:	83 b8 60 5f b3 00 00 	cmpl   $0x0,0xb35f60(%eax)
  80a703:	74 24                	je     80a729 <sys_mbox_free+0x3e>
  80a705:	c7 44 24 0c 0a 26 81 	movl   $0x81260a,0xc(%esp)
  80a70c:	00 
  80a70d:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  80a714:	00 
  80a715:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  80a71c:	00 
  80a71d:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80a724:	e8 c3 4a 00 00       	call   80f1ec <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  80a729:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80a72f:	8b 83 ec 5f b3 00    	mov    0xb35fec(%ebx),%eax
  80a735:	89 04 24             	mov    %eax,(%esp)
  80a738:	e8 2c ff ff ff       	call   80a669 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80a73d:	8b 83 f0 5f b3 00    	mov    0xb35ff0(%ebx),%eax
  80a743:	89 04 24             	mov    %eax,(%esp)
  80a746:	e8 1e ff ff ff       	call   80a669 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80a74b:	81 c3 60 5f b3 00    	add    $0xb35f60,%ebx
  80a751:	a1 60 ad b3 00       	mov    0xb3ad60,%eax
  80a756:	89 83 94 00 00 00    	mov    %eax,0x94(%ebx)
  80a75c:	85 c0                	test   %eax,%eax
  80a75e:	74 0c                	je     80a76c <sys_mbox_free+0x81>
  80a760:	8d 93 94 00 00 00    	lea    0x94(%ebx),%edx
  80a766:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a76c:	89 1d 60 ad b3 00    	mov    %ebx,0xb3ad60
  80a772:	c7 83 98 00 00 00 60 	movl   $0xb3ad60,0x98(%ebx)
  80a779:	ad b3 00 
    mboxes[mbox].freed = 1;
  80a77c:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80a782:	c7 86 60 5f b3 00 01 	movl   $0x1,0xb35f60(%esi)
  80a789:	00 00 00 
}
  80a78c:	83 c4 10             	add    $0x10,%esp
  80a78f:	5b                   	pop    %ebx
  80a790:	5e                   	pop    %esi
  80a791:	5d                   	pop    %ebp
  80a792:	c3                   	ret    

0080a793 <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a793:	55                   	push   %ebp
  80a794:	89 e5                	mov    %esp,%ebp
  80a796:	57                   	push   %edi
  80a797:	56                   	push   %esi
  80a798:	53                   	push   %ebx
  80a799:	83 ec 1c             	sub    $0x1c,%esp
    thread_id_t tid = thread_id();
  80a79c:	e8 a2 07 00 00       	call   80af43 <thread_id>
  80a7a1:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a7a3:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a7a8:	f7 e2                	mul    %edx
  80a7aa:	c1 ea 08             	shr    $0x8,%edx
  80a7ad:	89 d0                	mov    %edx,%eax
  80a7af:	c1 e0 08             	shl    $0x8,%eax
  80a7b2:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80a7b5:	89 f0                	mov    %esi,%eax
  80a7b7:	29 d0                	sub    %edx,%eax
  80a7b9:	8d 3c 85 80 ad b3 00 	lea    0xb3ad80(,%eax,4),%edi
  80a7c0:	8b 1f                	mov    (%edi),%ebx
  80a7c2:	eb 0b                	jmp    80a7cf <sys_arch_timeouts+0x3c>
	if (t->tid == tid)
  80a7c4:	3b 33                	cmp    (%ebx),%esi
  80a7c6:	0f 84 a0 00 00 00    	je     80a86c <sys_arch_timeouts+0xd9>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a7cc:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a7cf:	85 db                	test   %ebx,%ebx
  80a7d1:	75 f1                	jne    80a7c4 <sys_arch_timeouts+0x31>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80a7d3:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  80a7da:	e8 10 62 00 00       	call   8109ef <malloc>
  80a7df:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a7e1:	85 c0                	test   %eax,%eax
  80a7e3:	75 1c                	jne    80a801 <sys_arch_timeouts+0x6e>
	panic("sys_arch_timeouts: cannot malloc");
  80a7e5:	c7 44 24 08 6c 26 81 	movl   $0x81266c,0x8(%esp)
  80a7ec:	00 
  80a7ed:	c7 44 24 04 2c 01 00 	movl   $0x12c,0x4(%esp)
  80a7f4:	00 
  80a7f5:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80a7fc:	e8 eb 49 00 00       	call   80f1ec <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80a801:	c7 04 24 77 a8 80 00 	movl   $0x80a877,(%esp)
  80a808:	e8 84 07 00 00       	call   80af91 <thread_onhalt>
    if (r < 0)
  80a80d:	85 c0                	test   %eax,%eax
  80a80f:	79 28                	jns    80a839 <sys_arch_timeouts+0xa6>
	panic("thread_onhalt failed: %s", e2s(r));
  80a811:	89 04 24             	mov    %eax,(%esp)
  80a814:	e8 df 0a 00 00       	call   80b2f8 <e2s>
  80a819:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80a81d:	c7 44 24 08 1e 26 81 	movl   $0x81261e,0x8(%esp)
  80a824:	00 
  80a825:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80a82c:	00 
  80a82d:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80a834:	e8 b3 49 00 00       	call   80f1ec <_panic>

    t->tid = tid;
  80a839:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a83b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80a842:	00 
  80a843:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80a84a:	00 
  80a84b:	8d 43 04             	lea    0x4(%ebx),%eax
  80a84e:	89 04 24             	mov    %eax,(%esp)
  80a851:	e8 fa 51 00 00       	call   80fa50 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a856:	8b 07                	mov    (%edi),%eax
  80a858:	89 43 08             	mov    %eax,0x8(%ebx)
  80a85b:	85 c0                	test   %eax,%eax
  80a85d:	74 08                	je     80a867 <sys_arch_timeouts+0xd4>
  80a85f:	8b 07                	mov    (%edi),%eax
  80a861:	8d 53 08             	lea    0x8(%ebx),%edx
  80a864:	89 50 0c             	mov    %edx,0xc(%eax)
  80a867:	89 1f                	mov    %ebx,(%edi)
  80a869:	89 7b 0c             	mov    %edi,0xc(%ebx)
  80a86c:	8d 43 04             	lea    0x4(%ebx),%eax

out:
    return &t->tmo;
}
  80a86f:	83 c4 1c             	add    $0x1c,%esp
  80a872:	5b                   	pop    %ebx
  80a873:	5e                   	pop    %esi
  80a874:	5f                   	pop    %edi
  80a875:	5d                   	pop    %ebp
  80a876:	c3                   	ret    

0080a877 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  80a877:	55                   	push   %ebp
  80a878:	89 e5                	mov    %esp,%ebp
  80a87a:	83 ec 18             	sub    $0x18,%esp
  80a87d:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a880:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a885:	89 c8                	mov    %ecx,%eax
  80a887:	f7 e2                	mul    %edx
  80a889:	c1 ea 08             	shr    $0x8,%edx
  80a88c:	89 d0                	mov    %edx,%eax
  80a88e:	c1 e0 08             	shl    $0x8,%eax
  80a891:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80a894:	89 c8                	mov    %ecx,%eax
  80a896:	29 d0                	sub    %edx,%eax
  80a898:	8b 04 85 80 ad b3 00 	mov    0xb3ad80(,%eax,4),%eax
  80a89f:	eb 26                	jmp    80a8c7 <timeout_cleanup+0x50>
	if (t->tid == tid) {
  80a8a1:	39 08                	cmp    %ecx,(%eax)
  80a8a3:	75 1f                	jne    80a8c4 <timeout_cleanup+0x4d>
	    LIST_REMOVE(t, link);
  80a8a5:	8b 50 08             	mov    0x8(%eax),%edx
  80a8a8:	85 d2                	test   %edx,%edx
  80a8aa:	74 06                	je     80a8b2 <timeout_cleanup+0x3b>
  80a8ac:	8b 48 0c             	mov    0xc(%eax),%ecx
  80a8af:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80a8b2:	8b 50 0c             	mov    0xc(%eax),%edx
  80a8b5:	8b 48 08             	mov    0x8(%eax),%ecx
  80a8b8:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  80a8ba:	89 04 24             	mov    %eax,(%esp)
  80a8bd:	e8 5a 60 00 00       	call   81091c <free>
	    goto done;
  80a8c2:	eb 07                	jmp    80a8cb <timeout_cleanup+0x54>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a8c4:	8b 40 08             	mov    0x8(%eax),%eax
  80a8c7:	85 c0                	test   %eax,%eax
  80a8c9:	75 d6                	jne    80a8a1 <timeout_cleanup+0x2a>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80a8cb:	c9                   	leave  
  80a8cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80a8d0:	c3                   	ret    

0080a8d1 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80a8d1:	55                   	push   %ebp
  80a8d2:	89 e5                	mov    %esp,%ebp
  80a8d4:	53                   	push   %ebx
  80a8d5:	83 ec 14             	sub    $0x14,%esp
  80a8d8:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  80a8db:	8b 43 04             	mov    0x4(%ebx),%eax
  80a8de:	89 04 24             	mov    %eax,(%esp)
  80a8e1:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  80a8e3:	89 1c 24             	mov    %ebx,(%esp)
  80a8e6:	e8 31 60 00 00       	call   81091c <free>
}
  80a8eb:	83 c4 14             	add    $0x14,%esp
  80a8ee:	5b                   	pop    %ebx
  80a8ef:	5d                   	pop    %ebp
  80a8f0:	c3                   	ret    

0080a8f1 <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80a8f1:	55                   	push   %ebp
  80a8f2:	89 e5                	mov    %esp,%ebp
  80a8f4:	53                   	push   %ebx
  80a8f5:	83 ec 24             	sub    $0x24,%esp
  80a8f8:	8b 5d 14             	mov    0x14(%ebp),%ebx
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a8fb:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80a902:	e8 e8 60 00 00       	call   8109ef <malloc>
    if (lt == 0)
  80a907:	85 c0                	test   %eax,%eax
  80a909:	75 1c                	jne    80a927 <sys_thread_new+0x36>
	panic("sys_thread_new: cannot allocate thread struct");
  80a90b:	c7 44 24 08 90 26 81 	movl   $0x812690,0x8(%esp)
  80a912:	00 
  80a913:	c7 44 24 04 fd 00 00 	movl   $0xfd,0x4(%esp)
  80a91a:	00 
  80a91b:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80a922:	e8 c5 48 00 00       	call   80f1ec <_panic>

    if (stacksize > PGSIZE)
  80a927:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  80a92d:	7e 20                	jle    80a94f <sys_thread_new+0x5e>
	panic("large stack %d", stacksize);
  80a92f:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80a933:	c7 44 24 08 37 26 81 	movl   $0x812637,0x8(%esp)
  80a93a:	00 
  80a93b:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  80a942:	00 
  80a943:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80a94a:	e8 9d 48 00 00       	call   80f1ec <_panic>

    lt->func = thread;
  80a94f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a952:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a954:	8b 55 10             	mov    0x10(%ebp),%edx
  80a957:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a95a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80a95e:	c7 44 24 08 d1 a8 80 	movl   $0x80a8d1,0x8(%esp)
  80a965:	00 
  80a966:	8b 45 08             	mov    0x8(%ebp),%eax
  80a969:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a96d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a970:	89 04 24             	mov    %eax,(%esp)
  80a973:	e8 86 07 00 00       	call   80b0fe <thread_create>

    if (r < 0)
  80a978:	85 c0                	test   %eax,%eax
  80a97a:	79 28                	jns    80a9a4 <sys_thread_new+0xb3>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a97c:	89 04 24             	mov    %eax,(%esp)
  80a97f:	e8 74 09 00 00       	call   80b2f8 <e2s>
  80a984:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80a988:	c7 44 24 08 c0 26 81 	movl   $0x8126c0,0x8(%esp)
  80a98f:	00 
  80a990:	c7 44 24 04 09 01 00 	movl   $0x109,0x4(%esp)
  80a997:	00 
  80a998:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80a99f:	e8 48 48 00 00       	call   80f1ec <_panic>

    return tid;
}
  80a9a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a9a7:	83 c4 24             	add    $0x24,%esp
  80a9aa:	5b                   	pop    %ebx
  80a9ab:	5d                   	pop    %ebp
  80a9ac:	c3                   	ret    

0080a9ad <sys_arch_sem_wait>:
    }
}

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80a9ad:	55                   	push   %ebp
  80a9ae:	89 e5                	mov    %esp,%ebp
  80a9b0:	57                   	push   %edi
  80a9b1:	56                   	push   %esi
  80a9b2:	53                   	push   %ebx
  80a9b3:	83 ec 2c             	sub    $0x2c,%esp
  80a9b6:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!sems[sem].freed);
  80a9b9:	8b 55 08             	mov    0x8(%ebp),%edx
  80a9bc:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80a9bf:	83 3c 85 40 4b b3 00 	cmpl   $0x0,0xb34b40(,%eax,4)
  80a9c6:	00 
  80a9c7:	74 24                	je     80a9ed <sys_arch_sem_wait+0x40>
  80a9c9:	c7 44 24 0c c7 25 81 	movl   $0x8125c7,0xc(%esp)
  80a9d0:	00 
  80a9d1:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  80a9d8:	00 
  80a9d9:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
  80a9e0:	00 
  80a9e1:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80a9e8:	e8 ff 47 00 00       	call   80f1ec <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80a9ed:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9f0:	c1 e0 02             	shl    $0x2,%eax
  80a9f3:	8b 55 08             	mov    0x8(%ebp),%edx
  80a9f6:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80a9f9:	8b 14 95 44 4b b3 00 	mov    0xb34b44(,%edx,4),%edx
  80aa00:	89 55 dc             	mov    %edx,-0x24(%ebp)
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80aa03:	03 45 08             	add    0x8(%ebp),%eax
  80aa06:	8d 04 85 48 4b b3 00 	lea    0xb34b48(,%eax,4),%eax
  80aa0d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80aa10:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80aa17:	bb 40 4b b3 00       	mov    $0xb34b40,%ebx
  80aa1c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80aa1f:	8d 34 89             	lea    (%ecx,%ecx,4),%esi
  80aa22:	c1 e6 02             	shl    $0x2,%esi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80aa25:	e9 82 00 00 00       	jmp    80aaac <sys_arch_sem_wait+0xff>
	if (sems[sem].counter > 0) {
  80aa2a:	0f b7 44 1e 08       	movzwl 0x8(%esi,%ebx,1),%eax
  80aa2f:	66 85 c0             	test   %ax,%ax
  80aa32:	74 13                	je     80aa47 <sys_arch_sem_wait+0x9a>
	    sems[sem].counter--;
  80aa34:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80aa37:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  80aa3a:	83 e8 01             	sub    $0x1,%eax
  80aa3d:	66 89 04 95 48 4b b3 	mov    %ax,0xb34b48(,%edx,4)
  80aa44:	00 
	    return waited;
  80aa45:	eb 7d                	jmp    80aac4 <sys_arch_sem_wait+0x117>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80aa47:	83 ff fe             	cmp    $0xfffffffe,%edi
  80aa4a:	74 71                	je     80aabd <sys_arch_sem_wait+0x110>
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80aa4c:	e8 a2 52 00 00       	call   80fcf3 <sys_time_msec>
  80aa51:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80aa54:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80aa59:	85 ff                	test   %edi,%edi
  80aa5b:	74 08                	je     80aa65 <sys_arch_sem_wait+0xb8>
  80aa5d:	89 f8                	mov    %edi,%eax
  80aa5f:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80aa62:	03 45 e0             	add    -0x20(%ebp),%eax
	    sems[sem].waiters = 1;
  80aa65:	66 c7 44 1e 0a 01 00 	movw   $0x1,0xa(%esi,%ebx,1)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80aa6c:	89 44 24 08          	mov    %eax,0x8(%esp)
  80aa70:	8b 44 1e 08          	mov    0x8(%esi,%ebx,1),%eax
  80aa74:	89 44 24 04          	mov    %eax,0x4(%esp)
  80aa78:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80aa7b:	89 04 24             	mov    %eax,(%esp)
  80aa7e:	e8 c3 07 00 00       	call   80b246 <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80aa83:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80aa86:	39 54 1e 04          	cmp    %edx,0x4(%esi,%ebx,1)
  80aa8a:	74 15                	je     80aaa1 <sys_arch_sem_wait+0xf4>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80aa8c:	c7 04 24 ec 26 81 00 	movl   $0x8126ec,(%esp)
  80aa93:	e8 0d 48 00 00       	call   80f2a5 <cprintf>
  80aa98:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		return SYS_ARCH_TIMEOUT;
  80aa9f:	eb 23                	jmp    80aac4 <sys_arch_sem_wait+0x117>
	    }
	    uint32_t b = sys_time_msec();
  80aaa1:	e8 4d 52 00 00       	call   80fcf3 <sys_time_msec>
	    waited += (b - a);
  80aaa6:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80aaa9:	01 45 e4             	add    %eax,-0x1c(%ebp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80aaac:	85 ff                	test   %edi,%edi
  80aaae:	0f 84 76 ff ff ff    	je     80aa2a <sys_arch_sem_wait+0x7d>
  80aab4:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  80aab7:	0f 82 6d ff ff ff    	jb     80aa2a <sys_arch_sem_wait+0x7d>
  80aabd:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80aac4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80aac7:	83 c4 2c             	add    $0x2c,%esp
  80aaca:	5b                   	pop    %ebx
  80aacb:	5e                   	pop    %esi
  80aacc:	5f                   	pop    %edi
  80aacd:	5d                   	pop    %ebp
  80aace:	c3                   	ret    

0080aacf <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  80aacf:	55                   	push   %ebp
  80aad0:	89 e5                	mov    %esp,%ebp
  80aad2:	53                   	push   %ebx
  80aad3:	83 ec 14             	sub    $0x14,%esp
  80aad6:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80aada:	a1 40 5f b3 00       	mov    0xb35f40,%eax
    if (!se) {
  80aadf:	85 c0                	test   %eax,%eax
  80aae1:	75 13                	jne    80aaf6 <sys_sem_new+0x27>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80aae3:	c7 04 24 18 27 81 00 	movl   $0x812718,(%esp)
  80aaea:	e8 b6 47 00 00       	call   80f2a5 <cprintf>
  80aaef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return SYS_SEM_NULL;
  80aaf4:	eb 5d                	jmp    80ab53 <sys_sem_new+0x84>
    }
    LIST_REMOVE(se, link);
  80aaf6:	8b 50 0c             	mov    0xc(%eax),%edx
  80aaf9:	85 d2                	test   %edx,%edx
  80aafb:	74 06                	je     80ab03 <sys_sem_new+0x34>
  80aafd:	8b 58 10             	mov    0x10(%eax),%ebx
  80ab00:	89 5a 10             	mov    %ebx,0x10(%edx)
  80ab03:	8b 50 10             	mov    0x10(%eax),%edx
  80ab06:	8b 58 0c             	mov    0xc(%eax),%ebx
  80ab09:	89 1a                	mov    %ebx,(%edx)
    assert(se->freed);
  80ab0b:	83 38 00             	cmpl   $0x0,(%eax)
  80ab0e:	75 24                	jne    80ab34 <sys_sem_new+0x65>
  80ab10:	c7 44 24 0c 46 26 81 	movl   $0x812646,0xc(%esp)
  80ab17:	00 
  80ab18:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  80ab1f:	00 
  80ab20:	c7 44 24 04 8d 00 00 	movl   $0x8d,0x4(%esp)
  80ab27:	00 
  80ab28:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80ab2f:	e8 b8 46 00 00       	call   80f1ec <_panic>
    se->freed = 0;
  80ab34:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  80ab3a:	0f b6 c9             	movzbl %cl,%ecx
  80ab3d:	66 89 48 08          	mov    %cx,0x8(%eax)
    se->gen++;
  80ab41:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  80ab45:	2d 40 4b b3 00       	sub    $0xb34b40,%eax
  80ab4a:	c1 f8 02             	sar    $0x2,%eax
  80ab4d:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  80ab53:	83 c4 14             	add    $0x14,%esp
  80ab56:	5b                   	pop    %ebx
  80ab57:	5d                   	pop    %ebp
  80ab58:	c3                   	ret    

0080ab59 <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  80ab59:	55                   	push   %ebp
  80ab5a:	89 e5                	mov    %esp,%ebp
  80ab5c:	56                   	push   %esi
  80ab5d:	53                   	push   %ebx
  80ab5e:	83 ec 10             	sub    $0x10,%esp
    assert(size < MBOXSLOTS);
  80ab61:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80ab65:	7e 24                	jle    80ab8b <sys_mbox_new+0x32>
  80ab67:	c7 44 24 0c 50 26 81 	movl   $0x812650,0xc(%esp)
  80ab6e:	00 
  80ab6f:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  80ab76:	00 
  80ab77:	c7 44 24 04 45 00 00 	movl   $0x45,0x4(%esp)
  80ab7e:	00 
  80ab7f:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80ab86:	e8 61 46 00 00       	call   80f1ec <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80ab8b:	8b 1d 60 ad b3 00    	mov    0xb3ad60,%ebx
    if (!mbe) {
  80ab91:	85 db                	test   %ebx,%ebx
  80ab93:	75 16                	jne    80abab <sys_mbox_new+0x52>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80ab95:	c7 04 24 40 27 81 00 	movl   $0x812740,(%esp)
  80ab9c:	e8 04 47 00 00       	call   80f2a5 <cprintf>
  80aba1:	be ff ff ff ff       	mov    $0xffffffff,%esi
	return SYS_MBOX_NULL;
  80aba6:	e9 bd 00 00 00       	jmp    80ac68 <sys_mbox_new+0x10f>
    }
    LIST_REMOVE(mbe, link);
  80abab:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80abb1:	85 c0                	test   %eax,%eax
  80abb3:	74 0c                	je     80abc1 <sys_mbox_new+0x68>
  80abb5:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80abbb:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80abc1:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80abc7:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80abcd:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80abcf:	83 3b 00             	cmpl   $0x0,(%ebx)
  80abd2:	75 24                	jne    80abf8 <sys_mbox_new+0x9f>
  80abd4:	c7 44 24 0c 61 26 81 	movl   $0x812661,0xc(%esp)
  80abdb:	00 
  80abdc:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  80abe3:	00 
  80abe4:	c7 44 24 04 4c 00 00 	movl   $0x4c,0x4(%esp)
  80abeb:	00 
  80abec:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80abf3:	e8 f4 45 00 00       	call   80f1ec <_panic>
    mbe->freed = 0;
  80abf8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80abfe:	89 de                	mov    %ebx,%esi
  80ac00:	81 ee 60 5f b3 00    	sub    $0xb35f60,%esi
  80ac06:	c1 fe 02             	sar    $0x2,%esi
  80ac09:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
    mbe->head = -1;
  80ac0f:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80ac16:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80ac1d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ac24:	e8 a6 fe ff ff       	call   80aacf <sys_sem_new>
  80ac29:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80ac2f:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80ac36:	e8 94 fe ff ff       	call   80aacf <sys_sem_new>
  80ac3b:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80ac41:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80ac48:	74 05                	je     80ac4f <sys_mbox_new+0xf6>
  80ac4a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ac4d:	75 19                	jne    80ac68 <sys_mbox_new+0x10f>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  80ac4f:	89 34 24             	mov    %esi,(%esp)
  80ac52:	e8 94 fa ff ff       	call   80a6eb <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80ac57:	c7 04 24 68 27 81 00 	movl   $0x812768,(%esp)
  80ac5e:	e8 42 46 00 00       	call   80f2a5 <cprintf>
  80ac63:	be ff ff ff ff       	mov    $0xffffffff,%esi
	return SYS_MBOX_NULL;
    }
    return i;
}
  80ac68:	89 f0                	mov    %esi,%eax
  80ac6a:	83 c4 10             	add    $0x10,%esp
  80ac6d:	5b                   	pop    %ebx
  80ac6e:	5e                   	pop    %esi
  80ac6f:	5d                   	pop    %ebp
  80ac70:	c3                   	ret    

0080ac71 <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  80ac71:	55                   	push   %ebp
  80ac72:	89 e5                	mov    %esp,%ebp
  80ac74:	53                   	push   %ebx
  80ac75:	83 ec 14             	sub    $0x14,%esp
  80ac78:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80ac7b:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80ac7e:	83 3c 95 40 4b b3 00 	cmpl   $0x0,0xb34b40(,%edx,4)
  80ac85:	00 
  80ac86:	74 24                	je     80acac <sys_sem_signal+0x3b>
  80ac88:	c7 44 24 0c c7 25 81 	movl   $0x8125c7,0xc(%esp)
  80ac8f:	00 
  80ac90:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  80ac97:	00 
  80ac98:	c7 44 24 04 a1 00 00 	movl   $0xa1,0x4(%esp)
  80ac9f:	00 
  80aca0:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80aca7:	e8 40 45 00 00       	call   80f1ec <_panic>
    sems[sem].counter++;
  80acac:	ba 40 4b b3 00       	mov    $0xb34b40,%edx
  80acb1:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  80acb8:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
  80acbb:	66 83 44 9a 08 01    	addw   $0x1,0x8(%edx,%ebx,4)
    if (sems[sem].waiters) {
  80acc1:	66 83 7c 9a 0a 00    	cmpw   $0x0,0xa(%edx,%ebx,4)
  80acc7:	74 19                	je     80ace2 <sys_sem_signal+0x71>
	sems[sem].waiters = 0;
  80acc9:	66 c7 04 9d 4a 4b b3 	movw   $0x0,0xb34b4a(,%ebx,4)
  80acd0:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80acd3:	8d 04 9d 48 4b b3 00 	lea    0xb34b48(,%ebx,4),%eax
  80acda:	89 04 24             	mov    %eax,(%esp)
  80acdd:	e8 6d 02 00 00       	call   80af4f <thread_wakeup>
    }
}
  80ace2:	83 c4 14             	add    $0x14,%esp
  80ace5:	5b                   	pop    %ebx
  80ace6:	5d                   	pop    %ebp
  80ace7:	c3                   	ret    

0080ace8 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80ace8:	55                   	push   %ebp
  80ace9:	89 e5                	mov    %esp,%ebp
  80aceb:	83 ec 28             	sub    $0x28,%esp
  80acee:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80acf1:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80acf4:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80acf7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80acfa:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80acfd:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80ad03:	83 b8 60 5f b3 00 00 	cmpl   $0x0,0xb35f60(%eax)
  80ad0a:	74 24                	je     80ad30 <sys_arch_mbox_fetch+0x48>
  80ad0c:	c7 44 24 0c 0a 26 81 	movl   $0x81260a,0xc(%esp)
  80ad13:	00 
  80ad14:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  80ad1b:	00 
  80ad1c:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80ad23:	00 
  80ad24:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80ad2b:	e8 bc 44 00 00       	call   80f1ec <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80ad30:	8b 45 10             	mov    0x10(%ebp),%eax
  80ad33:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ad37:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80ad3d:	8b 80 ec 5f b3 00    	mov    0xb35fec(%eax),%eax
  80ad43:	89 04 24             	mov    %eax,(%esp)
  80ad46:	e8 62 fc ff ff       	call   80a9ad <sys_arch_sem_wait>
  80ad4b:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80ad4d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ad50:	0f 84 85 00 00 00    	je     80addb <sys_arch_mbox_fetch+0xf3>
	return waited;

    int slot = mboxes[mbox].head;
  80ad56:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80ad5c:	8b 80 64 5f b3 00    	mov    0xb35f64(%eax),%eax
    if (slot == -1)
  80ad62:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ad65:	75 1c                	jne    80ad83 <sys_arch_mbox_fetch+0x9b>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80ad67:	c7 44 24 08 94 27 81 	movl   $0x812794,0x8(%esp)
  80ad6e:	00 
  80ad6f:	c7 44 24 04 d6 00 00 	movl   $0xd6,0x4(%esp)
  80ad76:	00 
  80ad77:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80ad7e:	e8 69 44 00 00       	call   80f1ec <_panic>
    if (msg)
  80ad83:	85 ff                	test   %edi,%edi
  80ad85:	74 0e                	je     80ad95 <sys_arch_mbox_fetch+0xad>
	*msg = mboxes[mbox].msg[slot];
  80ad87:	6b d3 27             	imul   $0x27,%ebx,%edx
  80ad8a:	01 c2                	add    %eax,%edx
  80ad8c:	8b 14 95 6c 5f b3 00 	mov    0xb35f6c(,%edx,4),%edx
  80ad93:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80ad95:	8d 48 01             	lea    0x1(%eax),%ecx
  80ad98:	89 ca                	mov    %ecx,%edx
  80ad9a:	c1 fa 1f             	sar    $0x1f,%edx
  80ad9d:	c1 ea 1b             	shr    $0x1b,%edx
  80ada0:	8d 04 11             	lea    (%ecx,%edx,1),%eax
  80ada3:	83 e0 1f             	and    $0x1f,%eax
  80ada6:	29 d0                	sub    %edx,%eax
  80ada8:	ba 60 5f b3 00       	mov    $0xb35f60,%edx
  80adad:	69 cb 9c 00 00 00    	imul   $0x9c,%ebx,%ecx
  80adb3:	89 44 11 04          	mov    %eax,0x4(%ecx,%edx,1)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80adb7:	3b 44 11 08          	cmp    0x8(%ecx,%edx,1),%eax
  80adbb:	75 0a                	jne    80adc7 <sys_arch_mbox_fetch+0xdf>
	mboxes[mbox].head = -1;
  80adbd:	c7 81 64 5f b3 00 ff 	movl   $0xffffffff,0xb35f64(%ecx)
  80adc4:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80adc7:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80adcd:	8b 83 f0 5f b3 00    	mov    0xb35ff0(%ebx),%eax
  80add3:	89 04 24             	mov    %eax,(%esp)
  80add6:	e8 96 fe ff ff       	call   80ac71 <sys_sem_signal>
    return waited;
}
  80addb:	89 f0                	mov    %esi,%eax
  80addd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ade0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ade3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ade6:	89 ec                	mov    %ebp,%esp
  80ade8:	5d                   	pop    %ebp
  80ade9:	c3                   	ret    

0080adea <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80adea:	55                   	push   %ebp
  80adeb:	89 e5                	mov    %esp,%ebp
  80aded:	83 ec 18             	sub    $0x18,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80adf0:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
  80adf7:	ff 
  80adf8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80adfb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80adff:	8b 45 08             	mov    0x8(%ebp),%eax
  80ae02:	89 04 24             	mov    %eax,(%esp)
  80ae05:	e8 de fe ff ff       	call   80ace8 <sys_arch_mbox_fetch>
}
  80ae0a:	c9                   	leave  
  80ae0b:	c3                   	ret    

0080ae0c <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80ae0c:	55                   	push   %ebp
  80ae0d:	89 e5                	mov    %esp,%ebp
  80ae0f:	83 ec 28             	sub    $0x28,%esp
  80ae12:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ae15:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ae18:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80ae1b:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80ae1e:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80ae24:	83 b8 60 5f b3 00 00 	cmpl   $0x0,0xb35f60(%eax)
  80ae2b:	74 24                	je     80ae51 <sys_mbox_trypost+0x45>
  80ae2d:	c7 44 24 0c 0a 26 81 	movl   $0x81260a,0xc(%esp)
  80ae34:	00 
  80ae35:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  80ae3c:	00 
  80ae3d:	c7 44 24 04 72 00 00 	movl   $0x72,0x4(%esp)
  80ae44:	00 
  80ae45:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80ae4c:	e8 9b 43 00 00       	call   80f1ec <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80ae51:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ae58:	00 
  80ae59:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80ae5f:	8b 83 f0 5f b3 00    	mov    0xb35ff0(%ebx),%eax
  80ae65:	89 04 24             	mov    %eax,(%esp)
  80ae68:	e8 40 fb ff ff       	call   80a9ad <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80ae6d:	b9 60 5f b3 00       	mov    $0xb35f60,%ecx
  80ae72:	8b 54 0b 08          	mov    0x8(%ebx,%ecx,1),%edx
  80ae76:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ae7b:	3b 54 0b 04          	cmp    0x4(%ebx,%ecx,1),%edx
  80ae7f:	74 4c                	je     80aecd <sys_mbox_trypost+0xc1>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80ae81:	89 c8                	mov    %ecx,%eax
  80ae83:	89 d9                	mov    %ebx,%ecx
  80ae85:	8d 7a 01             	lea    0x1(%edx),%edi
  80ae88:	89 fb                	mov    %edi,%ebx
  80ae8a:	c1 fb 1f             	sar    $0x1f,%ebx
  80ae8d:	c1 eb 1b             	shr    $0x1b,%ebx
  80ae90:	01 df                	add    %ebx,%edi
  80ae92:	83 e7 1f             	and    $0x1f,%edi
  80ae95:	29 df                	sub    %ebx,%edi
  80ae97:	89 7c 01 08          	mov    %edi,0x8(%ecx,%eax,1)
    mboxes[mbox].msg[slot] = msg;
  80ae9b:	6b de 27             	imul   $0x27,%esi,%ebx
  80ae9e:	01 d3                	add    %edx,%ebx
  80aea0:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80aea3:	89 7c 98 0c          	mov    %edi,0xc(%eax,%ebx,4)

    if (mboxes[mbox].head == -1)
  80aea7:	83 7c 01 04 ff       	cmpl   $0xffffffff,0x4(%ecx,%eax,1)
  80aeac:	75 06                	jne    80aeb4 <sys_mbox_trypost+0xa8>
	mboxes[mbox].head = slot;
  80aeae:	89 91 64 5f b3 00    	mov    %edx,0xb35f64(%ecx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80aeb4:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80aeba:	8b 86 ec 5f b3 00    	mov    0xb35fec(%esi),%eax
  80aec0:	89 04 24             	mov    %eax,(%esp)
  80aec3:	e8 a9 fd ff ff       	call   80ac71 <sys_sem_signal>
  80aec8:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80aecd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80aed0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80aed3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80aed6:	89 ec                	mov    %ebp,%esp
  80aed8:	5d                   	pop    %ebp
  80aed9:	c3                   	ret    

0080aeda <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80aeda:	55                   	push   %ebp
  80aedb:	89 e5                	mov    %esp,%ebp
  80aedd:	83 ec 18             	sub    $0x18,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80aee0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80aee3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80aee7:	8b 45 08             	mov    0x8(%ebp),%eax
  80aeea:	89 04 24             	mov    %eax,(%esp)
  80aeed:	e8 1a ff ff ff       	call   80ae0c <sys_mbox_trypost>
  80aef2:	84 c0                	test   %al,%al
  80aef4:	74 24                	je     80af1a <sys_mbox_post+0x40>
  80aef6:	c7 44 24 0c bc 27 81 	movl   $0x8127bc,0xc(%esp)
  80aefd:	00 
  80aefe:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  80af05:	00 
  80af06:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
  80af0d:	00 
  80af0e:	c7 04 24 ed 25 81 00 	movl   $0x8125ed,(%esp)
  80af15:	e8 d2 42 00 00       	call   80f1ec <_panic>
}
  80af1a:	c9                   	leave  
  80af1b:	c3                   	ret    
  80af1c:	00 00                	add    %al,(%eax)
	...

0080af20 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80af20:	55                   	push   %ebp
  80af21:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80af23:	c7 05 8c b1 b3 00 00 	movl   $0x0,0xb3b18c
  80af2a:	00 00 00 
    tq->tq_last = 0;
  80af2d:	c7 05 90 b1 b3 00 00 	movl   $0x0,0xb3b190
  80af34:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80af37:	c7 05 84 b1 b3 00 00 	movl   $0x0,0xb3b184
  80af3e:	00 00 00 
}
  80af41:	5d                   	pop    %ebp
  80af42:	c3                   	ret    

0080af43 <thread_id>:

uint32_t
thread_id(void) {
  80af43:	55                   	push   %ebp
  80af44:	89 e5                	mov    %esp,%ebp
  80af46:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
  80af4b:	8b 00                	mov    (%eax),%eax
    return cur_tc->tc_tid;
}
  80af4d:	5d                   	pop    %ebp
  80af4e:	c3                   	ret    

0080af4f <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80af4f:	55                   	push   %ebp
  80af50:	89 e5                	mov    %esp,%ebp
  80af52:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80af55:	a1 8c b1 b3 00       	mov    0xb3b18c,%eax
    while (tc) {
  80af5a:	eb 0c                	jmp    80af68 <thread_wakeup+0x19>
	if (tc->tc_wait_addr == addr)
  80af5c:	39 50 48             	cmp    %edx,0x48(%eax)
  80af5f:	75 04                	jne    80af65 <thread_wakeup+0x16>
	    tc->tc_wakeup = 1;
  80af61:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80af65:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80af68:	85 c0                	test   %eax,%eax
  80af6a:	75 f0                	jne    80af5c <thread_wakeup+0xd>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80af6c:	5d                   	pop    %ebp
  80af6d:	c3                   	ret    

0080af6e <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80af6e:	55                   	push   %ebp
  80af6f:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80af71:	8b 15 8c b1 b3 00    	mov    0xb3b18c,%edx
  80af77:	b8 00 00 00 00       	mov    $0x0,%eax
    int n = 0;
    while (tc) {
  80af7c:	eb 0d                	jmp    80af8b <thread_wakeups_pending+0x1d>
	if (tc->tc_wakeup)
  80af7e:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80af82:	80 f9 01             	cmp    $0x1,%cl
  80af85:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80af88:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80af8b:	85 d2                	test   %edx,%edx
  80af8d:	75 ef                	jne    80af7e <thread_wakeups_pending+0x10>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80af8f:	5d                   	pop    %ebp
  80af90:	c3                   	ret    

0080af91 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80af91:	55                   	push   %ebp
  80af92:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80af94:	8b 15 88 b1 b3 00    	mov    0xb3b188,%edx
  80af9a:	8b 4a 60             	mov    0x60(%edx),%ecx
  80af9d:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80afa2:	83 f9 03             	cmp    $0x3,%ecx
  80afa5:	7f 12                	jg     80afb9 <thread_onhalt+0x28>
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80afa7:	8b 45 08             	mov    0x8(%ebp),%eax
  80afaa:	89 44 8a 50          	mov    %eax,0x50(%edx,%ecx,4)
  80afae:	83 c1 01             	add    $0x1,%ecx
  80afb1:	89 4a 60             	mov    %ecx,0x60(%edx)
  80afb4:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
}
  80afb9:	5d                   	pop    %ebp
  80afba:	c3                   	ret    

0080afbb <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80afbb:	55                   	push   %ebp
  80afbc:	89 e5                	mov    %esp,%ebp
  80afbe:	53                   	push   %ebx
  80afbf:	83 ec 14             	sub    $0x14,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80afc2:	8b 1d 8c b1 b3 00    	mov    0xb3b18c,%ebx
  80afc8:	85 db                	test   %ebx,%ebx
  80afca:	74 69                	je     80b035 <thread_yield+0x7a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80afcc:	8b 43 64             	mov    0x64(%ebx),%eax
  80afcf:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
    tc->tc_queue_link = 0;
  80afd4:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80afdb:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
  80afe0:	85 c0                	test   %eax,%eax
  80afe2:	74 3e                	je     80b022 <thread_yield+0x67>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80afe4:	83 c0 30             	add    $0x30,%eax
  80afe7:	89 04 24             	mov    %eax,(%esp)
  80afea:	e8 c1 02 00 00       	call   80b2b0 <jos_setjmp>
  80afef:	85 c0                	test   %eax,%eax
  80aff1:	75 42                	jne    80b035 <thread_yield+0x7a>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80aff3:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80aff8:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80afff:	83 3d 8c b1 b3 00 00 	cmpl   $0x0,0xb3b18c
  80b006:	75 0c                	jne    80b014 <thread_yield+0x59>
	tq->tq_first = tc;
  80b008:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
	tq->tq_last = tc;
  80b00d:	a3 90 b1 b3 00       	mov    %eax,0xb3b190
  80b012:	eb 0e                	jmp    80b022 <thread_yield+0x67>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b014:	8b 15 90 b1 b3 00    	mov    0xb3b190,%edx
  80b01a:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80b01d:	a3 90 b1 b3 00       	mov    %eax,0xb3b190
    }

    cur_tc = next_tc;
  80b022:	89 1d 88 b1 b3 00    	mov    %ebx,0xb3b188
    jos_longjmp(&cur_tc->tc_jb, 1);
  80b028:	8d 43 30             	lea    0x30(%ebx),%eax
  80b02b:	ba 01 00 00 00       	mov    $0x1,%edx
  80b030:	e8 ab 02 00 00       	call   80b2e0 <jos_longjmp>
}
  80b035:	83 c4 14             	add    $0x14,%esp
  80b038:	5b                   	pop    %ebx
  80b039:	5d                   	pop    %ebp
  80b03a:	c3                   	ret    

0080b03b <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80b03b:	55                   	push   %ebp
  80b03c:	89 e5                	mov    %esp,%ebp
  80b03e:	56                   	push   %esi
  80b03f:	53                   	push   %ebx
  80b040:	83 ec 10             	sub    $0x10,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80b043:	8b 1d 94 b1 b3 00    	mov    0xb3b194,%ebx
  80b049:	85 db                	test   %ebx,%ebx
  80b04b:	0f 84 84 00 00 00    	je     80b0d5 <thread_halt+0x9a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80b051:	8b 43 64             	mov    0x64(%ebx),%eax
  80b054:	a3 94 b1 b3 00       	mov    %eax,0xb3b194
    tc->tc_queue_link = 0;
  80b059:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80b060:	be 00 00 00 00       	mov    $0x0,%esi
  80b065:	eb 0c                	jmp    80b073 <thread_halt+0x38>
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
  80b067:	8b 03                	mov    (%ebx),%eax
  80b069:	89 04 24             	mov    %eax,(%esp)
  80b06c:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80b070:	83 c6 01             	add    $0x1,%esi
  80b073:	3b 73 60             	cmp    0x60(%ebx),%esi
  80b076:	7c ef                	jl     80b067 <thread_halt+0x2c>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80b078:	8b 43 04             	mov    0x4(%ebx),%eax
  80b07b:	89 04 24             	mov    %eax,(%esp)
  80b07e:	e8 99 58 00 00       	call   81091c <free>
    free(tc);
  80b083:	89 1c 24             	mov    %ebx,(%esp)
  80b086:	e8 91 58 00 00       	call   81091c <free>
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80b08b:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80b090:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80b097:	83 3d 94 b1 b3 00 00 	cmpl   $0x0,0xb3b194
  80b09e:	75 0c                	jne    80b0ac <thread_halt+0x71>
	tq->tq_first = tc;
  80b0a0:	a3 94 b1 b3 00       	mov    %eax,0xb3b194
	tq->tq_last = tc;
  80b0a5:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
  80b0aa:	eb 0e                	jmp    80b0ba <thread_halt+0x7f>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b0ac:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80b0b2:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80b0b5:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
    cur_tc = NULL;
  80b0ba:	c7 05 88 b1 b3 00 00 	movl   $0x0,0xb3b188
  80b0c1:	00 00 00 
    thread_yield();
  80b0c4:	e8 f2 fe ff ff       	call   80afbb <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80b0c9:	e8 0a 41 00 00       	call   80f1d8 <exit>
}
  80b0ce:	83 c4 10             	add    $0x10,%esp
  80b0d1:	5b                   	pop    %ebx
  80b0d2:	5e                   	pop    %esi
  80b0d3:	5d                   	pop    %ebp
  80b0d4:	c3                   	ret    
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80b0d5:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80b0da:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
  80b0e1:	eb bd                	jmp    80b0a0 <thread_halt+0x65>

0080b0e3 <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80b0e3:	55                   	push   %ebp
  80b0e4:	89 e5                	mov    %esp,%ebp
  80b0e6:	83 ec 18             	sub    $0x18,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80b0e9:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
  80b0ee:	8b 50 2c             	mov    0x2c(%eax),%edx
  80b0f1:	89 14 24             	mov    %edx,(%esp)
  80b0f4:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80b0f7:	e8 3f ff ff ff       	call   80b03b <thread_halt>
}
  80b0fc:	c9                   	leave  
  80b0fd:	c3                   	ret    

0080b0fe <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80b0fe:	55                   	push   %ebp
  80b0ff:	89 e5                	mov    %esp,%ebp
  80b101:	57                   	push   %edi
  80b102:	56                   	push   %esi
  80b103:	53                   	push   %ebx
  80b104:	83 ec 1c             	sub    $0x1c,%esp
  80b107:	8b 7d 08             	mov    0x8(%ebp),%edi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80b10a:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp)
  80b111:	e8 d9 58 00 00       	call   8109ef <malloc>
  80b116:	89 c3                	mov    %eax,%ebx
    if (!tc)
  80b118:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80b11d:	85 db                	test   %ebx,%ebx
  80b11f:	0f 84 19 01 00 00    	je     80b23e <thread_create+0x140>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80b125:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
  80b12c:	00 
  80b12d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80b134:	00 
  80b135:	89 1c 24             	mov    %ebx,(%esp)
  80b138:	e8 13 49 00 00       	call   80fa50 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80b13d:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  80b144:	00 
  80b145:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b148:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b14c:	8d 43 08             	lea    0x8(%ebx),%eax
  80b14f:	89 04 24             	mov    %eax,(%esp)
  80b152:	e8 fe 47 00 00       	call   80f955 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80b157:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80b15b:	a1 84 b1 b3 00       	mov    0xb3b184,%eax
  80b160:	8d 50 01             	lea    0x1(%eax),%edx
  80b163:	89 15 84 b1 b3 00    	mov    %edx,0xb3b184
    if (max_tid == (uint32_t)~0)
  80b169:	83 fa ff             	cmp    $0xffffffff,%edx
  80b16c:	75 1c                	jne    80b18a <thread_create+0x8c>
	panic("alloc_tid: no more thread ids");
  80b16e:	c7 44 24 08 e2 27 81 	movl   $0x8127e2,0x8(%esp)
  80b175:	00 
  80b176:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80b17d:	00 
  80b17e:	c7 04 24 00 28 81 00 	movl   $0x812800,(%esp)
  80b185:	e8 62 40 00 00       	call   80f1ec <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80b18a:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80b18c:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80b193:	e8 57 58 00 00       	call   8109ef <malloc>
  80b198:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80b19b:	85 c0                	test   %eax,%eax
  80b19d:	75 12                	jne    80b1b1 <thread_create+0xb3>
	free(tc);
  80b19f:	89 1c 24             	mov    %ebx,(%esp)
  80b1a2:	e8 75 57 00 00       	call   81091c <free>
  80b1a7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
	return -E_NO_MEM;
  80b1ac:	e9 8d 00 00 00       	jmp    80b23e <thread_create+0x140>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80b1b1:	8d b0 fc 0f 00 00    	lea    0xffc(%eax),%esi
    memset(stacktop, 0, 4);
  80b1b7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80b1be:	00 
  80b1bf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80b1c6:	00 
  80b1c7:	89 34 24             	mov    %esi,(%esp)
  80b1ca:	e8 81 48 00 00       	call   80fa50 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80b1cf:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  80b1d6:	00 
  80b1d7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80b1de:	00 
  80b1df:	8d 43 30             	lea    0x30(%ebx),%eax
  80b1e2:	89 04 24             	mov    %eax,(%esp)
  80b1e5:	e8 66 48 00 00       	call   80fa50 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80b1ea:	89 73 34             	mov    %esi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80b1ed:	c7 43 30 e3 b0 80 00 	movl   $0x80b0e3,0x30(%ebx)
    tc->tc_entry = entry;
  80b1f4:	8b 45 10             	mov    0x10(%ebp),%eax
  80b1f7:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80b1fa:	8b 45 14             	mov    0x14(%ebp),%eax
  80b1fd:	89 43 2c             	mov    %eax,0x2c(%ebx)
  80b200:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80b207:	83 3d 8c b1 b3 00 00 	cmpl   $0x0,0xb3b18c
  80b20e:	75 0e                	jne    80b21e <thread_create+0x120>
	tq->tq_first = tc;
  80b210:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c
	tq->tq_last = tc;
  80b216:	89 1d 90 b1 b3 00    	mov    %ebx,0xb3b190
  80b21c:	eb 0e                	jmp    80b22c <thread_create+0x12e>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b21e:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80b223:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80b226:	89 1d 90 b1 b3 00    	mov    %ebx,0xb3b190

    threadq_push(&thread_queue, tc);

    if (tid)
  80b22c:	b8 00 00 00 00       	mov    $0x0,%eax
  80b231:	85 ff                	test   %edi,%edi
  80b233:	74 09                	je     80b23e <thread_create+0x140>
	*tid = tc->tc_tid;
  80b235:	8b 03                	mov    (%ebx),%eax
  80b237:	89 07                	mov    %eax,(%edi)
  80b239:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
}
  80b23e:	83 c4 1c             	add    $0x1c,%esp
  80b241:	5b                   	pop    %ebx
  80b242:	5e                   	pop    %esi
  80b243:	5f                   	pop    %edi
  80b244:	5d                   	pop    %ebp
  80b245:	c3                   	ret    

0080b246 <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80b246:	55                   	push   %ebp
  80b247:	89 e5                	mov    %esp,%ebp
  80b249:	57                   	push   %edi
  80b24a:	56                   	push   %esi
  80b24b:	53                   	push   %ebx
  80b24c:	83 ec 0c             	sub    $0xc,%esp
  80b24f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b252:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80b255:	e8 99 4a 00 00       	call   80fcf3 <sys_time_msec>
  80b25a:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80b25c:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
  80b261:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80b264:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
  80b268:	89 f0                	mov    %esi,%eax

    while (p < msec) {
  80b26a:	eb 26                	jmp    80b292 <thread_wait+0x4c>
	if (p < s)
  80b26c:	39 f0                	cmp    %esi,%eax
  80b26e:	72 26                	jb     80b296 <thread_wait+0x50>
	    break;
	if (addr && *addr != val)
  80b270:	85 db                	test   %ebx,%ebx
  80b272:	74 07                	je     80b27b <thread_wait+0x35>
  80b274:	8b 03                	mov    (%ebx),%eax
  80b276:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80b279:	75 1b                	jne    80b296 <thread_wait+0x50>
	    break;
	if (cur_tc->tc_wakeup)
  80b27b:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
  80b280:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80b284:	84 c0                	test   %al,%al
  80b286:	75 0e                	jne    80b296 <thread_wait+0x50>
	    break;

	thread_yield();
  80b288:	e8 2e fd ff ff       	call   80afbb <thread_yield>
	p = sys_time_msec();
  80b28d:	e8 61 4a 00 00       	call   80fcf3 <sys_time_msec>
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80b292:	39 f8                	cmp    %edi,%eax
  80b294:	72 d6                	jb     80b26c <thread_wait+0x26>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80b296:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
  80b29b:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80b2a2:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80b2a6:	83 c4 0c             	add    $0xc,%esp
  80b2a9:	5b                   	pop    %ebx
  80b2aa:	5e                   	pop    %esi
  80b2ab:	5f                   	pop    %edi
  80b2ac:	5d                   	pop    %ebp
  80b2ad:	c3                   	ret    
	...

0080b2b0 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80b2b0:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80b2b4:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80b2b7:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80b2b9:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80b2bd:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80b2c0:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80b2c3:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80b2c6:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80b2c9:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80b2cc:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80b2d1:	c3                   	ret    
  80b2d2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80b2d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080b2e0 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80b2e0:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80b2e2:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80b2e5:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80b2e8:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80b2eb:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80b2ee:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80b2f1:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80b2f3:	ff e1                	jmp    *%ecx
  80b2f5:	00 00                	add    %al,(%eax)
	...

0080b2f8 <e2s>:
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
  80b2f8:	55                   	push   %ebp
  80b2f9:	89 e5                	mov    %esp,%ebp
  80b2fb:	8b 45 08             	mov    0x8(%ebp),%eax
  80b2fe:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
	return sys_errlist[err];
}
  80b305:	5d                   	pop    %ebp
  80b306:	c3                   	ret    

0080b307 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80b307:	55                   	push   %ebp
  80b308:	89 e5                	mov    %esp,%ebp
  80b30a:	83 ec 18             	sub    $0x18,%esp
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80b30d:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
  80b312:	89 04 24             	mov    %eax,(%esp)
  80b315:	e8 de ff ff ff       	call   80b2f8 <e2s>
  80b31a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b31e:	8b 45 08             	mov    0x8(%ebp),%eax
  80b321:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b325:	c7 04 24 1b 28 81 00 	movl   $0x81281b,(%esp)
  80b32c:	e8 74 3f 00 00       	call   80f2a5 <cprintf>
}
  80b331:	c9                   	leave  
  80b332:	c3                   	ret    
	...

0080b340 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80b340:	55                   	push   %ebp
  80b341:	89 e5                	mov    %esp,%ebp
  80b343:	83 ec 38             	sub    $0x38,%esp
  80b346:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80b349:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80b34c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80b34f:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80b352:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80b359:	e8 8e 91 ff ff       	call   8044ec <mem_malloc>
  80b35e:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
  80b360:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b365:	85 f6                	test   %esi,%esi
  80b367:	0f 84 8a 00 00 00    	je     80b3f7 <jif_init+0xb7>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80b36d:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80b370:	89 73 1c             	mov    %esi,0x1c(%ebx)
    netif->output = jif_output;
  80b373:	c7 43 14 01 b5 80 00 	movl   $0x80b501,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80b37a:	c7 43 18 04 b4 80 00 	movl   $0x80b404,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80b381:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80b388:	00 
  80b389:	c7 44 24 04 b9 39 81 	movl   $0x8139b9,0x4(%esp)
  80b390:	00 
  80b391:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80b394:	89 04 24             	mov    %eax,(%esp)
  80b397:	e8 8f 47 00 00       	call   80fb2b <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80b39c:	8d 43 25             	lea    0x25(%ebx),%eax
  80b39f:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80b3a1:	8b 07                	mov    (%edi),%eax
  80b3a3:	89 46 04             	mov    %eax,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80b3a6:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80b3aa:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80b3b0:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  80b3b4:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80b3b8:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80b3bc:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80b3c0:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80b3c4:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80b3c8:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80b3cc:	c7 04 24 6c 0f 81 00 	movl   $0x810f6c,(%esp)
  80b3d3:	e8 8f cc ff ff       	call   808067 <inet_addr>
  80b3d8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80b3db:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b3e2:	00 
  80b3e3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b3e6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b3ea:	89 1c 24             	mov    %ebx,(%esp)
  80b3ed:	e8 a8 e9 ff ff       	call   809d9a <etharp_query>
  80b3f2:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80b3f7:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80b3fa:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80b3fd:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80b400:	89 ec                	mov    %ebp,%esp
  80b402:	5d                   	pop    %ebp
  80b403:	c3                   	ret    

0080b404 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80b404:	55                   	push   %ebp
  80b405:	89 e5                	mov    %esp,%ebp
  80b407:	57                   	push   %edi
  80b408:	56                   	push   %esi
  80b409:	53                   	push   %ebx
  80b40a:	83 ec 2c             	sub    $0x2c,%esp
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80b40d:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80b414:	00 
  80b415:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80b41c:	10 
  80b41d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b424:	e8 25 4c 00 00       	call   81004e <sys_page_alloc>
    if (r < 0)
  80b429:	85 c0                	test   %eax,%eax
  80b42b:	79 1c                	jns    80b449 <low_level_output+0x45>
	panic("jif: could not allocate page of memory");
  80b42d:	c7 44 24 08 14 2d 81 	movl   $0x812d14,0x8(%esp)
  80b434:	00 
  80b435:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80b43c:	00 
  80b43d:	c7 04 24 fd 2c 81 00 	movl   $0x812cfd,(%esp)
  80b444:	e8 a3 3d 00 00       	call   80f1ec <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80b449:	8b 45 08             	mov    0x8(%ebp),%eax
  80b44c:	8b 78 1c             	mov    0x1c(%eax),%edi
  80b44f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80b452:	be 00 00 00 00       	mov    $0x0,%esi

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b457:	eb 5a                	jmp    80b4b3 <low_level_output+0xaf>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80b459:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80b45d:	0f b7 d0             	movzwl %ax,%edx
  80b460:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
  80b463:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80b469:	7e 24                	jle    80b48f <low_level_output+0x8b>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80b46b:	89 74 24 10          	mov    %esi,0x10(%esp)
  80b46f:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80b473:	c7 44 24 08 3c 2d 81 	movl   $0x812d3c,0x8(%esp)
  80b47a:	00 
  80b47b:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  80b482:	00 
  80b483:	c7 04 24 fd 2c 81 00 	movl   $0x812cfd,(%esp)
  80b48a:	e8 5d 3d 00 00       	call   80f1ec <_panic>
	memcpy(&txbuf[txsize], q->payload, q->len);
  80b48f:	8d 96 04 00 00 10    	lea    0x10000004(%esi),%edx
  80b495:	0f b7 c0             	movzwl %ax,%eax
  80b498:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b49c:	8b 43 04             	mov    0x4(%ebx),%eax
  80b49f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b4a3:	89 14 24             	mov    %edx,(%esp)
  80b4a6:	e8 80 46 00 00       	call   80fb2b <memcpy>
	txsize += q->len;
  80b4ab:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80b4af:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b4b1:	8b 1b                	mov    (%ebx),%ebx
  80b4b3:	85 db                	test   %ebx,%ebx
  80b4b5:	75 a2                	jne    80b459 <low_level_output+0x55>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;	
  80b4b7:	89 35 00 00 00 10    	mov    %esi,0x10000000

	//envid_t to_env = ipc_find_env(ENV_TYPE_OUTPUTH);
	//ipc_send(to_env, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80b4bd:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80b4c4:	00 
  80b4c5:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
  80b4cc:	10 
  80b4cd:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  80b4d4:	00 
  80b4d5:	8b 47 04             	mov    0x4(%edi),%eax
  80b4d8:	89 04 24             	mov    %eax,(%esp)
  80b4db:	e8 82 50 00 00       	call   810562 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80b4e0:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80b4e7:	10 
  80b4e8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b4ef:	e8 9e 4a 00 00       	call   80ff92 <sys_page_unmap>

    return ERR_OK;
}
  80b4f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80b4f9:	83 c4 2c             	add    $0x2c,%esp
  80b4fc:	5b                   	pop    %ebx
  80b4fd:	5e                   	pop    %esi
  80b4fe:	5f                   	pop    %edi
  80b4ff:	5d                   	pop    %ebp
  80b500:	c3                   	ret    

0080b501 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80b501:	55                   	push   %ebp
  80b502:	89 e5                	mov    %esp,%ebp
  80b504:	83 ec 18             	sub    $0x18,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80b507:	8b 45 10             	mov    0x10(%ebp),%eax
  80b50a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b50e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b511:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b515:	8b 45 08             	mov    0x8(%ebp),%eax
  80b518:	89 04 24             	mov    %eax,(%esp)
  80b51b:	e8 90 ea ff ff       	call   809fb0 <etharp_output>
}
  80b520:	c9                   	leave  
  80b521:	c3                   	ret    

0080b522 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80b522:	55                   	push   %ebp
  80b523:	89 e5                	mov    %esp,%ebp
  80b525:	57                   	push   %edi
  80b526:	56                   	push   %esi
  80b527:	53                   	push   %ebx
  80b528:	83 ec 2c             	sub    $0x2c,%esp
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80b52b:	8b 45 08             	mov    0x8(%ebp),%eax
  80b52e:	8b 40 1c             	mov    0x1c(%eax),%eax
  80b531:	89 45 d8             	mov    %eax,-0x28(%ebp)
 *
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  80b534:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    s16_t len = pkt->jp_len;
  80b537:	0f b7 33             	movzwl (%ebx),%esi

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80b53a:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  80b541:	00 
  80b542:	0f b7 c6             	movzwl %si,%eax
  80b545:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b549:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80b550:	e8 8a 9f ff ff       	call   8054df <pbuf_alloc>
  80b555:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80b558:	85 c0                	test   %eax,%eax
  80b55a:	0f 84 c4 00 00 00    	je     80b624 <jif_input+0x102>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80b560:	83 c3 04             	add    $0x4,%ebx
  80b563:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80b566:	89 c3                	mov    %eax,%ebx
  80b568:	bf 00 00 00 00       	mov    $0x0,%edi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80b56d:	0f bf f6             	movswl %si,%esi
  80b570:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80b573:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80b577:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80b57a:	29 fe                	sub    %edi,%esi
  80b57c:	39 c6                	cmp    %eax,%esi
  80b57e:	0f 4f f0             	cmovg  %eax,%esi
	if (bytes > (len - copied))
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80b581:	89 74 24 08          	mov    %esi,0x8(%esp)
  80b585:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b588:	01 f8                	add    %edi,%eax
  80b58a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b58e:	8b 43 04             	mov    0x4(%ebx),%eax
  80b591:	89 04 24             	mov    %eax,(%esp)
  80b594:	e8 92 45 00 00       	call   80fb2b <memcpy>
	copied += bytes;
  80b599:	01 f7                	add    %esi,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b59b:	8b 1b                	mov    (%ebx),%ebx
  80b59d:	85 db                	test   %ebx,%ebx
  80b59f:	75 d2                	jne    80b573 <jif_input+0x51>
  80b5a1:	eb 61                	jmp    80b604 <jif_input+0xe2>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80b5a3:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80b5a6:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b5aa:	8b 45 08             	mov    0x8(%ebp),%eax
  80b5ad:	89 04 24             	mov    %eax,(%esp)
  80b5b0:	e8 22 ed ff ff       	call   80a2d7 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80b5b5:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80b5bc:	ff 
  80b5bd:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80b5c0:	89 14 24             	mov    %edx,(%esp)
  80b5c3:	e8 ff 98 ff ff       	call   804ec7 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80b5c8:	8b 45 08             	mov    0x8(%ebp),%eax
  80b5cb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b5cf:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80b5d2:	89 14 24             	mov    %edx,(%esp)
  80b5d5:	ff 50 10             	call   *0x10(%eax)
	break;
  80b5d8:	eb 4a                	jmp    80b624 <jif_input+0x102>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80b5da:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b5dd:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b5e1:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b5e4:	8b 02                	mov    (%edx),%eax
  80b5e6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b5ea:	8b 45 08             	mov    0x8(%ebp),%eax
  80b5ed:	89 04 24             	mov    %eax,(%esp)
  80b5f0:	e8 30 ed ff ff       	call   80a325 <etharp_arp_input>
	break;
  80b5f5:	eb 2d                	jmp    80b624 <jif_input+0x102>

    default:
	pbuf_free(p);
  80b5f7:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80b5fa:	89 14 24             	mov    %edx,(%esp)
  80b5fd:	e8 22 9c ff ff       	call   805224 <pbuf_free>
  80b602:	eb 20                	jmp    80b624 <jif_input+0x102>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80b604:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80b607:	8b 42 04             	mov    0x4(%edx),%eax
  80b60a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b60e:	89 04 24             	mov    %eax,(%esp)
  80b611:	e8 49 c8 ff ff       	call   807e5f <htons>
  80b616:	66 3d 00 08          	cmp    $0x800,%ax
  80b61a:	74 87                	je     80b5a3 <jif_input+0x81>
  80b61c:	66 3d 06 08          	cmp    $0x806,%ax
  80b620:	75 d5                	jne    80b5f7 <jif_input+0xd5>
  80b622:	eb b6                	jmp    80b5da <jif_input+0xb8>
	break;

    default:
	pbuf_free(p);
    }
}
  80b624:	83 c4 2c             	add    $0x2c,%esp
  80b627:	5b                   	pop    %ebx
  80b628:	5e                   	pop    %esi
  80b629:	5f                   	pop    %edi
  80b62a:	5d                   	pop    %ebp
  80b62b:	c3                   	ret    

0080b62c <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80b62c:	55                   	push   %ebp
  80b62d:	89 e5                	mov    %esp,%ebp
  80b62f:	83 ec 18             	sub    $0x18,%esp
  80b632:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80b635:	85 c0                	test   %eax,%eax
  80b637:	75 1c                	jne    80b655 <netconn_type+0x29>
  80b639:	c7 44 24 08 65 2d 81 	movl   $0x812d65,0x8(%esp)
  80b640:	00 
  80b641:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  80b648:	00 
  80b649:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b650:	e8 97 3b 00 00       	call   80f1ec <_panic>
  80b655:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80b657:	c9                   	leave  
  80b658:	c3                   	ret    

0080b659 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b659:	55                   	push   %ebp
  80b65a:	89 e5                	mov    %esp,%ebp
  80b65c:	53                   	push   %ebx
  80b65d:	83 ec 34             	sub    $0x34,%esp
  80b660:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b663:	85 db                	test   %ebx,%ebx
  80b665:	75 1c                	jne    80b683 <netconn_close+0x2a>
  80b667:	c7 44 24 08 97 2d 81 	movl   $0x812d97,0x8(%esp)
  80b66e:	00 
  80b66f:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
  80b676:	00 
  80b677:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b67e:	e8 69 3b 00 00       	call   80f1ec <_panic>

  msg.function = do_close;
  80b683:	c7 45 e4 68 c0 80 00 	movl   $0x80c068,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b68a:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b68d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b690:	89 04 24             	mov    %eax,(%esp)
  80b693:	e8 44 6f ff ff       	call   8025dc <tcpip_apimsg>
  80b698:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80b69c:	83 c4 34             	add    $0x34,%esp
  80b69f:	5b                   	pop    %ebx
  80b6a0:	5d                   	pop    %ebp
  80b6a1:	c3                   	ret    

0080b6a2 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b6a2:	55                   	push   %ebp
  80b6a3:	89 e5                	mov    %esp,%ebp
  80b6a5:	53                   	push   %ebx
  80b6a6:	83 ec 34             	sub    $0x34,%esp
  80b6a9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b6ac:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b6b0:	85 db                	test   %ebx,%ebx
  80b6b2:	75 1c                	jne    80b6d0 <netconn_write+0x2e>
  80b6b4:	c7 44 24 08 b3 2d 81 	movl   $0x812db3,0x8(%esp)
  80b6bb:	00 
  80b6bc:	c7 44 24 04 d3 01 00 	movl   $0x1d3,0x4(%esp)
  80b6c3:	00 
  80b6c4:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b6cb:	e8 1c 3b 00 00       	call   80f1ec <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b6d0:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b6d3:	74 1c                	je     80b6f1 <netconn_write+0x4f>
  80b6d5:	c7 44 24 08 00 2f 81 	movl   $0x812f00,0x8(%esp)
  80b6dc:	00 
  80b6dd:	c7 44 24 04 d4 01 00 	movl   $0x1d4,0x4(%esp)
  80b6e4:	00 
  80b6e5:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b6ec:	e8 fb 3a 00 00       	call   80f1ec <_panic>

  msg.function = do_write;
  80b6f1:	c7 45 e4 de c3 80 00 	movl   $0x80c3de,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b6f8:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b6fb:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b6fe:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b701:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b704:	8b 45 10             	mov    0x10(%ebp),%eax
  80b707:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b70a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b70d:	89 04 24             	mov    %eax,(%esp)
  80b710:	e8 c7 6e ff ff       	call   8025dc <tcpip_apimsg>
  80b715:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80b719:	83 c4 34             	add    $0x34,%esp
  80b71c:	5b                   	pop    %ebx
  80b71d:	5d                   	pop    %ebp
  80b71e:	c3                   	ret    

0080b71f <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b71f:	55                   	push   %ebp
  80b720:	89 e5                	mov    %esp,%ebp
  80b722:	53                   	push   %ebx
  80b723:	83 ec 34             	sub    $0x34,%esp
  80b726:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b729:	85 db                	test   %ebx,%ebx
  80b72b:	75 1c                	jne    80b749 <netconn_send+0x2a>
  80b72d:	c7 44 24 08 cf 2d 81 	movl   $0x812dcf,0x8(%esp)
  80b734:	00 
  80b735:	c7 44 24 04 b9 01 00 	movl   $0x1b9,0x4(%esp)
  80b73c:	00 
  80b73d:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b744:	e8 a3 3a 00 00       	call   80f1ec <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b749:	c7 45 e4 6c c4 80 00 	movl   $0x80c46c,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b750:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b753:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b756:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b759:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b75c:	89 04 24             	mov    %eax,(%esp)
  80b75f:	e8 78 6e ff ff       	call   8025dc <tcpip_apimsg>
  80b764:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80b768:	83 c4 34             	add    $0x34,%esp
  80b76b:	5b                   	pop    %ebx
  80b76c:	5d                   	pop    %ebp
  80b76d:	c3                   	ret    

0080b76e <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80b76e:	55                   	push   %ebp
  80b76f:	89 e5                	mov    %esp,%ebp
  80b771:	83 ec 18             	sub    $0x18,%esp
  80b774:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b777:	0f b7 4d 14          	movzwl 0x14(%ebp),%ecx
  if (buf != NULL) {
  80b77b:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b780:	85 d2                	test   %edx,%edx
  80b782:	74 19                	je     80b79d <netconn_sendto+0x2f>
    buf->addr = addr;
  80b784:	8b 45 10             	mov    0x10(%ebp),%eax
  80b787:	89 42 08             	mov    %eax,0x8(%edx)
    buf->port = port;
  80b78a:	66 89 4a 0c          	mov    %cx,0xc(%edx)
    return netconn_send(conn, buf);
  80b78e:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b792:	8b 45 08             	mov    0x8(%ebp),%eax
  80b795:	89 04 24             	mov    %eax,(%esp)
  80b798:	e8 82 ff ff ff       	call   80b71f <netconn_send>
  }
  return ERR_VAL;
}
  80b79d:	c9                   	leave  
  80b79e:	c3                   	ret    

0080b79f <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80b79f:	55                   	push   %ebp
  80b7a0:	89 e5                	mov    %esp,%ebp
  80b7a2:	53                   	push   %ebx
  80b7a3:	83 ec 34             	sub    $0x34,%esp
  80b7a6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b7a9:	85 db                	test   %ebx,%ebx
  80b7ab:	75 1c                	jne    80b7c9 <netconn_listen_with_backlog+0x2a>
  80b7ad:	c7 44 24 08 ea 2d 81 	movl   $0x812dea,0x8(%esp)
  80b7b4:	00 
  80b7b5:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80b7bc:	00 
  80b7bd:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b7c4:	e8 23 3a 00 00       	call   80f1ec <_panic>

  msg.function = do_listen;
  80b7c9:	c7 45 e4 2f c5 80 00 	movl   $0x80c52f,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b7d0:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80b7d3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b7d6:	89 04 24             	mov    %eax,(%esp)
  80b7d9:	e8 fe 6d ff ff       	call   8025dc <tcpip_apimsg>
  80b7de:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80b7e2:	83 c4 34             	add    $0x34,%esp
  80b7e5:	5b                   	pop    %ebx
  80b7e6:	5d                   	pop    %ebp
  80b7e7:	c3                   	ret    

0080b7e8 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80b7e8:	55                   	push   %ebp
  80b7e9:	89 e5                	mov    %esp,%ebp
  80b7eb:	53                   	push   %ebx
  80b7ec:	83 ec 34             	sub    $0x34,%esp
  80b7ef:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b7f2:	85 db                	test   %ebx,%ebx
  80b7f4:	75 1c                	jne    80b812 <netconn_disconnect+0x2a>
  80b7f6:	c7 44 24 08 24 2f 81 	movl   $0x812f24,0x8(%esp)
  80b7fd:	00 
  80b7fe:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
  80b805:	00 
  80b806:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b80d:	e8 da 39 00 00       	call   80f1ec <_panic>

  msg.function = do_disconnect;
  80b812:	c7 45 e4 f9 c6 80 00 	movl   $0x80c6f9,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b819:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80b81c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b81f:	89 04 24             	mov    %eax,(%esp)
  80b822:	e8 b5 6d ff ff       	call   8025dc <tcpip_apimsg>
  80b827:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80b82b:	83 c4 34             	add    $0x34,%esp
  80b82e:	5b                   	pop    %ebx
  80b82f:	5d                   	pop    %ebp
  80b830:	c3                   	ret    

0080b831 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b831:	55                   	push   %ebp
  80b832:	89 e5                	mov    %esp,%ebp
  80b834:	53                   	push   %ebx
  80b835:	83 ec 34             	sub    $0x34,%esp
  80b838:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b83b:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b83f:	85 db                	test   %ebx,%ebx
  80b841:	75 1c                	jne    80b85f <netconn_connect+0x2e>
  80b843:	c7 44 24 08 07 2e 81 	movl   $0x812e07,0x8(%esp)
  80b84a:	00 
  80b84b:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
  80b852:	00 
  80b853:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b85a:	e8 8d 39 00 00       	call   80f1ec <_panic>

  msg.function = do_connect;
  80b85f:	c7 45 e4 30 c7 80 00 	movl   $0x80c730,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b866:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b869:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b86c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b86f:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80b873:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b876:	89 04 24             	mov    %eax,(%esp)
  80b879:	e8 5e 6d ff ff       	call   8025dc <tcpip_apimsg>
  80b87e:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80b882:	83 c4 34             	add    $0x34,%esp
  80b885:	5b                   	pop    %ebx
  80b886:	5d                   	pop    %ebp
  80b887:	c3                   	ret    

0080b888 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b888:	55                   	push   %ebp
  80b889:	89 e5                	mov    %esp,%ebp
  80b88b:	53                   	push   %ebx
  80b88c:	83 ec 34             	sub    $0x34,%esp
  80b88f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b892:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80b896:	85 db                	test   %ebx,%ebx
  80b898:	75 1c                	jne    80b8b6 <netconn_bind+0x2e>
  80b89a:	c7 44 24 08 25 2e 81 	movl   $0x812e25,0x8(%esp)
  80b8a1:	00 
  80b8a2:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80b8a9:	00 
  80b8aa:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b8b1:	e8 36 39 00 00       	call   80f1ec <_panic>

  msg.function = do_bind;
  80b8b6:	c7 45 e4 f8 c7 80 00 	movl   $0x80c7f8,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b8bd:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b8c0:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b8c3:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b8c6:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80b8ca:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b8cd:	89 04 24             	mov    %eax,(%esp)
  80b8d0:	e8 07 6d ff ff       	call   8025dc <tcpip_apimsg>
  80b8d5:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80b8d9:	83 c4 34             	add    $0x34,%esp
  80b8dc:	5b                   	pop    %ebx
  80b8dd:	5d                   	pop    %ebp
  80b8de:	c3                   	ret    

0080b8df <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80b8df:	55                   	push   %ebp
  80b8e0:	89 e5                	mov    %esp,%ebp
  80b8e2:	53                   	push   %ebx
  80b8e3:	83 ec 34             	sub    $0x34,%esp
  80b8e6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b8e9:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b8ec:	8b 45 10             	mov    0x10(%ebp),%eax
  80b8ef:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80b8f3:	85 db                	test   %ebx,%ebx
  80b8f5:	75 1c                	jne    80b913 <netconn_getaddr+0x34>
  80b8f7:	c7 44 24 08 40 2e 81 	movl   $0x812e40,0x8(%esp)
  80b8fe:	00 
  80b8ff:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80b906:	00 
  80b907:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b90e:	e8 d9 38 00 00       	call   80f1ec <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80b913:	85 d2                	test   %edx,%edx
  80b915:	75 1c                	jne    80b933 <netconn_getaddr+0x54>
  80b917:	c7 44 24 08 5e 2e 81 	movl   $0x812e5e,0x8(%esp)
  80b91e:	00 
  80b91f:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80b926:	00 
  80b927:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b92e:	e8 b9 38 00 00       	call   80f1ec <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80b933:	85 c0                	test   %eax,%eax
  80b935:	75 1c                	jne    80b953 <netconn_getaddr+0x74>
  80b937:	c7 44 24 08 7c 2e 81 	movl   $0x812e7c,0x8(%esp)
  80b93e:	00 
  80b93f:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  80b946:	00 
  80b947:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b94e:	e8 99 38 00 00       	call   80f1ec <_panic>

  msg.function = do_getaddr;
  80b953:	c7 45 e4 00 bd 80 00 	movl   $0x80bd00,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b95a:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80b95d:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80b960:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80b963:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80b966:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b969:	89 04 24             	mov    %eax,(%esp)
  80b96c:	e8 6b 6c ff ff       	call   8025dc <tcpip_apimsg>
  80b971:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax

  return conn->err;
}
  80b975:	83 c4 34             	add    $0x34,%esp
  80b978:	5b                   	pop    %ebx
  80b979:	5d                   	pop    %ebp
  80b97a:	c3                   	ret    

0080b97b <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80b97b:	55                   	push   %ebp
  80b97c:	89 e5                	mov    %esp,%ebp
  80b97e:	53                   	push   %ebx
  80b97f:	83 ec 24             	sub    $0x24,%esp
  80b982:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b985:	85 db                	test   %ebx,%ebx
  80b987:	75 1c                	jne    80b9a5 <netconn_accept+0x2a>
  80b989:	c7 44 24 08 9a 2e 81 	movl   $0x812e9a,0x8(%esp)
  80b990:	00 
  80b991:	c7 44 24 04 10 01 00 	movl   $0x110,0x4(%esp)
  80b998:	00 
  80b999:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b9a0:	e8 47 38 00 00       	call   80f1ec <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b9a5:	8b 43 18             	mov    0x18(%ebx),%eax
  80b9a8:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b9ab:	75 1c                	jne    80b9c9 <netconn_accept+0x4e>
  80b9ad:	c7 44 24 08 48 2f 81 	movl   $0x812f48,0x8(%esp)
  80b9b4:	00 
  80b9b5:	c7 44 24 04 11 01 00 	movl   $0x111,0x4(%esp)
  80b9bc:	00 
  80b9bd:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80b9c4:	e8 23 38 00 00       	call   80f1ec <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80b9c9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b9d0:	00 
  80b9d1:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80b9d4:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b9d8:	89 04 24             	mov    %eax,(%esp)
  80b9db:	e8 08 f3 ff ff       	call   80ace8 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80b9e0:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b9e3:	85 c0                	test   %eax,%eax
  80b9e5:	74 15                	je     80b9fc <netconn_accept+0x81>
  80b9e7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b9ee:	00 
  80b9ef:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80b9f6:	00 
  80b9f7:	89 1c 24             	mov    %ebx,(%esp)
  80b9fa:	ff d0                	call   *%eax
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80b9fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80b9ff:	83 c4 24             	add    $0x24,%esp
  80ba02:	5b                   	pop    %ebx
  80ba03:	5d                   	pop    %ebp
  80ba04:	c3                   	ret    

0080ba05 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80ba05:	55                   	push   %ebp
  80ba06:	89 e5                	mov    %esp,%ebp
  80ba08:	53                   	push   %ebx
  80ba09:	83 ec 34             	sub    $0x34,%esp
  80ba0c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80ba0f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80ba16:	85 db                	test   %ebx,%ebx
  80ba18:	75 1c                	jne    80ba36 <netconn_recv+0x31>
  80ba1a:	c7 44 24 08 b7 2e 81 	movl   $0x812eb7,0x8(%esp)
  80ba21:	00 
  80ba22:	c7 44 24 04 3a 01 00 	movl   $0x13a,0x4(%esp)
  80ba29:	00 
  80ba2a:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80ba31:	e8 b6 37 00 00       	call   80f1ec <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80ba36:	8b 43 14             	mov    0x14(%ebx),%eax
  80ba39:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ba3c:	75 0e                	jne    80ba4c <netconn_recv+0x47>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80ba3e:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80ba42:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  80ba47:	e9 62 01 00 00       	jmp    80bbae <netconn_recv+0x1a9>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80ba4c:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80ba50:	0f 8c 53 01 00 00    	jl     80bba9 <netconn_recv+0x1a4>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80ba56:	83 3b 10             	cmpl   $0x10,(%ebx)
  80ba59:	0f 85 fc 00 00 00    	jne    80bb5b <netconn_recv+0x156>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80ba5f:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80ba63:	75 0e                	jne    80ba73 <netconn_recv+0x6e>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80ba65:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80ba69:	b8 00 00 00 00       	mov    $0x0,%eax
      return NULL;
  80ba6e:	e9 3b 01 00 00       	jmp    80bbae <netconn_recv+0x1a9>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80ba73:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80ba7a:	e8 89 90 ff ff       	call   804b08 <memp_malloc>
  80ba7f:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80ba82:	85 c0                	test   %eax,%eax
  80ba84:	75 09                	jne    80ba8f <netconn_recv+0x8a>
      conn->err = ERR_MEM;
  80ba86:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80ba8a:	e9 1f 01 00 00       	jmp    80bbae <netconn_recv+0x1a9>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80ba8f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ba96:	00 
  80ba97:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80ba9a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ba9e:	8b 43 14             	mov    0x14(%ebx),%eax
  80baa1:	89 04 24             	mov    %eax,(%esp)
  80baa4:	e8 3f f2 ff ff       	call   80ace8 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80baa9:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80baac:	b8 00 00 00 00       	mov    $0x0,%eax
  80bab1:	85 d2                	test   %edx,%edx
  80bab3:	74 08                	je     80babd <netconn_recv+0xb8>
      len = p->tot_len;
  80bab5:	0f b7 42 08          	movzwl 0x8(%edx),%eax
      SYS_ARCH_DEC(conn->recv_avail, len);
  80bab9:	66 29 43 20          	sub    %ax,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80babd:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80bac0:	85 d2                	test   %edx,%edx
  80bac2:	74 14                	je     80bad8 <netconn_recv+0xd3>
  80bac4:	0f b7 c0             	movzwl %ax,%eax
  80bac7:	89 44 24 08          	mov    %eax,0x8(%esp)
  80bacb:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80bad2:	00 
  80bad3:	89 1c 24             	mov    %ebx,(%esp)
  80bad6:	ff d2                	call   *%edx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80bad8:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80badb:	85 c0                	test   %eax,%eax
  80badd:	75 2b                	jne    80bb0a <netconn_recv+0x105>
      memp_free(MEMP_NETBUF, buf);
  80badf:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80bae2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bae6:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80baed:	e8 d2 8f ff ff       	call   804ac4 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80baf2:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80baf6:	0f 85 ad 00 00 00    	jne    80bba9 <netconn_recv+0x1a4>
        conn->err = ERR_CLSD;
  80bafc:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80bb00:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb05:	e9 a4 00 00 00       	jmp    80bbae <netconn_recv+0x1a9>
      }
      return NULL;
    }

    buf->p = p;
  80bb0a:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80bb0d:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80bb0f:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80bb12:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80bb15:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80bb18:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80bb1b:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80bb21:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80bb24:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80bb2b:	c7 45 e4 2b c4 80 00 	movl   $0x80c42b,-0x1c(%ebp)
    msg.msg.conn = conn;
  80bb32:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80bb35:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80bb38:	85 c0                	test   %eax,%eax
  80bb3a:	74 0c                	je     80bb48 <netconn_recv+0x143>
      msg.msg.msg.r.len = buf->p->tot_len;
  80bb3c:	8b 00                	mov    (%eax),%eax
  80bb3e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80bb42:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80bb46:	eb 06                	jmp    80bb4e <netconn_recv+0x149>
    } else {
      msg.msg.msg.r.len = 1;
  80bb48:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80bb4e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80bb51:	89 04 24             	mov    %eax,(%esp)
  80bb54:	e8 83 6a ff ff       	call   8025dc <tcpip_apimsg>
  80bb59:	eb 49                	jmp    80bba4 <netconn_recv+0x19f>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80bb5b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bb62:	00 
  80bb63:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80bb66:	89 54 24 04          	mov    %edx,0x4(%esp)
  80bb6a:	89 04 24             	mov    %eax,(%esp)
  80bb6d:	e8 76 f1 ff ff       	call   80ace8 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80bb72:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80bb75:	85 c0                	test   %eax,%eax
  80bb77:	74 2b                	je     80bba4 <netconn_recv+0x19f>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80bb79:	8b 00                	mov    (%eax),%eax
  80bb7b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80bb7f:	66 29 43 20          	sub    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80bb83:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bb86:	85 c0                	test   %eax,%eax
  80bb88:	74 1a                	je     80bba4 <netconn_recv+0x19f>
  80bb8a:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80bb8d:	8b 12                	mov    (%edx),%edx
  80bb8f:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80bb93:	89 54 24 08          	mov    %edx,0x8(%esp)
  80bb97:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80bb9e:	00 
  80bb9f:	89 1c 24             	mov    %ebx,(%esp)
  80bba2:	ff d0                	call   *%eax
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80bba4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80bba7:	eb 05                	jmp    80bbae <netconn_recv+0x1a9>
  80bba9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80bbae:	83 c4 34             	add    $0x34,%esp
  80bbb1:	5b                   	pop    %ebx
  80bbb2:	5d                   	pop    %ebp
  80bbb3:	c3                   	ret    

0080bbb4 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80bbb4:	55                   	push   %ebp
  80bbb5:	89 e5                	mov    %esp,%ebp
  80bbb7:	53                   	push   %ebx
  80bbb8:	83 ec 34             	sub    $0x34,%esp
  80bbbb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80bbbe:	85 db                	test   %ebx,%ebx
  80bbc0:	74 24                	je     80bbe6 <netconn_delete+0x32>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80bbc2:	c7 45 e4 99 c8 80 00 	movl   $0x80c899,-0x1c(%ebp)
  msg.msg.conn = conn;
  80bbc9:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80bbcc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80bbcf:	89 04 24             	mov    %eax,(%esp)
  80bbd2:	e8 05 6a ff ff       	call   8025dc <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80bbd7:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80bbde:	89 1c 24             	mov    %ebx,(%esp)
  80bbe1:	e8 66 0d 00 00       	call   80c94c <netconn_free>

  return ERR_OK;
}
  80bbe6:	b8 00 00 00 00       	mov    $0x0,%eax
  80bbeb:	83 c4 34             	add    $0x34,%esp
  80bbee:	5b                   	pop    %ebx
  80bbef:	5d                   	pop    %ebp
  80bbf0:	c3                   	ret    

0080bbf1 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80bbf1:	55                   	push   %ebp
  80bbf2:	89 e5                	mov    %esp,%ebp
  80bbf4:	56                   	push   %esi
  80bbf5:	53                   	push   %ebx
  80bbf6:	83 ec 30             	sub    $0x30,%esp
  80bbf9:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80bbfd:	8b 45 10             	mov    0x10(%ebp),%eax
  80bc00:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bc04:	8b 45 08             	mov    0x8(%ebp),%eax
  80bc07:	89 04 24             	mov    %eax,(%esp)
  80bc0a:	e8 33 0f 00 00       	call   80cb42 <netconn_alloc>
  80bc0f:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80bc11:	85 c0                	test   %eax,%eax
  80bc13:	0f 84 d6 00 00 00    	je     80bcef <netconn_new_with_proto_and_callback+0xfe>
    msg.function = do_newconn;
  80bc19:	c7 45 e4 af cc 80 00 	movl   $0x80ccaf,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80bc20:	89 f0                	mov    %esi,%eax
  80bc22:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80bc25:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80bc28:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80bc2b:	89 04 24             	mov    %eax,(%esp)
  80bc2e:	e8 a9 69 ff ff       	call   8025dc <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80bc33:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80bc37:	0f 84 b2 00 00 00    	je     80bcef <netconn_new_with_proto_and_callback+0xfe>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80bc3d:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bc41:	74 1c                	je     80bc5f <netconn_new_with_proto_and_callback+0x6e>
  80bc43:	c7 44 24 08 6c 2f 81 	movl   $0x812f6c,0x8(%esp)
  80bc4a:	00 
  80bc4b:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80bc52:	00 
  80bc53:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80bc5a:	e8 8d 35 00 00       	call   80f1ec <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80bc5f:	8b 43 10             	mov    0x10(%ebx),%eax
  80bc62:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bc65:	75 1c                	jne    80bc83 <netconn_new_with_proto_and_callback+0x92>
  80bc67:	c7 44 24 08 d2 2e 81 	movl   $0x812ed2,0x8(%esp)
  80bc6e:	00 
  80bc6f:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  80bc76:	00 
  80bc77:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80bc7e:	e8 69 35 00 00       	call   80f1ec <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80bc83:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bc87:	75 1c                	jne    80bca5 <netconn_new_with_proto_and_callback+0xb4>
  80bc89:	c7 44 24 08 eb 2e 81 	movl   $0x812eeb,0x8(%esp)
  80bc90:	00 
  80bc91:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80bc98:	00 
  80bc99:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80bca0:	e8 47 35 00 00       	call   80f1ec <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80bca5:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bca9:	74 1c                	je     80bcc7 <netconn_new_with_proto_and_callback+0xd6>
  80bcab:	c7 44 24 08 90 2f 81 	movl   $0x812f90,0x8(%esp)
  80bcb2:	00 
  80bcb3:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80bcba:	00 
  80bcbb:	c7 04 24 80 2d 81 00 	movl   $0x812d80,(%esp)
  80bcc2:	e8 25 35 00 00       	call   80f1ec <_panic>
      sys_sem_free(conn->op_completed);
  80bcc7:	89 04 24             	mov    %eax,(%esp)
  80bcca:	e8 9a e9 ff ff       	call   80a669 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80bccf:	8b 43 14             	mov    0x14(%ebx),%eax
  80bcd2:	89 04 24             	mov    %eax,(%esp)
  80bcd5:	e8 11 ea ff ff       	call   80a6eb <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80bcda:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80bcde:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80bce5:	e8 da 8d ff ff       	call   804ac4 <memp_free>
  80bcea:	bb 00 00 00 00       	mov    $0x0,%ebx
      return NULL;
    }
  }
  return conn;
}
  80bcef:	89 d8                	mov    %ebx,%eax
  80bcf1:	83 c4 30             	add    $0x30,%esp
  80bcf4:	5b                   	pop    %ebx
  80bcf5:	5e                   	pop    %esi
  80bcf6:	5d                   	pop    %ebp
  80bcf7:	c3                   	ret    
	...

0080bd00 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80bd00:	55                   	push   %ebp
  80bd01:	89 e5                	mov    %esp,%ebp
  80bd03:	83 ec 18             	sub    $0x18,%esp
  80bd06:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80bd09:	8b 08                	mov    (%eax),%ecx
  80bd0b:	8b 51 08             	mov    0x8(%ecx),%edx
  80bd0e:	85 d2                	test   %edx,%edx
  80bd10:	0f 84 98 00 00 00    	je     80bdae <do_getaddr+0xae>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80bd16:	8b 48 04             	mov    0x4(%eax),%ecx
  80bd19:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80bd1d:	74 06                	je     80bd25 <do_getaddr+0x25>
  80bd1f:	8b 12                	mov    (%edx),%edx
  80bd21:	89 11                	mov    %edx,(%ecx)
  80bd23:	eb 05                	jmp    80bd2a <do_getaddr+0x2a>
  80bd25:	8b 52 04             	mov    0x4(%edx),%edx
  80bd28:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bd2a:	8b 08                	mov    (%eax),%ecx
  80bd2c:	8b 11                	mov    (%ecx),%edx
  80bd2e:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80bd34:	83 fa 20             	cmp    $0x20,%edx
  80bd37:	74 27                	je     80bd60 <do_getaddr+0x60>
  80bd39:	83 fa 40             	cmp    $0x40,%edx
  80bd3c:	74 07                	je     80bd45 <do_getaddr+0x45>
  80bd3e:	83 fa 10             	cmp    $0x10,%edx
  80bd41:	75 6f                	jne    80bdb2 <do_getaddr+0xb2>
  80bd43:	eb 4b                	jmp    80bd90 <do_getaddr+0x90>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80bd45:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80bd49:	74 0f                	je     80bd5a <do_getaddr+0x5a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80bd4b:	8b 50 08             	mov    0x8(%eax),%edx
  80bd4e:	8b 49 08             	mov    0x8(%ecx),%ecx
  80bd51:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80bd55:	66 89 0a             	mov    %cx,(%edx)
  80bd58:	eb 58                	jmp    80bdb2 <do_getaddr+0xb2>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80bd5a:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80bd5e:	eb 52                	jmp    80bdb2 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80bd60:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80bd64:	74 0f                	je     80bd75 <do_getaddr+0x75>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80bd66:	8b 50 08             	mov    0x8(%eax),%edx
  80bd69:	8b 49 08             	mov    0x8(%ecx),%ecx
  80bd6c:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80bd70:	66 89 0a             	mov    %cx,(%edx)
  80bd73:	eb 3d                	jmp    80bdb2 <do_getaddr+0xb2>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80bd75:	8b 51 08             	mov    0x8(%ecx),%edx
  80bd78:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80bd7c:	75 06                	jne    80bd84 <do_getaddr+0x84>
          msg->conn->err = ERR_CONN;
  80bd7e:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80bd82:	eb 2e                	jmp    80bdb2 <do_getaddr+0xb2>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80bd84:	8b 48 08             	mov    0x8(%eax),%ecx
  80bd87:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80bd8b:	66 89 11             	mov    %dx,(%ecx)
  80bd8e:	eb 22                	jmp    80bdb2 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80bd90:	8b 50 08             	mov    0x8(%eax),%edx
  80bd93:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80bd97:	74 09                	je     80bda2 <do_getaddr+0xa2>
  80bd99:	8b 49 08             	mov    0x8(%ecx),%ecx
  80bd9c:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80bda0:	eb 07                	jmp    80bda9 <do_getaddr+0xa9>
  80bda2:	8b 49 08             	mov    0x8(%ecx),%ecx
  80bda5:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80bda9:	66 89 0a             	mov    %cx,(%edx)
  80bdac:	eb 04                	jmp    80bdb2 <do_getaddr+0xb2>
      break;
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80bdae:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80bdb2:	8b 00                	mov    (%eax),%eax
  80bdb4:	8b 40 10             	mov    0x10(%eax),%eax
  80bdb7:	89 04 24             	mov    %eax,(%esp)
  80bdba:	e8 b2 ee ff ff       	call   80ac71 <sys_sem_signal>
}
  80bdbf:	c9                   	leave  
  80bdc0:	c3                   	ret    

0080bdc1 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80bdc1:	55                   	push   %ebp
  80bdc2:	89 e5                	mov    %esp,%ebp
  80bdc4:	53                   	push   %ebx
  80bdc5:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80bdc8:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80bdcb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bdcf:	89 1c 24             	mov    %ebx,(%esp)
  80bdd2:	e8 4a 9d ff ff       	call   805b21 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80bdd7:	c7 44 24 04 20 c6 80 	movl   $0x80c620,0x4(%esp)
  80bdde:	00 
  80bddf:	89 1c 24             	mov    %ebx,(%esp)
  80bde2:	e8 48 9d ff ff       	call   805b2f <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80bde7:	c7 44 24 04 30 c3 80 	movl   $0x80c330,0x4(%esp)
  80bdee:	00 
  80bdef:	89 1c 24             	mov    %ebx,(%esp)
  80bdf2:	e8 49 9d ff ff       	call   805b40 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80bdf7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80bdfe:	00 
  80bdff:	c7 44 24 04 e7 c2 80 	movl   $0x80c2e7,0x4(%esp)
  80be06:	00 
  80be07:	89 1c 24             	mov    %ebx,(%esp)
  80be0a:	e8 61 9d ff ff       	call   805b70 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80be0f:	c7 44 24 04 a1 c0 80 	movl   $0x80c0a1,0x4(%esp)
  80be16:	00 
  80be17:	89 1c 24             	mov    %ebx,(%esp)
  80be1a:	e8 32 9d ff ff       	call   805b51 <tcp_err>
}
  80be1f:	83 c4 14             	add    $0x14,%esp
  80be22:	5b                   	pop    %ebx
  80be23:	5d                   	pop    %ebp
  80be24:	c3                   	ret    

0080be25 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80be25:	55                   	push   %ebp
  80be26:	89 e5                	mov    %esp,%ebp
  80be28:	53                   	push   %ebx
  80be29:	83 ec 14             	sub    $0x14,%esp
  80be2c:	0f b6 55 10          	movzbl 0x10(%ebp),%edx
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  80be30:	8b 5d 08             	mov    0x8(%ebp),%ebx

  if (conn == NULL) {
  80be33:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80be38:	85 db                	test   %ebx,%ebx
  80be3a:	74 2a                	je     80be66 <do_connected+0x41>
    return ERR_VAL;
  }

  conn->err = err;
  80be3c:	88 53 0c             	mov    %dl,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80be3f:	83 3b 10             	cmpl   $0x10,(%ebx)
  80be42:	75 0b                	jne    80be4f <do_connected+0x2a>
  80be44:	84 d2                	test   %dl,%dl
  80be46:	75 07                	jne    80be4f <do_connected+0x2a>
    setup_tcp(conn);
  80be48:	89 d8                	mov    %ebx,%eax
  80be4a:	e8 72 ff ff ff       	call   80bdc1 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80be4f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80be56:	8b 43 10             	mov    0x10(%ebx),%eax
  80be59:	89 04 24             	mov    %eax,(%esp)
  80be5c:	e8 10 ee ff ff       	call   80ac71 <sys_sem_signal>
  80be61:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  80be66:	83 c4 14             	add    $0x14,%esp
  80be69:	5b                   	pop    %ebx
  80be6a:	5d                   	pop    %ebp
  80be6b:	c3                   	ret    

0080be6c <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80be6c:	55                   	push   %ebp
  80be6d:	89 e5                	mov    %esp,%ebp
  80be6f:	53                   	push   %ebx
  80be70:	83 ec 14             	sub    $0x14,%esp
  80be73:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80be75:	85 c0                	test   %eax,%eax
  80be77:	75 1c                	jne    80be95 <do_close_internal+0x29>
  80be79:	c7 44 24 08 dd 2d 81 	movl   $0x812ddd,0x8(%esp)
  80be80:	00 
  80be81:	c7 44 24 04 53 02 00 	movl   $0x253,0x4(%esp)
  80be88:	00 
  80be89:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80be90:	e8 57 33 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80be95:	83 38 10             	cmpl   $0x10,(%eax)
  80be98:	74 1c                	je     80beb6 <do_close_internal+0x4a>
  80be9a:	c7 44 24 08 c8 2f 81 	movl   $0x812fc8,0x8(%esp)
  80bea1:	00 
  80bea2:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
  80bea9:	00 
  80beaa:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80beb1:	e8 36 33 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80beb6:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80beba:	74 1c                	je     80bed8 <do_close_internal+0x6c>
  80bebc:	c7 44 24 08 94 30 81 	movl   $0x813094,0x8(%esp)
  80bec3:	00 
  80bec4:	c7 44 24 04 55 02 00 	movl   $0x255,0x4(%esp)
  80becb:	00 
  80becc:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80bed3:	e8 14 33 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80bed8:	8b 40 08             	mov    0x8(%eax),%eax
  80bedb:	85 c0                	test   %eax,%eax
  80bedd:	75 1c                	jne    80befb <do_close_internal+0x8f>
  80bedf:	c7 44 24 08 e6 2f 81 	movl   $0x812fe6,0x8(%esp)
  80bee6:	00 
  80bee7:	c7 44 24 04 56 02 00 	movl   $0x256,0x4(%esp)
  80beee:	00 
  80beef:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80bef6:	e8 f1 32 00 00       	call   80f1ec <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80befb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bf02:	00 
  80bf03:	89 04 24             	mov    %eax,(%esp)
  80bf06:	e8 16 9c ff ff       	call   805b21 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80bf0b:	8b 43 08             	mov    0x8(%ebx),%eax
  80bf0e:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80bf12:	75 12                	jne    80bf26 <do_close_internal+0xba>
    tcp_accept(conn->pcb.tcp, NULL);
  80bf14:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bf1b:	00 
  80bf1c:	89 04 24             	mov    %eax,(%esp)
  80bf1f:	e8 3e 9c ff ff       	call   805b62 <tcp_accept>
  80bf24:	eb 64                	jmp    80bf8a <do_close_internal+0x11e>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80bf26:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bf2d:	00 
  80bf2e:	89 04 24             	mov    %eax,(%esp)
  80bf31:	e8 f9 9b ff ff       	call   805b2f <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80bf36:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bf3d:	00 
  80bf3e:	8b 43 08             	mov    0x8(%ebx),%eax
  80bf41:	89 04 24             	mov    %eax,(%esp)
  80bf44:	e8 19 9c ff ff       	call   805b62 <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80bf49:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bf50:	00 
  80bf51:	8b 43 08             	mov    0x8(%ebx),%eax
  80bf54:	89 04 24             	mov    %eax,(%esp)
  80bf57:	e8 e4 9b ff ff       	call   805b40 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80bf5c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80bf63:	00 
  80bf64:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bf6b:	00 
  80bf6c:	8b 43 08             	mov    0x8(%ebx),%eax
  80bf6f:	89 04 24             	mov    %eax,(%esp)
  80bf72:	e8 f9 9b ff ff       	call   805b70 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80bf77:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bf7e:	00 
  80bf7f:	8b 43 08             	mov    0x8(%ebx),%eax
  80bf82:	89 04 24             	mov    %eax,(%esp)
  80bf85:	e8 c7 9b ff ff       	call   805b51 <tcp_err>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80bf8a:	8b 43 08             	mov    0x8(%ebx),%eax
  80bf8d:	89 04 24             	mov    %eax,(%esp)
  80bf90:	e8 2f aa ff ff       	call   8069c4 <tcp_close>
  if (err == ERR_OK) {
  80bf95:	84 c0                	test   %al,%al
  80bf97:	75 57                	jne    80bff0 <do_close_internal+0x184>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80bf99:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80bfa0:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80bfa7:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bfab:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bfae:	85 c0                	test   %eax,%eax
  80bfb0:	74 31                	je     80bfe3 <do_close_internal+0x177>
  80bfb2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bfb9:	00 
  80bfba:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bfc1:	00 
  80bfc2:	89 1c 24             	mov    %ebx,(%esp)
  80bfc5:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80bfc7:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bfca:	85 c0                	test   %eax,%eax
  80bfcc:	74 15                	je     80bfe3 <do_close_internal+0x177>
  80bfce:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bfd5:	00 
  80bfd6:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80bfdd:	00 
  80bfde:	89 1c 24             	mov    %ebx,(%esp)
  80bfe1:	ff d0                	call   *%eax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80bfe3:	8b 43 10             	mov    0x10(%ebx),%eax
  80bfe6:	89 04 24             	mov    %eax,(%esp)
  80bfe9:	e8 83 ec ff ff       	call   80ac71 <sys_sem_signal>
  80bfee:	eb 72                	jmp    80c062 <do_close_internal+0x1f6>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80bff0:	8b 43 08             	mov    0x8(%ebx),%eax
  80bff3:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80bff7:	75 1c                	jne    80c015 <do_close_internal+0x1a9>
  80bff9:	c7 44 24 08 b8 30 81 	movl   $0x8130b8,0x8(%esp)
  80c000:	00 
  80c001:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80c008:	00 
  80c009:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80c010:	e8 d7 31 00 00       	call   80f1ec <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80c015:	c7 44 24 04 30 c3 80 	movl   $0x80c330,0x4(%esp)
  80c01c:	00 
  80c01d:	89 04 24             	mov    %eax,(%esp)
  80c020:	e8 1b 9b ff ff       	call   805b40 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80c025:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80c02c:	00 
  80c02d:	c7 44 24 04 e7 c2 80 	movl   $0x80c2e7,0x4(%esp)
  80c034:	00 
  80c035:	8b 43 08             	mov    0x8(%ebx),%eax
  80c038:	89 04 24             	mov    %eax,(%esp)
  80c03b:	e8 30 9b ff ff       	call   805b70 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80c040:	c7 44 24 04 a1 c0 80 	movl   $0x80c0a1,0x4(%esp)
  80c047:	00 
  80c048:	8b 43 08             	mov    0x8(%ebx),%eax
  80c04b:	89 04 24             	mov    %eax,(%esp)
  80c04e:	e8 fe 9a ff ff       	call   805b51 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80c053:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c057:	8b 43 08             	mov    0x8(%ebx),%eax
  80c05a:	89 04 24             	mov    %eax,(%esp)
  80c05d:	e8 bf 9a ff ff       	call   805b21 <tcp_arg>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80c062:	83 c4 14             	add    $0x14,%esp
  80c065:	5b                   	pop    %ebx
  80c066:	5d                   	pop    %ebp
  80c067:	c3                   	ret    

0080c068 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c068:	55                   	push   %ebp
  80c069:	89 e5                	mov    %esp,%ebp
  80c06b:	83 ec 18             	sub    $0x18,%esp
  80c06e:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c071:	8b 02                	mov    (%edx),%eax
  80c073:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c077:	74 15                	je     80c08e <do_close+0x26>
  80c079:	83 38 10             	cmpl   $0x10,(%eax)
  80c07c:	75 10                	jne    80c08e <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80c07e:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c085:	8b 02                	mov    (%edx),%eax
  80c087:	e8 e0 fd ff ff       	call   80be6c <do_close_internal>
 */
void
do_close(struct api_msg_msg *msg)
{
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c08c:	eb 11                	jmp    80c09f <do_close+0x37>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c08e:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c092:	8b 02                	mov    (%edx),%eax
  80c094:	8b 40 10             	mov    0x10(%eax),%eax
  80c097:	89 04 24             	mov    %eax,(%esp)
  80c09a:	e8 d2 eb ff ff       	call   80ac71 <sys_sem_signal>
  }
}
  80c09f:	c9                   	leave  
  80c0a0:	c3                   	ret    

0080c0a1 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80c0a1:	55                   	push   %ebp
  80c0a2:	89 e5                	mov    %esp,%ebp
  80c0a4:	53                   	push   %ebx
  80c0a5:	83 ec 14             	sub    $0x14,%esp
  80c0a8:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  80c0ac:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80c0af:	85 db                	test   %ebx,%ebx
  80c0b1:	75 1c                	jne    80c0cf <err_tcp+0x2e>
  80c0b3:	c7 44 24 08 f9 2f 81 	movl   $0x812ff9,0x8(%esp)
  80c0ba:	00 
  80c0bb:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
  80c0c2:	00 
  80c0c3:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80c0ca:	e8 1d 31 00 00       	call   80f1ec <_panic>

  conn->pcb.tcp = NULL;
  80c0cf:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80c0d6:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80c0d9:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80c0dd:	74 2f                	je     80c10e <err_tcp+0x6d>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c0df:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c0e2:	85 c0                	test   %eax,%eax
  80c0e4:	74 15                	je     80c0fb <err_tcp+0x5a>
  80c0e6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c0ed:	00 
  80c0ee:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c0f5:	00 
  80c0f6:	89 1c 24             	mov    %ebx,(%esp)
  80c0f9:	ff d0                	call   *%eax
    sys_mbox_post(conn->recvmbox, NULL);
  80c0fb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c102:	00 
  80c103:	8b 43 14             	mov    0x14(%ebx),%eax
  80c106:	89 04 24             	mov    %eax,(%esp)
  80c109:	e8 cc ed ff ff       	call   80aeda <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80c10e:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  80c112:	74 18                	je     80c12c <err_tcp+0x8b>
  80c114:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80c118:	75 12                	jne    80c12c <err_tcp+0x8b>
    conn->state = NETCONN_NONE;
  80c11a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80c121:	8b 43 10             	mov    0x10(%ebx),%eax
  80c124:	89 04 24             	mov    %eax,(%esp)
  80c127:	e8 45 eb ff ff       	call   80ac71 <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80c12c:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c130:	74 2f                	je     80c161 <err_tcp+0xc0>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c132:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c135:	85 c0                	test   %eax,%eax
  80c137:	74 15                	je     80c14e <err_tcp+0xad>
  80c139:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c140:	00 
  80c141:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c148:	00 
  80c149:	89 1c 24             	mov    %ebx,(%esp)
  80c14c:	ff d0                	call   *%eax
    sys_mbox_post(conn->acceptmbox, NULL);
  80c14e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c155:	00 
  80c156:	8b 43 18             	mov    0x18(%ebx),%eax
  80c159:	89 04 24             	mov    %eax,(%esp)
  80c15c:	e8 79 ed ff ff       	call   80aeda <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80c161:	8b 43 04             	mov    0x4(%ebx),%eax
  80c164:	83 f8 01             	cmp    $0x1,%eax
  80c167:	74 05                	je     80c16e <err_tcp+0xcd>
  80c169:	83 f8 04             	cmp    $0x4,%eax
  80c16c:	75 12                	jne    80c180 <err_tcp+0xdf>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80c16e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80c175:	8b 43 10             	mov    0x10(%ebx),%eax
  80c178:	89 04 24             	mov    %eax,(%esp)
  80c17b:	e8 f1 ea ff ff       	call   80ac71 <sys_sem_signal>
  }
}
  80c180:	83 c4 14             	add    $0x14,%esp
  80c183:	5b                   	pop    %ebx
  80c184:	5d                   	pop    %ebp
  80c185:	c3                   	ret    

0080c186 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80c186:	55                   	push   %ebp
  80c187:	89 e5                	mov    %esp,%ebp
  80c189:	57                   	push   %edi
  80c18a:	56                   	push   %esi
  80c18b:	53                   	push   %ebx
  80c18c:	83 ec 2c             	sub    $0x2c,%esp
  80c18f:	89 c3                	mov    %eax,%ebx
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80c191:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80c195:	74 1c                	je     80c1b3 <do_writemore+0x2d>
  80c197:	c7 44 24 08 06 30 81 	movl   $0x813006,0x8(%esp)
  80c19e:	00 
  80c19f:	c7 44 24 04 b8 03 00 	movl   $0x3b8,0x4(%esp)
  80c1a6:	00 
  80c1a7:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80c1ae:	e8 39 30 00 00       	call   80f1ec <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80c1b3:	8b 50 24             	mov    0x24(%eax),%edx
  80c1b6:	8b 42 04             	mov    0x4(%edx),%eax
  80c1b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c1bc:	8b 43 28             	mov    0x28(%ebx),%eax
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80c1bf:	8b 72 08             	mov    0x8(%edx),%esi
  80c1c2:	89 f1                	mov    %esi,%ecx
  80c1c4:	29 c1                	sub    %eax,%ecx
  80c1c6:	66 29 c6             	sub    %ax,%si
  80c1c9:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80c1cf:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80c1d4:	0f 4d f1             	cmovge %ecx,%esi
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80c1d7:	8b 4b 08             	mov    0x8(%ebx),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80c1da:	66 3b 71 6e          	cmp    0x6e(%ecx),%si
  80c1de:	0f b7 79 6e          	movzwl 0x6e(%ecx),%edi
  80c1e2:	0f 47 f7             	cmova  %edi,%esi
  80c1e5:	0f b7 f6             	movzwl %si,%esi
  80c1e8:	0f b6 52 0c          	movzbl 0xc(%edx),%edx
  80c1ec:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80c1f0:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c1f4:	03 45 e4             	add    -0x1c(%ebp),%eax
  80c1f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c1fb:	89 0c 24             	mov    %ecx,(%esp)
  80c1fe:	e8 d7 ce ff ff       	call   8090da <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80c203:	89 f2                	mov    %esi,%edx
  80c205:	03 53 28             	add    0x28(%ebx),%edx
  80c208:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80c20b:	3b 51 08             	cmp    0x8(%ecx),%edx
  80c20e:	7e 1c                	jle    80c22c <do_writemore+0xa6>
  80c210:	c7 44 24 08 23 30 81 	movl   $0x813023,0x8(%esp)
  80c217:	00 
  80c218:	c7 44 24 04 cd 03 00 	movl   $0x3cd,0x4(%esp)
  80c21f:	00 
  80c220:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80c227:	e8 c0 2f 00 00       	call   80f1ec <_panic>
  if (err == ERR_OK) {
  80c22c:	84 c0                	test   %al,%al
  80c22e:	75 72                	jne    80c2a2 <do_writemore+0x11c>
    conn->write_offset += len;
  80c230:	89 53 28             	mov    %edx,0x28(%ebx)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80c233:	8b 43 24             	mov    0x24(%ebx),%eax
  80c236:	bf 00 00 00 00       	mov    $0x0,%edi
  80c23b:	3b 50 08             	cmp    0x8(%eax),%edx
  80c23e:	75 13                	jne    80c253 <do_writemore+0xcd>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80c240:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80c247:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  80c24e:	bf 01 00 00 00       	mov    $0x1,%edi
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80c253:	8b 43 08             	mov    0x8(%ebx),%eax
  80c256:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80c25a:	74 12                	je     80c26e <do_writemore+0xe8>
  80c25c:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80c260:	75 0c                	jne    80c26e <do_writemore+0xe8>
  80c262:	8b 50 74             	mov    0x74(%eax),%edx
  80c265:	85 d2                	test   %edx,%edx
  80c267:	74 78                	je     80c2e1 <do_writemore+0x15b>
  80c269:	83 3a 00             	cmpl   $0x0,(%edx)
  80c26c:	74 73                	je     80c2e1 <do_writemore+0x15b>
  80c26e:	89 04 24             	mov    %eax,(%esp)
  80c271:	e8 55 c2 ff ff       	call   8084cb <tcp_output>
    conn->err = err;
  80c276:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80c279:	84 c0                	test   %al,%al
  80c27b:	75 3b                	jne    80c2b8 <do_writemore+0x132>
  80c27d:	8b 43 08             	mov    0x8(%ebx),%eax
  80c280:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80c286:	77 30                	ja     80c2b8 <do_writemore+0x132>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80c288:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c28b:	85 c0                	test   %eax,%eax
  80c28d:	74 29                	je     80c2b8 <do_writemore+0x132>
  80c28f:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c293:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80c29a:	00 
  80c29b:	89 1c 24             	mov    %ebx,(%esp)
  80c29e:	ff d0                	call   *%eax
  80c2a0:	eb 16                	jmp    80c2b8 <do_writemore+0x132>
    }
  } else if (err == ERR_MEM) {
  80c2a2:	3c ff                	cmp    $0xff,%al
  80c2a4:	75 0d                	jne    80c2b3 <do_writemore+0x12d>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80c2a6:	8b 43 08             	mov    0x8(%ebx),%eax
  80c2a9:	89 04 24             	mov    %eax,(%esp)
  80c2ac:	e8 1a c2 ff ff       	call   8084cb <tcp_output>
  80c2b1:	eb 21                	jmp    80c2d4 <do_writemore+0x14e>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80c2b3:	88 43 0c             	mov    %al,0xc(%ebx)
  80c2b6:	eb 0a                	jmp    80c2c2 <do_writemore+0x13c>
    write_finished = 1;
  }

  if (write_finished) {
  80c2b8:	89 f8                	mov    %edi,%eax
  80c2ba:	84 c0                	test   %al,%al
  80c2bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c2c0:	74 12                	je     80c2d4 <do_writemore+0x14e>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80c2c2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80c2c9:	8b 43 10             	mov    0x10(%ebx),%eax
  80c2cc:	89 04 24             	mov    %eax,(%esp)
  80c2cf:	e8 9d e9 ff ff       	call   80ac71 <sys_sem_signal>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80c2d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80c2d9:	83 c4 2c             	add    $0x2c,%esp
  80c2dc:	5b                   	pop    %ebx
  80c2dd:	5e                   	pop    %esi
  80c2de:	5f                   	pop    %edi
  80c2df:	5d                   	pop    %ebp
  80c2e0:	c3                   	ret    
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80c2e1:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80c2e5:	eb 96                	jmp    80c27d <do_writemore+0xf7>

0080c2e7 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80c2e7:	55                   	push   %ebp
  80c2e8:	89 e5                	mov    %esp,%ebp
  80c2ea:	83 ec 18             	sub    $0x18,%esp
  struct netconn *conn = arg;
  80c2ed:	8b 45 08             	mov    0x8(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80c2f0:	85 c0                	test   %eax,%eax
  80c2f2:	75 1c                	jne    80c310 <poll_tcp+0x29>
  80c2f4:	c7 44 24 08 f9 2f 81 	movl   $0x812ff9,0x8(%esp)
  80c2fb:	00 
  80c2fc:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  80c303:	00 
  80c304:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80c30b:	e8 dc 2e 00 00       	call   80f1ec <_panic>

  if (conn->state == NETCONN_WRITE) {
  80c310:	8b 50 04             	mov    0x4(%eax),%edx
  80c313:	83 fa 01             	cmp    $0x1,%edx
  80c316:	75 07                	jne    80c31f <poll_tcp+0x38>
    do_writemore(conn);
  80c318:	e8 69 fe ff ff       	call   80c186 <do_writemore>
  80c31d:	eb 0a                	jmp    80c329 <poll_tcp+0x42>
  } else if (conn->state == NETCONN_CLOSE) {
  80c31f:	83 fa 04             	cmp    $0x4,%edx
  80c322:	75 05                	jne    80c329 <poll_tcp+0x42>
    do_close_internal(conn);
  80c324:	e8 43 fb ff ff       	call   80be6c <do_close_internal>
  }

  return ERR_OK;
}
  80c329:	b8 00 00 00 00       	mov    $0x0,%eax
  80c32e:	c9                   	leave  
  80c32f:	c3                   	ret    

0080c330 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80c330:	55                   	push   %ebp
  80c331:	89 e5                	mov    %esp,%ebp
  80c333:	83 ec 18             	sub    $0x18,%esp
  80c336:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80c339:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80c33c:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct netconn *conn = arg;
  80c340:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80c343:	85 db                	test   %ebx,%ebx
  80c345:	75 1c                	jne    80c363 <sent_tcp+0x33>
  80c347:	c7 44 24 08 f9 2f 81 	movl   $0x812ff9,0x8(%esp)
  80c34e:	00 
  80c34f:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  80c356:	00 
  80c357:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80c35e:	e8 89 2e 00 00       	call   80f1ec <_panic>

  if (conn->state == NETCONN_WRITE) {
  80c363:	8b 43 04             	mov    0x4(%ebx),%eax
  80c366:	83 f8 01             	cmp    $0x1,%eax
  80c369:	75 2b                	jne    80c396 <sent_tcp+0x66>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80c36b:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80c36f:	75 1c                	jne    80c38d <sent_tcp+0x5d>
  80c371:	c7 44 24 08 41 30 81 	movl   $0x813041,0x8(%esp)
  80c378:	00 
  80c379:	c7 44 24 04 06 01 00 	movl   $0x106,0x4(%esp)
  80c380:	00 
  80c381:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80c388:	e8 5f 2e 00 00       	call   80f1ec <_panic>
    do_writemore(conn);
  80c38d:	89 d8                	mov    %ebx,%eax
  80c38f:	e8 f2 fd ff ff       	call   80c186 <do_writemore>
  80c394:	eb 0f                	jmp    80c3a5 <sent_tcp+0x75>
  } else if (conn->state == NETCONN_CLOSE) {
  80c396:	83 f8 04             	cmp    $0x4,%eax
  80c399:	75 0a                	jne    80c3a5 <sent_tcp+0x75>
    do_close_internal(conn);
  80c39b:	89 d8                	mov    %ebx,%eax
  80c39d:	8d 76 00             	lea    0x0(%esi),%esi
  80c3a0:	e8 c7 fa ff ff       	call   80be6c <do_close_internal>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80c3a5:	8b 43 08             	mov    0x8(%ebx),%eax
  80c3a8:	85 c0                	test   %eax,%eax
  80c3aa:	74 23                	je     80c3cf <sent_tcp+0x9f>
  80c3ac:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80c3b2:	76 1b                	jbe    80c3cf <sent_tcp+0x9f>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80c3b4:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c3b7:	85 c0                	test   %eax,%eax
  80c3b9:	74 14                	je     80c3cf <sent_tcp+0x9f>
  80c3bb:	0f b7 f6             	movzwl %si,%esi
  80c3be:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c3c2:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c3c9:	00 
  80c3ca:	89 1c 24             	mov    %ebx,(%esp)
  80c3cd:	ff d0                	call   *%eax
    }
  }
  
  return ERR_OK;
}
  80c3cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80c3d4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80c3d7:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80c3da:	89 ec                	mov    %ebp,%esp
  80c3dc:	5d                   	pop    %ebp
  80c3dd:	c3                   	ret    

0080c3de <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c3de:	55                   	push   %ebp
  80c3df:	89 e5                	mov    %esp,%ebp
  80c3e1:	83 ec 18             	sub    $0x18,%esp
  80c3e4:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c3e7:	8b 02                	mov    (%edx),%eax
  80c3e9:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c3ed:	7c 2d                	jl     80c41c <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c3ef:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c3f3:	74 23                	je     80c418 <do_write+0x3a>
  80c3f5:	83 38 10             	cmpl   $0x10,(%eax)
  80c3f8:	75 1e                	jne    80c418 <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80c3fa:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80c401:	8b 02                	mov    (%edx),%eax
  80c403:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c406:	8b 02                	mov    (%edx),%eax
  80c408:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80c40f:	8b 02                	mov    (%edx),%eax
  80c411:	e8 70 fd ff ff       	call   80c186 <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80c416:	eb 11                	jmp    80c429 <do_write+0x4b>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c418:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c41c:	8b 02                	mov    (%edx),%eax
  80c41e:	8b 40 10             	mov    0x10(%eax),%eax
  80c421:	89 04 24             	mov    %eax,(%esp)
  80c424:	e8 48 e8 ff ff       	call   80ac71 <sys_sem_signal>
}
  80c429:	c9                   	leave  
  80c42a:	c3                   	ret    

0080c42b <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80c42b:	55                   	push   %ebp
  80c42c:	89 e5                	mov    %esp,%ebp
  80c42e:	53                   	push   %ebx
  80c42f:	83 ec 14             	sub    $0x14,%esp
  80c432:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c435:	8b 03                	mov    (%ebx),%eax
  80c437:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c43b:	7c 1c                	jl     80c459 <do_recv+0x2e>
    if (msg->conn->pcb.tcp != NULL) {
  80c43d:	8b 50 08             	mov    0x8(%eax),%edx
  80c440:	85 d2                	test   %edx,%edx
  80c442:	74 15                	je     80c459 <do_recv+0x2e>
      if (msg->conn->type == NETCONN_TCP) {
  80c444:	83 38 10             	cmpl   $0x10,(%eax)
  80c447:	75 10                	jne    80c459 <do_recv+0x2e>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c449:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c44d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c451:	89 14 24             	mov    %edx,(%esp)
  80c454:	e8 77 97 ff ff       	call   805bd0 <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80c459:	8b 03                	mov    (%ebx),%eax
  80c45b:	8b 40 10             	mov    0x10(%eax),%eax
  80c45e:	89 04 24             	mov    %eax,(%esp)
  80c461:	e8 0b e8 ff ff       	call   80ac71 <sys_sem_signal>
}
  80c466:	83 c4 14             	add    $0x14,%esp
  80c469:	5b                   	pop    %ebx
  80c46a:	5d                   	pop    %ebp
  80c46b:	c3                   	ret    

0080c46c <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80c46c:	55                   	push   %ebp
  80c46d:	89 e5                	mov    %esp,%ebp
  80c46f:	83 ec 28             	sub    $0x28,%esp
  80c472:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80c475:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80c478:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80c47b:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c47e:	8b 1e                	mov    (%esi),%ebx
  80c480:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80c484:	0f 8c 8b 00 00 00    	jl     80c515 <do_send+0xa9>
    if (msg->conn->pcb.tcp != NULL) {
  80c48a:	8b 43 08             	mov    0x8(%ebx),%eax
  80c48d:	85 c0                	test   %eax,%eax
  80c48f:	0f 84 80 00 00 00    	je     80c515 <do_send+0xa9>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c495:	8b 13                	mov    (%ebx),%edx
  80c497:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c49d:	83 fa 20             	cmp    $0x20,%edx
  80c4a0:	74 39                	je     80c4db <do_send+0x6f>
  80c4a2:	83 fa 40             	cmp    $0x40,%edx
  80c4a5:	75 6e                	jne    80c515 <do_send+0xa9>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80c4a7:	8b 56 04             	mov    0x4(%esi),%edx
  80c4aa:	8b 4a 08             	mov    0x8(%edx),%ecx
  80c4ad:	85 c9                	test   %ecx,%ecx
  80c4af:	75 13                	jne    80c4c4 <do_send+0x58>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80c4b1:	8b 12                	mov    (%edx),%edx
  80c4b3:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c4b7:	89 04 24             	mov    %eax,(%esp)
  80c4ba:	e8 79 26 00 00       	call   80eb38 <raw_send>
  80c4bf:	88 43 0c             	mov    %al,0xc(%ebx)
  80c4c2:	eb 51                	jmp    80c515 <do_send+0xa9>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80c4c4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80c4c8:	8b 12                	mov    (%edx),%edx
  80c4ca:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c4ce:	89 04 24             	mov    %eax,(%esp)
  80c4d1:	e8 58 25 00 00       	call   80ea2e <raw_sendto>
  80c4d6:	88 43 0c             	mov    %al,0xc(%ebx)
  80c4d9:	eb 3a                	jmp    80c515 <do_send+0xa9>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80c4db:	8b 56 04             	mov    0x4(%esi),%edx
  80c4de:	8b 4a 08             	mov    0x8(%edx),%ecx
  80c4e1:	85 c9                	test   %ecx,%ecx
  80c4e3:	75 13                	jne    80c4f8 <do_send+0x8c>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80c4e5:	8b 12                	mov    (%edx),%edx
  80c4e7:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c4eb:	89 04 24             	mov    %eax,(%esp)
  80c4ee:	e8 92 d0 ff ff       	call   809585 <udp_send>
  80c4f3:	88 43 0c             	mov    %al,0xc(%ebx)
  80c4f6:	eb 1d                	jmp    80c515 <do_send+0xa9>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80c4f8:	0f b7 7a 0c          	movzwl 0xc(%edx),%edi
  80c4fc:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80c500:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80c504:	8b 12                	mov    (%edx),%edx
  80c506:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c50a:	89 04 24             	mov    %eax,(%esp)
  80c50d:	e8 22 d0 ff ff       	call   809534 <udp_sendto>
  80c512:	88 43 0c             	mov    %al,0xc(%ebx)
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c515:	8b 06                	mov    (%esi),%eax
  80c517:	8b 40 10             	mov    0x10(%eax),%eax
  80c51a:	89 04 24             	mov    %eax,(%esp)
  80c51d:	e8 4f e7 ff ff       	call   80ac71 <sys_sem_signal>
}
  80c522:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80c525:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80c528:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80c52b:	89 ec                	mov    %ebp,%esp
  80c52d:	5d                   	pop    %ebp
  80c52e:	c3                   	ret    

0080c52f <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80c52f:	55                   	push   %ebp
  80c530:	89 e5                	mov    %esp,%ebp
  80c532:	83 ec 28             	sub    $0x28,%esp
  80c535:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80c538:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80c53b:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80c53e:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c541:	8b 03                	mov    (%ebx),%eax
  80c543:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c547:	0f 8c b9 00 00 00    	jl     80c606 <do_listen+0xd7>
    if (msg->conn->pcb.tcp != NULL) {
  80c54d:	8b 50 08             	mov    0x8(%eax),%edx
  80c550:	85 d2                	test   %edx,%edx
  80c552:	0f 84 ae 00 00 00    	je     80c606 <do_listen+0xd7>
      if (msg->conn->type == NETCONN_TCP) {
  80c558:	83 38 10             	cmpl   $0x10,(%eax)
  80c55b:	0f 85 a5 00 00 00    	jne    80c606 <do_listen+0xd7>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80c561:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80c565:	0f 85 97 00 00 00    	jne    80c602 <do_listen+0xd3>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80c56b:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80c572:	00 
  80c573:	89 14 24             	mov    %edx,(%esp)
  80c576:	e8 80 99 ff ff       	call   805efb <tcp_listen_with_backlog>
  80c57b:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80c57d:	85 c0                	test   %eax,%eax
  80c57f:	75 08                	jne    80c589 <do_listen+0x5a>
            msg->conn->err = ERR_MEM;
  80c581:	8b 03                	mov    (%ebx),%eax
  80c583:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c587:	eb 7d                	jmp    80c606 <do_listen+0xd7>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80c589:	8b 03                	mov    (%ebx),%eax
  80c58b:	8b 40 14             	mov    0x14(%eax),%eax
  80c58e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c591:	74 11                	je     80c5a4 <do_listen+0x75>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80c593:	89 04 24             	mov    %eax,(%esp)
  80c596:	e8 50 e1 ff ff       	call   80a6eb <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80c59b:	8b 03                	mov    (%ebx),%eax
  80c59d:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80c5a4:	8b 3b                	mov    (%ebx),%edi
  80c5a6:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80c5aa:	75 1a                	jne    80c5c6 <do_listen+0x97>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80c5ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c5b3:	e8 a1 e5 ff ff       	call   80ab59 <sys_mbox_new>
  80c5b8:	89 47 18             	mov    %eax,0x18(%edi)
  80c5bb:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c5be:	75 06                	jne    80c5c6 <do_listen+0x97>
                msg->conn->err = ERR_MEM;
  80c5c0:	8b 03                	mov    (%ebx),%eax
  80c5c2:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80c5c6:	8b 03                	mov    (%ebx),%eax
  80c5c8:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c5cc:	75 38                	jne    80c606 <do_listen+0xd7>
              msg->conn->state = NETCONN_LISTEN;
  80c5ce:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80c5d5:	8b 03                	mov    (%ebx),%eax
  80c5d7:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80c5da:	8b 03                	mov    (%ebx),%eax
  80c5dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c5e0:	8b 40 08             	mov    0x8(%eax),%eax
  80c5e3:	89 04 24             	mov    %eax,(%esp)
  80c5e6:	e8 36 95 ff ff       	call   805b21 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80c5eb:	c7 44 24 04 f9 cb 80 	movl   $0x80cbf9,0x4(%esp)
  80c5f2:	00 
  80c5f3:	8b 03                	mov    (%ebx),%eax
  80c5f5:	8b 40 08             	mov    0x8(%eax),%eax
  80c5f8:	89 04 24             	mov    %eax,(%esp)
  80c5fb:	e8 62 95 ff ff       	call   805b62 <tcp_accept>
  80c600:	eb 04                	jmp    80c606 <do_listen+0xd7>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80c602:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80c606:	8b 03                	mov    (%ebx),%eax
  80c608:	8b 40 10             	mov    0x10(%eax),%eax
  80c60b:	89 04 24             	mov    %eax,(%esp)
  80c60e:	e8 5e e6 ff ff       	call   80ac71 <sys_sem_signal>
}
  80c613:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80c616:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80c619:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80c61c:	89 ec                	mov    %ebp,%esp
  80c61e:	5d                   	pop    %ebp
  80c61f:	c3                   	ret    

0080c620 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80c620:	55                   	push   %ebp
  80c621:	89 e5                	mov    %esp,%ebp
  80c623:	83 ec 18             	sub    $0x18,%esp
  80c626:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80c629:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80c62c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c62f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c632:	8b 75 10             	mov    0x10(%ebp),%esi
  80c635:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80c639:	85 c0                	test   %eax,%eax
  80c63b:	75 1c                	jne    80c659 <recv_tcp+0x39>
  80c63d:	c7 44 24 08 dc 30 81 	movl   $0x8130dc,0x8(%esp)
  80c644:	00 
  80c645:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
  80c64c:	00 
  80c64d:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80c654:	e8 93 2b 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80c659:	85 db                	test   %ebx,%ebx
  80c65b:	75 1c                	jne    80c679 <recv_tcp+0x59>
  80c65d:	c7 44 24 08 00 31 81 	movl   $0x813100,0x8(%esp)
  80c664:	00 
  80c665:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80c66c:	00 
  80c66d:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80c674:	e8 73 2b 00 00       	call   80f1ec <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80c679:	39 43 08             	cmp    %eax,0x8(%ebx)
  80c67c:	74 1c                	je     80c69a <recv_tcp+0x7a>
  80c67e:	c7 44 24 08 57 30 81 	movl   $0x813057,0x8(%esp)
  80c685:	00 
  80c686:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
  80c68d:	00 
  80c68e:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80c695:	e8 52 2b 00 00       	call   80f1ec <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80c69a:	85 db                	test   %ebx,%ebx
  80c69c:	74 4c                	je     80c6ea <recv_tcp+0xca>
  80c69e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80c6a2:	74 46                	je     80c6ea <recv_tcp+0xca>
    return ERR_VAL;
  }

  conn->err = err;
  80c6a4:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80c6a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80c6ac:	85 f6                	test   %esi,%esi
  80c6ae:	74 08                	je     80c6b8 <recv_tcp+0x98>
    len = p->tot_len;
  80c6b0:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80c6b4:	66 01 43 20          	add    %ax,0x20(%ebx)
  } else {
    len = 0;
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80c6b8:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80c6bb:	85 d2                	test   %edx,%edx
  80c6bd:	74 14                	je     80c6d3 <recv_tcp+0xb3>
  80c6bf:	0f b7 c0             	movzwl %ax,%eax
  80c6c2:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c6c6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c6cd:	00 
  80c6ce:	89 1c 24             	mov    %ebx,(%esp)
  80c6d1:	ff d2                	call   *%edx
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80c6d3:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c6d7:	8b 43 14             	mov    0x14(%ebx),%eax
  80c6da:	89 04 24             	mov    %eax,(%esp)
  80c6dd:	e8 2a e7 ff ff       	call   80ae0c <sys_mbox_trypost>
  80c6e2:	3c 01                	cmp    $0x1,%al
  80c6e4:	19 c0                	sbb    %eax,%eax
  80c6e6:	f7 d0                	not    %eax
  80c6e8:	eb 05                	jmp    80c6ef <recv_tcp+0xcf>
  80c6ea:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80c6ef:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80c6f2:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80c6f5:	89 ec                	mov    %ebp,%esp
  80c6f7:	5d                   	pop    %ebp
  80c6f8:	c3                   	ret    

0080c6f9 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80c6f9:	55                   	push   %ebp
  80c6fa:	89 e5                	mov    %esp,%ebp
  80c6fc:	53                   	push   %ebx
  80c6fd:	83 ec 14             	sub    $0x14,%esp
  80c700:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80c703:	8b 03                	mov    (%ebx),%eax
  80c705:	8b 10                	mov    (%eax),%edx
  80c707:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c70d:	83 fa 20             	cmp    $0x20,%edx
  80c710:	75 0b                	jne    80c71d <do_disconnect+0x24>
    udp_disconnect(msg->conn->pcb.udp);
  80c712:	8b 40 08             	mov    0x8(%eax),%eax
  80c715:	89 04 24             	mov    %eax,(%esp)
  80c718:	e8 83 ca ff ff       	call   8091a0 <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80c71d:	8b 03                	mov    (%ebx),%eax
  80c71f:	8b 40 10             	mov    0x10(%eax),%eax
  80c722:	89 04 24             	mov    %eax,(%esp)
  80c725:	e8 47 e5 ff ff       	call   80ac71 <sys_sem_signal>
}
  80c72a:	83 c4 14             	add    $0x14,%esp
  80c72d:	5b                   	pop    %ebx
  80c72e:	5d                   	pop    %ebp
  80c72f:	c3                   	ret    

0080c730 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80c730:	55                   	push   %ebp
  80c731:	89 e5                	mov    %esp,%ebp
  80c733:	56                   	push   %esi
  80c734:	53                   	push   %ebx
  80c735:	83 ec 10             	sub    $0x10,%esp
  80c738:	8b 75 08             	mov    0x8(%ebp),%esi
  if (msg->conn->pcb.tcp == NULL) {
  80c73b:	8b 1e                	mov    (%esi),%ebx
  80c73d:	8b 53 08             	mov    0x8(%ebx),%edx
  80c740:	85 d2                	test   %edx,%edx
  80c742:	75 10                	jne    80c754 <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80c744:	8b 43 10             	mov    0x10(%ebx),%eax
  80c747:	89 04 24             	mov    %eax,(%esp)
  80c74a:	e8 22 e5 ff ff       	call   80ac71 <sys_sem_signal>
    return;
  80c74f:	e9 9d 00 00 00       	jmp    80c7f1 <do_connect+0xc1>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c754:	8b 03                	mov    (%ebx),%eax
  80c756:	25 f0 00 00 00       	and    $0xf0,%eax
  80c75b:	83 f8 20             	cmp    $0x20,%eax
  80c75e:	74 33                	je     80c793 <do_connect+0x63>
  80c760:	83 f8 40             	cmp    $0x40,%eax
  80c763:	74 0d                	je     80c772 <do_connect+0x42>
  80c765:	83 f8 10             	cmp    $0x10,%eax
  80c768:	0f 85 83 00 00 00    	jne    80c7f1 <do_connect+0xc1>
  80c76e:	66 90                	xchg   %ax,%ax
  80c770:	eb 4a                	jmp    80c7bc <do_connect+0x8c>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c772:	8b 46 04             	mov    0x4(%esi),%eax
  80c775:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c779:	89 14 24             	mov    %edx,(%esp)
  80c77c:	e8 d8 21 00 00       	call   80e959 <raw_connect>
  80c781:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80c784:	8b 06                	mov    (%esi),%eax
  80c786:	8b 40 10             	mov    0x10(%eax),%eax
  80c789:	89 04 24             	mov    %eax,(%esp)
  80c78c:	e8 e0 e4 ff ff       	call   80ac71 <sys_sem_signal>
    break;
  80c791:	eb 5e                	jmp    80c7f1 <do_connect+0xc1>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c793:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c797:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c79b:	8b 46 04             	mov    0x4(%esi),%eax
  80c79e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c7a2:	89 14 24             	mov    %edx,(%esp)
  80c7a5:	e8 67 cb ff ff       	call   809311 <udp_connect>
  80c7aa:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80c7ad:	8b 06                	mov    (%esi),%eax
  80c7af:	8b 40 10             	mov    0x10(%eax),%eax
  80c7b2:	89 04 24             	mov    %eax,(%esp)
  80c7b5:	e8 b7 e4 ff ff       	call   80ac71 <sys_sem_signal>
    break;
  80c7ba:	eb 35                	jmp    80c7f1 <do_connect+0xc1>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80c7bc:	c7 43 04 03 00 00 00 	movl   $0x3,0x4(%ebx)
    setup_tcp(msg->conn);
  80c7c3:	8b 06                	mov    (%esi),%eax
  80c7c5:	e8 f7 f5 ff ff       	call   80bdc1 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80c7ca:	8b 1e                	mov    (%esi),%ebx
  80c7cc:	c7 44 24 0c 25 be 80 	movl   $0x80be25,0xc(%esp)
  80c7d3:	00 
  80c7d4:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c7d8:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c7dc:	8b 46 04             	mov    0x4(%esi),%eax
  80c7df:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c7e3:	8b 43 08             	mov    0x8(%ebx),%eax
  80c7e6:	89 04 24             	mov    %eax,(%esp)
  80c7e9:	e8 4e 99 ff ff       	call   80613c <tcp_connect>
  80c7ee:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80c7f1:	83 c4 10             	add    $0x10,%esp
  80c7f4:	5b                   	pop    %ebx
  80c7f5:	5e                   	pop    %esi
  80c7f6:	5d                   	pop    %ebp
  80c7f7:	c3                   	ret    

0080c7f8 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80c7f8:	55                   	push   %ebp
  80c7f9:	89 e5                	mov    %esp,%ebp
  80c7fb:	83 ec 18             	sub    $0x18,%esp
  80c7fe:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80c801:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80c804:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c807:	8b 1e                	mov    (%esi),%ebx
  80c809:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80c80d:	7c 73                	jl     80c882 <do_bind+0x8a>
    if (msg->conn->pcb.tcp != NULL) {
  80c80f:	8b 53 08             	mov    0x8(%ebx),%edx
  80c812:	85 d2                	test   %edx,%edx
  80c814:	74 68                	je     80c87e <do_bind+0x86>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c816:	8b 03                	mov    (%ebx),%eax
  80c818:	25 f0 00 00 00       	and    $0xf0,%eax
  80c81d:	83 f8 20             	cmp    $0x20,%eax
  80c820:	74 24                	je     80c846 <do_bind+0x4e>
  80c822:	83 f8 40             	cmp    $0x40,%eax
  80c825:	74 0b                	je     80c832 <do_bind+0x3a>
  80c827:	83 f8 10             	cmp    $0x10,%eax
  80c82a:	75 56                	jne    80c882 <do_bind+0x8a>
  80c82c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c830:	eb 30                	jmp    80c862 <do_bind+0x6a>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c832:	8b 46 04             	mov    0x4(%esi),%eax
  80c835:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c839:	89 14 24             	mov    %edx,(%esp)
  80c83c:	e8 fb 20 00 00       	call   80e93c <raw_bind>
  80c841:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80c844:	eb 3c                	jmp    80c882 <do_bind+0x8a>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c846:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c84a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c84e:	8b 46 04             	mov    0x4(%esi),%eax
  80c851:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c855:	89 14 24             	mov    %edx,(%esp)
  80c858:	e8 f5 c9 ff ff       	call   809252 <udp_bind>
  80c85d:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80c860:	eb 20                	jmp    80c882 <do_bind+0x8a>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c862:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c866:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c86a:	8b 46 04             	mov    0x4(%esi),%eax
  80c86d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c871:	89 14 24             	mov    %edx,(%esp)
  80c874:	e8 82 97 ff ff       	call   805ffb <tcp_bind>
  80c879:	88 43 0c             	mov    %al,0xc(%ebx)
  80c87c:	eb 04                	jmp    80c882 <do_bind+0x8a>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80c87e:	c6 43 0c f7          	movb   $0xf7,0xc(%ebx)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c882:	8b 06                	mov    (%esi),%eax
  80c884:	8b 40 10             	mov    0x10(%eax),%eax
  80c887:	89 04 24             	mov    %eax,(%esp)
  80c88a:	e8 e2 e3 ff ff       	call   80ac71 <sys_sem_signal>
}
  80c88f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80c892:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80c895:	89 ec                	mov    %ebp,%esp
  80c897:	5d                   	pop    %ebp
  80c898:	c3                   	ret    

0080c899 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80c899:	55                   	push   %ebp
  80c89a:	89 e5                	mov    %esp,%ebp
  80c89c:	53                   	push   %ebx
  80c89d:	83 ec 14             	sub    $0x14,%esp
  80c8a0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80c8a3:	8b 03                	mov    (%ebx),%eax
  80c8a5:	8b 48 08             	mov    0x8(%eax),%ecx
  80c8a8:	85 c9                	test   %ecx,%ecx
  80c8aa:	74 4c                	je     80c8f8 <do_delconn+0x5f>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c8ac:	8b 10                	mov    (%eax),%edx
  80c8ae:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c8b4:	83 fa 20             	cmp    $0x20,%edx
  80c8b7:	74 19                	je     80c8d2 <do_delconn+0x39>
  80c8b9:	83 fa 40             	cmp    $0x40,%edx
  80c8bc:	74 07                	je     80c8c5 <do_delconn+0x2c>
  80c8be:	83 fa 10             	cmp    $0x10,%edx
  80c8c1:	75 35                	jne    80c8f8 <do_delconn+0x5f>
  80c8c3:	eb 23                	jmp    80c8e8 <do_delconn+0x4f>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80c8c5:	89 0c 24             	mov    %ecx,(%esp)
  80c8c8:	e8 1b 21 00 00       	call   80e9e8 <raw_remove>
      break;
  80c8cd:	8d 76 00             	lea    0x0(%esi),%esi
  80c8d0:	eb 26                	jmp    80c8f8 <do_delconn+0x5f>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80c8d2:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80c8d9:	8b 03                	mov    (%ebx),%eax
  80c8db:	8b 40 08             	mov    0x8(%eax),%eax
  80c8de:	89 04 24             	mov    %eax,(%esp)
  80c8e1:	e8 26 c9 ff ff       	call   80920c <udp_remove>
      break;
  80c8e6:	eb 10                	jmp    80c8f8 <do_delconn+0x5f>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80c8e8:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c8ef:	8b 03                	mov    (%ebx),%eax
  80c8f1:	e8 76 f5 ff ff       	call   80be6c <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80c8f6:	eb 4e                	jmp    80c946 <do_delconn+0xad>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80c8f8:	8b 13                	mov    (%ebx),%edx
  80c8fa:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c8fd:	85 c0                	test   %eax,%eax
  80c8ff:	74 33                	je     80c934 <do_delconn+0x9b>
  80c901:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c908:	00 
  80c909:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c910:	00 
  80c911:	89 14 24             	mov    %edx,(%esp)
  80c914:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80c916:	8b 13                	mov    (%ebx),%edx
  80c918:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c91b:	85 c0                	test   %eax,%eax
  80c91d:	74 15                	je     80c934 <do_delconn+0x9b>
  80c91f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c926:	00 
  80c927:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c92e:	00 
  80c92f:	89 14 24             	mov    %edx,(%esp)
  80c932:	ff d0                	call   *%eax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80c934:	8b 03                	mov    (%ebx),%eax
  80c936:	8b 40 10             	mov    0x10(%eax),%eax
  80c939:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c93c:	74 08                	je     80c946 <do_delconn+0xad>
    sys_sem_signal(msg->conn->op_completed);
  80c93e:	89 04 24             	mov    %eax,(%esp)
  80c941:	e8 2b e3 ff ff       	call   80ac71 <sys_sem_signal>
  }
}
  80c946:	83 c4 14             	add    $0x14,%esp
  80c949:	5b                   	pop    %ebx
  80c94a:	5d                   	pop    %ebp
  80c94b:	c3                   	ret    

0080c94c <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80c94c:	55                   	push   %ebp
  80c94d:	89 e5                	mov    %esp,%ebp
  80c94f:	56                   	push   %esi
  80c950:	53                   	push   %ebx
  80c951:	83 ec 20             	sub    $0x20,%esp
  80c954:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80c957:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80c95b:	74 1c                	je     80c979 <netconn_free+0x2d>
  80c95d:	c7 44 24 08 20 31 81 	movl   $0x813120,0x8(%esp)
  80c964:	00 
  80c965:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
  80c96c:	00 
  80c96d:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80c974:	e8 73 28 00 00       	call   80f1ec <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80c979:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80c97c:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80c980:	75 25                	jne    80c9a7 <netconn_free+0x5b>
  80c982:	eb 49                	jmp    80c9cd <netconn_free+0x81>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80c984:	83 3b 10             	cmpl   $0x10,(%ebx)
  80c987:	75 13                	jne    80c99c <netconn_free+0x50>
        if(mem != NULL) {
  80c989:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c98c:	85 c0                	test   %eax,%eax
  80c98e:	66 90                	xchg   %ax,%ax
  80c990:	74 15                	je     80c9a7 <netconn_free+0x5b>
          pbuf_free((struct pbuf *)mem);
  80c992:	89 04 24             	mov    %eax,(%esp)
  80c995:	e8 8a 88 ff ff       	call   805224 <pbuf_free>
  80c99a:	eb 0b                	jmp    80c9a7 <netconn_free+0x5b>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80c99c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c99f:	89 04 24             	mov    %eax,(%esp)
  80c9a2:	e8 4f 60 ff ff       	call   8029f6 <netbuf_delete>
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80c9a7:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c9ab:	8b 43 14             	mov    0x14(%ebx),%eax
  80c9ae:	89 04 24             	mov    %eax,(%esp)
  80c9b1:	e8 34 e4 ff ff       	call   80adea <sys_arch_mbox_tryfetch>
  80c9b6:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c9b9:	75 c9                	jne    80c984 <netconn_free+0x38>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80c9bb:	8b 43 14             	mov    0x14(%ebx),%eax
  80c9be:	89 04 24             	mov    %eax,(%esp)
  80c9c1:	e8 25 dd ff ff       	call   80a6eb <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80c9c6:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80c9cd:	8d 75 f4             	lea    -0xc(%ebp),%esi
    sys_mbox_free(conn->recvmbox);
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80c9d0:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c9d4:	75 0d                	jne    80c9e3 <netconn_free+0x97>
  80c9d6:	eb 31                	jmp    80ca09 <netconn_free+0xbd>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80c9d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c9db:	89 04 24             	mov    %eax,(%esp)
  80c9de:	e8 d1 f1 ff ff       	call   80bbb4 <netconn_delete>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80c9e3:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c9e7:	8b 43 18             	mov    0x18(%ebx),%eax
  80c9ea:	89 04 24             	mov    %eax,(%esp)
  80c9ed:	e8 f8 e3 ff ff       	call   80adea <sys_arch_mbox_tryfetch>
  80c9f2:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c9f5:	75 e1                	jne    80c9d8 <netconn_free+0x8c>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80c9f7:	8b 43 18             	mov    0x18(%ebx),%eax
  80c9fa:	89 04 24             	mov    %eax,(%esp)
  80c9fd:	e8 e9 dc ff ff       	call   80a6eb <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80ca02:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  }

  sys_sem_free(conn->op_completed);
  80ca09:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca0c:	89 04 24             	mov    %eax,(%esp)
  80ca0f:	e8 55 dc ff ff       	call   80a669 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80ca14:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80ca1b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ca1f:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80ca26:	e8 99 80 ff ff       	call   804ac4 <memp_free>
}
  80ca2b:	83 c4 20             	add    $0x20,%esp
  80ca2e:	5b                   	pop    %ebx
  80ca2f:	5e                   	pop    %esi
  80ca30:	5d                   	pop    %ebp
  80ca31:	c3                   	ret    

0080ca32 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80ca32:	55                   	push   %ebp
  80ca33:	89 e5                	mov    %esp,%ebp
  80ca35:	83 ec 38             	sub    $0x38,%esp
  80ca38:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ca3b:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ca3e:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80ca41:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ca44:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ca47:	8b 7d 10             	mov    0x10(%ebp),%edi
  80ca4a:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80ca4e:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80ca52:	85 c0                	test   %eax,%eax
  80ca54:	75 1c                	jne    80ca72 <recv_udp+0x40>
  80ca56:	c7 44 24 08 50 31 81 	movl   $0x813150,0x8(%esp)
  80ca5d:	00 
  80ca5e:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80ca65:	00 
  80ca66:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80ca6d:	e8 7a 27 00 00       	call   80f1ec <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80ca72:	85 db                	test   %ebx,%ebx
  80ca74:	75 1c                	jne    80ca92 <recv_udp+0x60>
  80ca76:	c7 44 24 08 74 31 81 	movl   $0x813174,0x8(%esp)
  80ca7d:	00 
  80ca7e:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  80ca85:	00 
  80ca86:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80ca8d:	e8 5a 27 00 00       	call   80f1ec <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80ca92:	39 43 08             	cmp    %eax,0x8(%ebx)
  80ca95:	74 1c                	je     80cab3 <recv_udp+0x81>
  80ca97:	c7 44 24 08 75 30 81 	movl   $0x813075,0x8(%esp)
  80ca9e:	00 
  80ca9f:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  80caa6:	00 
  80caa7:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80caae:	e8 39 27 00 00       	call   80f1ec <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80cab3:	85 db                	test   %ebx,%ebx
  80cab5:	74 06                	je     80cabd <recv_udp+0x8b>
  80cab7:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80cabb:	75 0a                	jne    80cac7 <recv_udp+0x95>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80cabd:	89 3c 24             	mov    %edi,(%esp)
  80cac0:	e8 5f 87 ff ff       	call   805224 <pbuf_free>
    return;
  80cac5:	eb 6e                	jmp    80cb35 <recv_udp+0x103>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80cac7:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80cace:	e8 35 80 ff ff       	call   804b08 <memp_malloc>
  80cad3:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80cad5:	85 c0                	test   %eax,%eax
  80cad7:	75 0a                	jne    80cae3 <recv_udp+0xb1>
    pbuf_free(p);
  80cad9:	89 3c 24             	mov    %edi,(%esp)
  80cadc:	e8 43 87 ff ff       	call   805224 <pbuf_free>
    return;
  80cae1:	eb 52                	jmp    80cb35 <recv_udp+0x103>
  } else {
    buf->p = p;
  80cae3:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80cae5:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80cae8:	8b 45 14             	mov    0x14(%ebp),%eax
  80caeb:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80caee:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80caf2:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80caf6:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80cafa:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80cafe:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80cb01:	85 c0                	test   %eax,%eax
  80cb03:	74 15                	je     80cb1a <recv_udp+0xe8>
  80cb05:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80cb09:	89 54 24 08          	mov    %edx,0x8(%esp)
  80cb0d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80cb14:	00 
  80cb15:	89 1c 24             	mov    %ebx,(%esp)
  80cb18:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80cb1a:	89 74 24 04          	mov    %esi,0x4(%esp)
  80cb1e:	8b 43 14             	mov    0x14(%ebx),%eax
  80cb21:	89 04 24             	mov    %eax,(%esp)
  80cb24:	e8 e3 e2 ff ff       	call   80ae0c <sys_mbox_trypost>
  80cb29:	84 c0                	test   %al,%al
  80cb2b:	74 08                	je     80cb35 <recv_udp+0x103>
    netbuf_delete(buf);
  80cb2d:	89 34 24             	mov    %esi,(%esp)
  80cb30:	e8 c1 5e ff ff       	call   8029f6 <netbuf_delete>
    return;
  }
}
  80cb35:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80cb38:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80cb3b:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80cb3e:	89 ec                	mov    %ebp,%esp
  80cb40:	5d                   	pop    %ebp
  80cb41:	c3                   	ret    

0080cb42 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80cb42:	55                   	push   %ebp
  80cb43:	89 e5                	mov    %esp,%ebp
  80cb45:	53                   	push   %ebx
  80cb46:	83 ec 14             	sub    $0x14,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80cb49:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80cb50:	e8 b3 7f ff ff       	call   804b08 <memp_malloc>
  80cb55:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80cb57:	85 c0                	test   %eax,%eax
  80cb59:	0f 84 92 00 00 00    	je     80cbf1 <netconn_alloc+0xaf>
    return NULL;
  }

  conn->err = ERR_OK;
  80cb5f:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80cb63:	8b 45 08             	mov    0x8(%ebp),%eax
  80cb66:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80cb68:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80cb6f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80cb76:	e8 54 df ff ff       	call   80aacf <sys_sem_new>
  80cb7b:	89 43 10             	mov    %eax,0x10(%ebx)
  80cb7e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80cb81:	75 17                	jne    80cb9a <netconn_alloc+0x58>
    memp_free(MEMP_NETCONN, conn);
  80cb83:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80cb87:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80cb8e:	e8 31 7f ff ff       	call   804ac4 <memp_free>
  80cb93:	bb 00 00 00 00       	mov    $0x0,%ebx
    return NULL;
  80cb98:	eb 57                	jmp    80cbf1 <netconn_alloc+0xaf>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80cb9a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80cba1:	e8 b3 df ff ff       	call   80ab59 <sys_mbox_new>
  80cba6:	89 43 14             	mov    %eax,0x14(%ebx)
  80cba9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80cbac:	75 22                	jne    80cbd0 <netconn_alloc+0x8e>
    sys_sem_free(conn->op_completed);
  80cbae:	8b 43 10             	mov    0x10(%ebx),%eax
  80cbb1:	89 04 24             	mov    %eax,(%esp)
  80cbb4:	e8 b0 da ff ff       	call   80a669 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80cbb9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80cbbd:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80cbc4:	e8 fb 7e ff ff       	call   804ac4 <memp_free>
  80cbc9:	bb 00 00 00 00       	mov    $0x0,%ebx
    return NULL;
  80cbce:	eb 21                	jmp    80cbf1 <netconn_alloc+0xaf>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80cbd0:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80cbd7:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80cbde:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80cbe5:	8b 45 0c             	mov    0xc(%ebp),%eax
  80cbe8:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80cbeb:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80cbf1:	89 d8                	mov    %ebx,%eax
  80cbf3:	83 c4 14             	add    $0x14,%esp
  80cbf6:	5b                   	pop    %ebx
  80cbf7:	5d                   	pop    %ebp
  80cbf8:	c3                   	ret    

0080cbf9 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80cbf9:	55                   	push   %ebp
  80cbfa:	89 e5                	mov    %esp,%ebp
  80cbfc:	83 ec 28             	sub    $0x28,%esp
  80cbff:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80cc02:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80cc05:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80cc08:	0f b6 7d 10          	movzbl 0x10(%ebp),%edi
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  80cc0c:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80cc0f:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80cc13:	75 1c                	jne    80cc31 <accept_function+0x38>
  80cc15:	c7 44 24 08 94 31 81 	movl   $0x813194,0x8(%esp)
  80cc1c:	00 
  80cc1d:	c7 44 24 04 65 01 00 	movl   $0x165,0x4(%esp)
  80cc24:	00 
  80cc25:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80cc2c:	e8 bb 25 00 00       	call   80f1ec <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80cc31:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80cc34:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cc38:	8b 03                	mov    (%ebx),%eax
  80cc3a:	89 04 24             	mov    %eax,(%esp)
  80cc3d:	e8 00 ff ff ff       	call   80cb42 <netconn_alloc>
  80cc42:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80cc44:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80cc49:	85 f6                	test   %esi,%esi
  80cc4b:	74 55                	je     80cca2 <accept_function+0xa9>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80cc4d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80cc50:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80cc53:	89 f0                	mov    %esi,%eax
  80cc55:	e8 67 f1 ff ff       	call   80bdc1 <setup_tcp>
  newconn->err = err;
  80cc5a:	89 f8                	mov    %edi,%eax
  80cc5c:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80cc5f:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80cc62:	85 c0                	test   %eax,%eax
  80cc64:	74 15                	je     80cc7b <accept_function+0x82>
  80cc66:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80cc6d:	00 
  80cc6e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80cc75:	00 
  80cc76:	89 1c 24             	mov    %ebx,(%esp)
  80cc79:	ff d0                	call   *%eax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80cc7b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80cc7f:	8b 43 18             	mov    0x18(%ebx),%eax
  80cc82:	89 04 24             	mov    %eax,(%esp)
  80cc85:	e8 82 e1 ff ff       	call   80ae0c <sys_mbox_trypost>
  80cc8a:	84 c0                	test   %al,%al
  80cc8c:	74 14                	je     80cca2 <accept_function+0xa9>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80cc8e:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80cc95:	89 34 24             	mov    %esi,(%esp)
  80cc98:	e8 af fc ff ff       	call   80c94c <netconn_free>
  80cc9d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  return ERR_OK;
}
  80cca2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80cca5:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80cca8:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ccab:	89 ec                	mov    %ebp,%esp
  80ccad:	5d                   	pop    %ebp
  80ccae:	c3                   	ret    

0080ccaf <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80ccaf:	55                   	push   %ebp
  80ccb0:	89 e5                	mov    %esp,%ebp
  80ccb2:	83 ec 18             	sub    $0x18,%esp
  80ccb5:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80ccb8:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80ccbb:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80ccbe:	8b 03                	mov    (%ebx),%eax
  80ccc0:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80ccc4:	0f 85 dc 00 00 00    	jne    80cda6 <do_newconn+0xf7>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80ccca:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80ccce:	8b 33                	mov    (%ebx),%esi
  80ccd0:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80ccd4:	74 1c                	je     80ccf2 <do_newconn+0x43>
  80ccd6:	c7 44 24 08 c0 31 81 	movl   $0x8131c0,0x8(%esp)
  80ccdd:	00 
  80ccde:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80cce5:	00 
  80cce6:	c7 04 24 b1 2f 81 00 	movl   $0x812fb1,(%esp)
  80cced:	e8 fa 24 00 00       	call   80f1ec <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80ccf2:	8b 06                	mov    (%esi),%eax
  80ccf4:	25 f0 00 00 00       	and    $0xf0,%eax
  80ccf9:	83 f8 20             	cmp    $0x20,%eax
  80ccfc:	74 48                	je     80cd46 <do_newconn+0x97>
  80ccfe:	83 f8 40             	cmp    $0x40,%eax
  80cd01:	74 0f                	je     80cd12 <do_newconn+0x63>
  80cd03:	83 f8 10             	cmp    $0x10,%eax
  80cd06:	0f 85 96 00 00 00    	jne    80cda2 <do_newconn+0xf3>
  80cd0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80cd10:	eb 6f                	jmp    80cd81 <do_newconn+0xd2>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80cd12:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80cd16:	89 04 24             	mov    %eax,(%esp)
  80cd19:	e8 6d 1c 00 00       	call   80e98b <raw_new>
  80cd1e:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80cd21:	8b 03                	mov    (%ebx),%eax
  80cd23:	8b 50 08             	mov    0x8(%eax),%edx
  80cd26:	85 d2                	test   %edx,%edx
  80cd28:	75 06                	jne    80cd30 <do_newconn+0x81>
       msg->conn->err = ERR_MEM;
  80cd2a:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80cd2e:	eb 76                	jmp    80cda6 <do_newconn+0xf7>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80cd30:	89 44 24 08          	mov    %eax,0x8(%esp)
  80cd34:	c7 44 24 04 bd cd 80 	movl   $0x80cdbd,0x4(%esp)
  80cd3b:	00 
  80cd3c:	89 14 24             	mov    %edx,(%esp)
  80cd3f:	e8 33 1c 00 00       	call   80e977 <raw_recv>
  80cd44:	eb 60                	jmp    80cda6 <do_newconn+0xf7>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80cd46:	e8 84 c4 ff ff       	call   8091cf <udp_new>
  80cd4b:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80cd4e:	8b 03                	mov    (%ebx),%eax
  80cd50:	8b 50 08             	mov    0x8(%eax),%edx
  80cd53:	85 d2                	test   %edx,%edx
  80cd55:	75 06                	jne    80cd5d <do_newconn+0xae>
       msg->conn->err = ERR_MEM;
  80cd57:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80cd5b:	eb 49                	jmp    80cda6 <do_newconn+0xf7>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80cd5d:	83 38 22             	cmpl   $0x22,(%eax)
  80cd60:	75 04                	jne    80cd66 <do_newconn+0xb7>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80cd62:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80cd66:	8b 03                	mov    (%ebx),%eax
  80cd68:	89 44 24 08          	mov    %eax,0x8(%esp)
  80cd6c:	c7 44 24 04 32 ca 80 	movl   $0x80ca32,0x4(%esp)
  80cd73:	00 
  80cd74:	8b 40 08             	mov    0x8(%eax),%eax
  80cd77:	89 04 24             	mov    %eax,(%esp)
  80cd7a:	e8 3c c4 ff ff       	call   8091bb <udp_recv>
  80cd7f:	eb 25                	jmp    80cda6 <do_newconn+0xf7>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80cd81:	e8 cc 97 ff ff       	call   806552 <tcp_new>
  80cd86:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80cd89:	8b 03                	mov    (%ebx),%eax
  80cd8b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80cd8f:	75 06                	jne    80cd97 <do_newconn+0xe8>
       msg->conn->err = ERR_MEM;
  80cd91:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80cd95:	eb 0f                	jmp    80cda6 <do_newconn+0xf7>
       break;
     }
     setup_tcp(msg->conn);
  80cd97:	e8 25 f0 ff ff       	call   80bdc1 <setup_tcp>
  80cd9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80cda0:	eb 04                	jmp    80cda6 <do_newconn+0xf7>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80cda2:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80cda6:	8b 03                	mov    (%ebx),%eax
  80cda8:	8b 40 10             	mov    0x10(%eax),%eax
  80cdab:	89 04 24             	mov    %eax,(%esp)
  80cdae:	e8 be de ff ff       	call   80ac71 <sys_sem_signal>
}
  80cdb3:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80cdb6:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80cdb9:	89 ec                	mov    %ebp,%esp
  80cdbb:	5d                   	pop    %ebp
  80cdbc:	c3                   	ret    

0080cdbd <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80cdbd:	55                   	push   %ebp
  80cdbe:	89 e5                	mov    %esp,%ebp
  80cdc0:	83 ec 28             	sub    $0x28,%esp
  80cdc3:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80cdc6:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80cdc9:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80cdcc:	8b 7d 10             	mov    0x10(%ebp),%edi
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  80cdcf:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80cdd2:	85 db                	test   %ebx,%ebx
  80cdd4:	0f 84 b0 00 00 00    	je     80ce8a <recv_raw+0xcd>
  80cdda:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80cdde:	0f 84 a6 00 00 00    	je     80ce8a <recv_raw+0xcd>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80cde4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80cdeb:	00 
  80cdec:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80cdf0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cdf4:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80cdfb:	e8 df 86 ff ff       	call   8054df <pbuf_alloc>
  80ce00:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80ce02:	85 c0                	test   %eax,%eax
  80ce04:	0f 84 80 00 00 00    	je     80ce8a <recv_raw+0xcd>
      if (pbuf_copy(q, p) != ERR_OK) {
  80ce0a:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80ce0e:	89 04 24             	mov    %eax,(%esp)
  80ce11:	e8 6f 82 ff ff       	call   805085 <pbuf_copy>
  80ce16:	84 c0                	test   %al,%al
  80ce18:	0f 84 7e 00 00 00    	je     80ce9c <recv_raw+0xdf>
        pbuf_free(q);
  80ce1e:	89 34 24             	mov    %esi,(%esp)
  80ce21:	e8 fe 83 ff ff       	call   805224 <pbuf_free>
  80ce26:	eb 62                	jmp    80ce8a <recv_raw+0xcd>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80ce28:	89 34 24             	mov    %esi,(%esp)
  80ce2b:	e8 f4 83 ff ff       	call   805224 <pbuf_free>
        return 0;
  80ce30:	eb 58                	jmp    80ce8a <recv_raw+0xcd>
      }

      buf->p = q;
  80ce32:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80ce34:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80ce37:	8b 46 04             	mov    0x4(%esi),%eax
  80ce3a:	83 c0 0c             	add    $0xc,%eax
  80ce3d:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80ce40:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ce43:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80ce47:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80ce4b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80ce4f:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80ce53:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ce56:	85 c0                	test   %eax,%eax
  80ce58:	74 15                	je     80ce6f <recv_raw+0xb2>
  80ce5a:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80ce5e:	89 54 24 08          	mov    %edx,0x8(%esp)
  80ce62:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ce69:	00 
  80ce6a:	89 1c 24             	mov    %ebx,(%esp)
  80ce6d:	ff d0                	call   *%eax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80ce6f:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80ce73:	8b 43 14             	mov    0x14(%ebx),%eax
  80ce76:	89 04 24             	mov    %eax,(%esp)
  80ce79:	e8 8e df ff ff       	call   80ae0c <sys_mbox_trypost>
  80ce7e:	84 c0                	test   %al,%al
  80ce80:	74 08                	je     80ce8a <recv_raw+0xcd>
        netbuf_delete(buf);
  80ce82:	89 3c 24             	mov    %edi,(%esp)
  80ce85:	e8 6c 5b ff ff       	call   8029f6 <netbuf_delete>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80ce8a:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce8f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ce92:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ce95:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ce98:	89 ec                	mov    %ebp,%esp
  80ce9a:	5d                   	pop    %ebp
  80ce9b:	c3                   	ret    
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80ce9c:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80cea3:	e8 60 7c ff ff       	call   804b08 <memp_malloc>
  80cea8:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80ceaa:	85 c0                	test   %eax,%eax
  80ceac:	75 84                	jne    80ce32 <recv_raw+0x75>
  80ceae:	e9 75 ff ff ff       	jmp    80ce28 <recv_raw+0x6b>
	...

0080cec0 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80cec0:	55                   	push   %ebp
  80cec1:	89 e5                	mov    %esp,%ebp
  80cec3:	57                   	push   %edi
  80cec4:	56                   	push   %esi
  80cec5:	53                   	push   %ebx
  80cec6:	83 ec 1c             	sub    $0x1c,%esp
  80cec9:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80cecb:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80ced0:	8d 70 14             	lea    0x14(%eax),%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80ced3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ced7:	89 04 24             	mov    %eax,(%esp)
  80ceda:	e8 8d af ff ff       	call   807e6c <ntohs>
  80cedf:	66 c1 e8 0c          	shr    $0xc,%ax
  80cee3:	bb 00 00 00 00       	mov    $0x0,%ebx
  80cee8:	66 83 f8 05          	cmp    $0x5,%ax
  80ceec:	77 51                	ja     80cf3f <tcp_parseopt+0x7f>
  80ceee:	eb 75                	jmp    80cf65 <tcp_parseopt+0xa5>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80cef0:	0f b6 d3             	movzbl %bl,%edx
  80cef3:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80cef7:	84 c0                	test   %al,%al
  80cef9:	74 6a                	je     80cf65 <tcp_parseopt+0xa5>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80cefb:	3c 01                	cmp    $0x1,%al
  80cefd:	75 05                	jne    80cf04 <tcp_parseopt+0x44>
        ++c;
  80ceff:	83 c3 01             	add    $0x1,%ebx
  80cf02:	eb 3b                	jmp    80cf3f <tcp_parseopt+0x7f>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80cf04:	3c 02                	cmp    $0x2,%al
  80cf06:	75 2c                	jne    80cf34 <tcp_parseopt+0x74>
  80cf08:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80cf0d:	75 25                	jne    80cf34 <tcp_parseopt+0x74>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80cf0f:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80cf14:	c1 e0 08             	shl    $0x8,%eax
  80cf17:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80cf1c:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80cf1e:	8d 50 ff             	lea    -0x1(%eax),%edx
  80cf21:	66 81 fa b4 05       	cmp    $0x5b4,%dx
  80cf26:	ba b4 05 00 00       	mov    $0x5b4,%edx
  80cf2b:	0f 43 c2             	cmovae %edx,%eax
  80cf2e:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80cf32:	eb 31                	jmp    80cf65 <tcp_parseopt+0xa5>
      } else {
        if (opts[c + 1] == 0) {
  80cf34:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80cf39:	84 c0                	test   %al,%al
  80cf3b:	74 28                	je     80cf65 <tcp_parseopt+0xa5>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80cf3d:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80cf3f:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80cf44:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf48:	89 04 24             	mov    %eax,(%esp)
  80cf4b:	e8 1c af ff ff       	call   807e6c <ntohs>
  80cf50:	0f b6 d3             	movzbl %bl,%edx
  80cf53:	66 c1 e8 0c          	shr    $0xc,%ax
  80cf57:	0f b7 c0             	movzwl %ax,%eax
  80cf5a:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80cf61:	39 c2                	cmp    %eax,%edx
  80cf63:	7c 8b                	jl     80cef0 <tcp_parseopt+0x30>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80cf65:	83 c4 1c             	add    $0x1c,%esp
  80cf68:	5b                   	pop    %ebx
  80cf69:	5e                   	pop    %esi
  80cf6a:	5f                   	pop    %edi
  80cf6b:	5d                   	pop    %ebp
  80cf6c:	c3                   	ret    

0080cf6d <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80cf6d:	55                   	push   %ebp
  80cf6e:	89 e5                	mov    %esp,%ebp
  80cf70:	57                   	push   %edi
  80cf71:	56                   	push   %esi
  80cf72:	53                   	push   %ebx
  80cf73:	83 ec 2c             	sub    $0x2c,%esp
  80cf76:	89 c3                	mov    %eax,%ebx
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80cf78:	f6 05 c0 b1 b3 00 10 	testb  $0x10,0xb3b1c0
  80cf7f:	0f 84 69 04 00 00    	je     80d3ee <tcp_receive+0x481>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80cf85:	0f b7 70 5c          	movzwl 0x5c(%eax),%esi
  80cf89:	8b 50 60             	mov    0x60(%eax),%edx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80cf8c:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80cf91:	39 c2                	cmp    %eax,%edx
  80cf93:	78 24                	js     80cfb9 <tcp_receive+0x4c>
  80cf95:	39 c2                	cmp    %eax,%edx
  80cf97:	75 0a                	jne    80cfa3 <tcp_receive+0x36>
  80cf99:	a1 bc b1 b3 00       	mov    0xb3b1bc,%eax
  80cf9e:	39 43 64             	cmp    %eax,0x64(%ebx)
  80cfa1:	78 16                	js     80cfb9 <tcp_receive+0x4c>
  80cfa3:	8b 43 64             	mov    0x64(%ebx),%eax
  80cfa6:	3b 05 bc b1 b3 00    	cmp    0xb3b1bc,%eax
  80cfac:	75 3f                	jne    80cfed <tcp_receive+0x80>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80cfae:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80cfb3:	66 3b 70 0e          	cmp    0xe(%eax),%si
  80cfb7:	73 34                	jae    80cfed <tcp_receive+0x80>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
  80cfb9:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80cfbe:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  80cfc2:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
      pcb->snd_wl1 = seqno;
  80cfc6:	8b 0d b8 b1 b3 00    	mov    0xb3b1b8,%ecx
  80cfcc:	89 4b 60             	mov    %ecx,0x60(%ebx)
      pcb->snd_wl2 = ackno;
  80cfcf:	8b 0d bc b1 b3 00    	mov    0xb3b1bc,%ecx
  80cfd5:	89 4b 64             	mov    %ecx,0x64(%ebx)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80cfd8:	66 85 c0             	test   %ax,%ax
  80cfdb:	74 10                	je     80cfed <tcp_receive+0x80>
  80cfdd:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  80cfe4:	74 07                	je     80cfed <tcp_receive+0x80>
          pcb->persist_backoff = 0;
  80cfe6:	c6 83 a4 00 00 00 00 	movb   $0x0,0xa4(%ebx)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80cfed:	8b 4b 48             	mov    0x48(%ebx),%ecx
  80cff0:	a1 bc b1 b3 00       	mov    0xb3b1bc,%eax
  80cff5:	39 c1                	cmp    %eax,%ecx
  80cff7:	0f 85 ab 00 00 00    	jne    80d0a8 <tcp_receive+0x13b>
      pcb->acked = 0;
  80cffd:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80d003:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  80d007:	03 43 60             	add    0x60(%ebx),%eax
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80d00a:	0f b7 f6             	movzwl %si,%esi
  80d00d:	8d 14 16             	lea    (%esi,%edx,1),%edx
    }

    if (pcb->lastack == ackno) {
      pcb->acked = 0;

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80d010:	39 d0                	cmp    %edx,%eax
  80d012:	0f 85 fb 02 00 00    	jne    80d313 <tcp_receive+0x3a6>
        ++pcb->dupacks;
  80d018:	0f b6 43 4c          	movzbl 0x4c(%ebx),%eax
  80d01c:	83 c0 01             	add    $0x1,%eax
  80d01f:	88 43 4c             	mov    %al,0x4c(%ebx)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80d022:	3c 02                	cmp    $0x2,%al
  80d024:	0f 86 e9 02 00 00    	jbe    80d313 <tcp_receive+0x3a6>
  80d02a:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80d02e:	0f 84 df 02 00 00    	je     80d313 <tcp_receive+0x3a6>
          if (!(pcb->flags & TF_INFR)) {
  80d034:	f6 43 20 04          	testb  $0x4,0x20(%ebx)
  80d038:	75 52                	jne    80d08c <tcp_receive+0x11f>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80d03a:	89 1c 24             	mov    %ebx,(%esp)
  80d03d:	e8 21 b9 ff ff       	call   808963 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80d042:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  80d046:	0f b7 53 5c          	movzwl 0x5c(%ebx),%edx
  80d04a:	66 39 d0             	cmp    %dx,%ax
  80d04d:	76 09                	jbe    80d058 <tcp_receive+0xeb>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80d04f:	66 d1 ea             	shr    %dx
  80d052:	66 89 53 50          	mov    %dx,0x50(%ebx)
  80d056:	eb 07                	jmp    80d05f <tcp_receive+0xf2>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80d058:	66 d1 e8             	shr    %ax
  80d05b:	66 89 43 50          	mov    %ax,0x50(%ebx)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80d05f:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d063:	0f b7 4b 50          	movzwl 0x50(%ebx),%ecx
  80d067:	0f b7 d0             	movzwl %ax,%edx
  80d06a:	01 d2                	add    %edx,%edx
  80d06c:	39 d1                	cmp    %edx,%ecx
  80d06e:	7d 06                	jge    80d076 <tcp_receive+0x109>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80d070:	01 c0                	add    %eax,%eax
  80d072:	66 89 43 50          	mov    %ax,0x50(%ebx)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80d076:	66 6b 43 34 03       	imul   $0x3,0x34(%ebx),%ax
  80d07b:	66 03 43 50          	add    0x50(%ebx),%ax
  80d07f:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
            pcb->flags |= TF_INFR;
  80d083:	80 4b 20 04          	orb    $0x4,0x20(%ebx)
  80d087:	e9 87 02 00 00       	jmp    80d313 <tcp_receive+0x3a6>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80d08c:	0f b7 53 4e          	movzwl 0x4e(%ebx),%edx
  80d090:	89 d0                	mov    %edx,%eax
  80d092:	66 03 43 34          	add    0x34(%ebx),%ax
  80d096:	66 39 c2             	cmp    %ax,%dx
  80d099:	0f 83 74 02 00 00    	jae    80d313 <tcp_receive+0x3a6>
              pcb->cwnd += pcb->mss;
  80d09f:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80d0a3:	e9 6b 02 00 00       	jmp    80d313 <tcp_receive+0x3a6>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80d0a8:	f7 d1                	not    %ecx
  80d0aa:	01 c1                	add    %eax,%ecx
  80d0ac:	0f 88 b2 01 00 00    	js     80d264 <tcp_receive+0x2f7>
  80d0b2:	2b 43 58             	sub    0x58(%ebx),%eax
  80d0b5:	85 c0                	test   %eax,%eax
  80d0b7:	0f 8f a7 01 00 00    	jg     80d264 <tcp_receive+0x2f7>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80d0bd:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  80d0c1:	a8 04                	test   $0x4,%al
  80d0c3:	74 0e                	je     80d0d3 <tcp_receive+0x166>
        pcb->flags &= ~TF_INFR;
  80d0c5:	83 e0 fb             	and    $0xfffffffb,%eax
  80d0c8:	88 43 20             	mov    %al,0x20(%ebx)
        pcb->cwnd = pcb->ssthresh;
  80d0cb:	0f b7 43 50          	movzwl 0x50(%ebx),%eax
  80d0cf:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80d0d3:	c6 43 46 00          	movb   $0x0,0x46(%ebx)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80d0d7:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  80d0db:	66 c1 f8 03          	sar    $0x3,%ax
  80d0df:	66 03 43 42          	add    0x42(%ebx),%ax
  80d0e3:	66 89 43 44          	mov    %ax,0x44(%ebx)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80d0e7:	a1 bc b1 b3 00       	mov    0xb3b1bc,%eax
  80d0ec:	66 2b 43 48          	sub    0x48(%ebx),%ax
  80d0f0:	66 89 43 6c          	mov    %ax,0x6c(%ebx)

      pcb->snd_buf += pcb->acked;
  80d0f4:	66 01 43 6e          	add    %ax,0x6e(%ebx)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80d0f8:	c6 43 4c 00          	movb   $0x0,0x4c(%ebx)
      pcb->lastack = ackno;
  80d0fc:	a1 bc b1 b3 00       	mov    0xb3b1bc,%eax
  80d101:	89 43 48             	mov    %eax,0x48(%ebx)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80d104:	83 7b 10 03          	cmpl   $0x3,0x10(%ebx)
  80d108:	0f 86 d3 00 00 00    	jbe    80d1e1 <tcp_receive+0x274>
        if (pcb->cwnd < pcb->ssthresh) {
  80d10e:	0f b7 4b 4e          	movzwl 0x4e(%ebx),%ecx
  80d112:	66 3b 4b 50          	cmp    0x50(%ebx),%cx
  80d116:	73 18                	jae    80d130 <tcp_receive+0x1c3>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80d118:	89 c8                	mov    %ecx,%eax
  80d11a:	66 03 43 34          	add    0x34(%ebx),%ax
  80d11e:	66 39 c1             	cmp    %ax,%cx
  80d121:	0f 83 ba 00 00 00    	jae    80d1e1 <tcp_receive+0x274>
            pcb->cwnd += pcb->mss;
  80d127:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80d12b:	e9 b1 00 00 00       	jmp    80d1e1 <tcp_receive+0x274>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80d130:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80d134:	0f af d2             	imul   %edx,%edx
  80d137:	0f b7 f1             	movzwl %cx,%esi
  80d13a:	89 d0                	mov    %edx,%eax
  80d13c:	c1 fa 1f             	sar    $0x1f,%edx
  80d13f:	f7 fe                	idiv   %esi
  80d141:	8d 04 01             	lea    (%ecx,%eax,1),%eax
          if (new_cwnd > pcb->cwnd) {
  80d144:	66 39 c1             	cmp    %ax,%cx
  80d147:	0f 83 94 00 00 00    	jae    80d1e1 <tcp_receive+0x274>
            pcb->cwnd = new_cwnd;
  80d14d:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80d151:	e9 8b 00 00 00       	jmp    80d1e1 <tcp_receive+0x274>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80d156:	8b 73 78             	mov    0x78(%ebx),%esi
        pcb->unacked = pcb->unacked->next;
  80d159:	8b 06                	mov    (%esi),%eax
  80d15b:	89 43 78             	mov    %eax,0x78(%ebx)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80d15e:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  80d162:	8b 46 04             	mov    0x4(%esi),%eax
  80d165:	89 04 24             	mov    %eax,(%esp)
  80d168:	e8 73 7c ff ff       	call   804de0 <pbuf_clen>
  80d16d:	0f b6 c0             	movzbl %al,%eax
  80d170:	66 39 c7             	cmp    %ax,%di
  80d173:	73 1c                	jae    80d191 <tcp_receive+0x224>
  80d175:	c7 44 24 08 e0 31 81 	movl   $0x8131e0,0x8(%esp)
  80d17c:	00 
  80d17d:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
  80d184:	00 
  80d185:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80d18c:	e8 5b 20 00 00       	call   80f1ec <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80d191:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  80d195:	8b 46 04             	mov    0x4(%esi),%eax
  80d198:	89 04 24             	mov    %eax,(%esp)
  80d19b:	e8 40 7c ff ff       	call   804de0 <pbuf_clen>
  80d1a0:	0f b6 c0             	movzbl %al,%eax
  80d1a3:	66 29 c7             	sub    %ax,%di
  80d1a6:	66 89 7b 70          	mov    %di,0x70(%ebx)
        tcp_seg_free(next);
  80d1aa:	89 34 24             	mov    %esi,(%esp)
  80d1ad:	e8 70 8b ff ff       	call   805d22 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80d1b2:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  80d1b7:	74 28                	je     80d1e1 <tcp_receive+0x274>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80d1b9:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80d1bd:	75 22                	jne    80d1e1 <tcp_receive+0x274>
  80d1bf:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  80d1c3:	75 1c                	jne    80d1e1 <tcp_receive+0x274>
  80d1c5:	c7 44 24 08 08 32 81 	movl   $0x813208,0x8(%esp)
  80d1cc:	00 
  80d1cd:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
  80d1d4:	00 
  80d1d5:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80d1dc:	e8 0b 20 00 00       	call   80f1ec <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80d1e1:	8b 43 78             	mov    0x78(%ebx),%eax
  80d1e4:	85 c0                	test   %eax,%eax
  80d1e6:	74 65                	je     80d24d <tcp_receive+0x2e0>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80d1e8:	8b 40 10             	mov    0x10(%eax),%eax
  80d1eb:	8b 40 04             	mov    0x4(%eax),%eax
  80d1ee:	89 04 24             	mov    %eax,(%esp)
  80d1f1:	e8 96 ae ff ff       	call   80808c <ntohl>
  80d1f6:	89 c6                	mov    %eax,%esi
  80d1f8:	8b 43 78             	mov    0x78(%ebx),%eax
  80d1fb:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80d1ff:	8b 40 10             	mov    0x10(%eax),%eax
  80d202:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d206:	89 04 24             	mov    %eax,(%esp)
  80d209:	e8 5e ac ff ff       	call   807e6c <ntohs>
  80d20e:	a8 01                	test   $0x1,%al
  80d210:	75 1b                	jne    80d22d <tcp_receive+0x2c0>
  80d212:	8b 43 78             	mov    0x78(%ebx),%eax
  80d215:	8b 40 10             	mov    0x10(%eax),%eax
  80d218:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d21c:	89 04 24             	mov    %eax,(%esp)
  80d21f:	e8 48 ac ff ff       	call   807e6c <ntohs>
  80d224:	ba 00 00 00 00       	mov    $0x0,%edx
  80d229:	a8 02                	test   $0x2,%al
  80d22b:	74 05                	je     80d232 <tcp_receive+0x2c5>
  80d22d:	ba 01 00 00 00       	mov    $0x1,%edx
  80d232:	2b 35 bc b1 b3 00    	sub    0xb3b1bc,%esi
  80d238:	0f b7 ff             	movzwl %di,%edi
  80d23b:	01 fa                	add    %edi,%edx
  80d23d:	01 d6                	add    %edx,%esi
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80d23f:	85 f6                	test   %esi,%esi
  80d241:	0f 8e 0f ff ff ff    	jle    80d156 <tcp_receive+0x1e9>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80d247:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80d24b:	75 08                	jne    80d255 <tcp_receive+0x2e8>
        pcb->rtime = -1;
  80d24d:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80d253:	eb 06                	jmp    80d25b <tcp_receive+0x2ee>
      else
        pcb->rtime = 0;
  80d255:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

      pcb->polltmr = 0;
  80d25b:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80d25f:	e9 af 00 00 00       	jmp    80d313 <tcp_receive+0x3a6>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80d264:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)
  80d26a:	e9 a4 00 00 00       	jmp    80d313 <tcp_receive+0x3a6>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80d26f:	8b 73 74             	mov    0x74(%ebx),%esi
      pcb->unsent = pcb->unsent->next;
  80d272:	8b 06                	mov    (%esi),%eax
  80d274:	89 43 74             	mov    %eax,0x74(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80d277:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  80d27b:	8b 46 04             	mov    0x4(%esi),%eax
  80d27e:	89 04 24             	mov    %eax,(%esp)
  80d281:	e8 5a 7b ff ff       	call   804de0 <pbuf_clen>
  80d286:	0f b6 c0             	movzbl %al,%eax
  80d289:	66 39 c7             	cmp    %ax,%di
  80d28c:	73 1c                	jae    80d2aa <tcp_receive+0x33d>
  80d28e:	c7 44 24 08 e0 31 81 	movl   $0x8131e0,0x8(%esp)
  80d295:	00 
  80d296:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
  80d29d:	00 
  80d29e:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80d2a5:	e8 42 1f 00 00       	call   80f1ec <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80d2aa:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  80d2ae:	8b 46 04             	mov    0x4(%esi),%eax
  80d2b1:	89 04 24             	mov    %eax,(%esp)
  80d2b4:	e8 27 7b ff ff       	call   804de0 <pbuf_clen>
  80d2b9:	0f b6 c0             	movzbl %al,%eax
  80d2bc:	66 29 c7             	sub    %ax,%di
  80d2bf:	66 89 7b 70          	mov    %di,0x70(%ebx)
      tcp_seg_free(next);
  80d2c3:	89 34 24             	mov    %esi,(%esp)
  80d2c6:	e8 57 8a ff ff       	call   805d22 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80d2cb:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  80d2d0:	74 29                	je     80d2fb <tcp_receive+0x38e>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80d2d2:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80d2d6:	75 23                	jne    80d2fb <tcp_receive+0x38e>
  80d2d8:	8b 43 74             	mov    0x74(%ebx),%eax
  80d2db:	85 c0                	test   %eax,%eax
  80d2dd:	75 23                	jne    80d302 <tcp_receive+0x395>
  80d2df:	c7 44 24 08 08 32 81 	movl   $0x813208,0x8(%esp)
  80d2e6:	00 
  80d2e7:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
  80d2ee:	00 
  80d2ef:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80d2f6:	e8 f1 1e 00 00       	call   80f1ec <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80d2fb:	8b 43 74             	mov    0x74(%ebx),%eax
  80d2fe:	85 c0                	test   %eax,%eax
  80d300:	74 11                	je     80d313 <tcp_receive+0x3a6>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80d302:	8b 40 10             	mov    0x10(%eax),%eax
  80d305:	8b 40 04             	mov    0x4(%eax),%eax
  80d308:	89 04 24             	mov    %eax,(%esp)
  80d30b:	e8 70 ab ff ff       	call   807e80 <htonl>
  80d310:	89 43 54             	mov    %eax,0x54(%ebx)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80d313:	8b 43 74             	mov    0x74(%ebx),%eax
  80d316:	85 c0                	test   %eax,%eax
  80d318:	74 70                	je     80d38a <tcp_receive+0x41d>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80d31a:	8b 35 bc b1 b3 00    	mov    0xb3b1bc,%esi
  80d320:	8b 40 10             	mov    0x10(%eax),%eax
  80d323:	8b 40 04             	mov    0x4(%eax),%eax
  80d326:	89 04 24             	mov    %eax,(%esp)
  80d329:	e8 5e ad ff ff       	call   80808c <ntohl>
  80d32e:	89 c7                	mov    %eax,%edi
  80d330:	8b 43 74             	mov    0x74(%ebx),%eax
  80d333:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  80d337:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  80d33b:	8b 40 10             	mov    0x10(%eax),%eax
  80d33e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d342:	89 04 24             	mov    %eax,(%esp)
  80d345:	e8 22 ab ff ff       	call   807e6c <ntohs>
  80d34a:	a8 01                	test   $0x1,%al
  80d34c:	75 1b                	jne    80d369 <tcp_receive+0x3fc>
  80d34e:	8b 43 74             	mov    0x74(%ebx),%eax
  80d351:	8b 40 10             	mov    0x10(%eax),%eax
  80d354:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d358:	89 04 24             	mov    %eax,(%esp)
  80d35b:	e8 0c ab ff ff       	call   807e6c <ntohs>
  80d360:	ba 00 00 00 00       	mov    $0x0,%edx
  80d365:	a8 02                	test   $0x2,%al
  80d367:	74 05                	je     80d36e <tcp_receive+0x401>
  80d369:	ba 01 00 00 00       	mov    $0x1,%edx
  80d36e:	29 fe                	sub    %edi,%esi
  80d370:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80d374:	01 c2                	add    %eax,%edx
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80d376:	39 d6                	cmp    %edx,%esi
  80d378:	78 10                	js     80d38a <tcp_receive+0x41d>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80d37a:	a1 bc b1 b3 00       	mov    0xb3b1bc,%eax
  80d37f:	2b 43 58             	sub    0x58(%ebx),%eax
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80d382:	85 c0                	test   %eax,%eax
  80d384:	0f 8e e5 fe ff ff    	jle    80d26f <tcp_receive+0x302>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80d38a:	8b 43 38             	mov    0x38(%ebx),%eax
  80d38d:	85 c0                	test   %eax,%eax
  80d38f:	74 5d                	je     80d3ee <tcp_receive+0x481>
  80d391:	8b 35 bc b1 b3 00    	mov    0xb3b1bc,%esi
  80d397:	39 73 3c             	cmp    %esi,0x3c(%ebx)
  80d39a:	79 52                	jns    80d3ee <tcp_receive+0x481>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80d39c:	0f b7 53 40          	movzwl 0x40(%ebx),%edx
  80d3a0:	8b 0d 40 b2 b3 00    	mov    0xb3b240,%ecx
  80d3a6:	66 29 c1             	sub    %ax,%cx
  80d3a9:	89 c8                	mov    %ecx,%eax
  80d3ab:	89 d1                	mov    %edx,%ecx
  80d3ad:	66 c1 f9 03          	sar    $0x3,%cx
  80d3b1:	66 29 c8             	sub    %cx,%ax
      pcb->sa += m;
  80d3b4:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80d3b7:	66 89 53 40          	mov    %dx,0x40(%ebx)
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
  80d3bb:	0f b7 4b 42          	movzwl 0x42(%ebx),%ecx
      pcb->sv += m;
  80d3bf:	89 ce                	mov    %ecx,%esi
  80d3c1:	66 c1 fe 02          	sar    $0x2,%si
  80d3c5:	66 29 f1             	sub    %si,%cx
  80d3c8:	89 ce                	mov    %ecx,%esi
  80d3ca:	89 c1                	mov    %eax,%ecx
  80d3cc:	66 c1 f9 0f          	sar    $0xf,%cx
  80d3d0:	31 c8                	xor    %ecx,%eax
  80d3d2:	66 29 c8             	sub    %cx,%ax
  80d3d5:	8d 04 06             	lea    (%esi,%eax,1),%eax
  80d3d8:	66 89 43 42          	mov    %ax,0x42(%ebx)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80d3dc:	66 c1 fa 03          	sar    $0x3,%dx
  80d3e0:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80d3e3:	66 89 43 44          	mov    %ax,0x44(%ebx)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80d3e7:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80d3ee:	0f b7 0d c2 b1 b3 00 	movzwl 0xb3b1c2,%ecx
  80d3f5:	66 85 c9             	test   %cx,%cx
  80d3f8:	0f 84 6b 07 00 00    	je     80db69 <tcp_receive+0xbfc>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80d3fe:	8b 53 24             	mov    0x24(%ebx),%edx
  80d401:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80d406:	89 c6                	mov    %eax,%esi
  80d408:	f7 d6                	not    %esi
  80d40a:	01 d6                	add    %edx,%esi
  80d40c:	0f 88 3a 01 00 00    	js     80d54c <tcp_receive+0x5df>
  80d412:	8d 7a 01             	lea    0x1(%edx),%edi
  80d415:	29 c7                	sub    %eax,%edi
  80d417:	0f b7 f1             	movzwl %cx,%esi
  80d41a:	89 f9                	mov    %edi,%ecx
  80d41c:	29 f1                	sub    %esi,%ecx
  80d41e:	85 c9                	test   %ecx,%ecx
  80d420:	0f 8f 26 01 00 00    	jg     80d54c <tcp_receive+0x5df>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
  80d426:	8b 35 a0 b1 b3 00    	mov    0xb3b1a0,%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80d42c:	85 f6                	test   %esi,%esi
  80d42e:	75 1c                	jne    80d44c <tcp_receive+0x4df>
  80d430:	c7 44 24 08 63 33 81 	movl   $0x813363,0x8(%esp)
  80d437:	00 
  80d438:	c7 44 24 04 e5 03 00 	movl   $0x3e5,0x4(%esp)
  80d43f:	00 
  80d440:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80d447:	e8 a0 1d 00 00       	call   80f1ec <_panic>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80d44c:	29 c2                	sub    %eax,%edx
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80d44e:	81 fa fe 7f 00 00    	cmp    $0x7ffe,%edx
  80d454:	7e 1c                	jle    80d472 <tcp_receive+0x505>
  80d456:	c7 44 24 08 73 33 81 	movl   $0x813373,0x8(%esp)
  80d45d:	00 
  80d45e:	c7 44 24 04 e6 03 00 	movl   $0x3e6,0x4(%esp)
  80d465:	00 
  80d466:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80d46d:	e8 7a 1d 00 00       	call   80f1ec <_panic>
      if (inseg.p->len < off) {
  80d472:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80d476:	39 c2                	cmp    %eax,%edx
  80d478:	7e 71                	jle    80d4eb <tcp_receive+0x57e>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80d47a:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  80d47e:	0f b7 f9             	movzwl %cx,%edi
  80d481:	39 fa                	cmp    %edi,%edx
  80d483:	7e 1c                	jle    80d4a1 <tcp_receive+0x534>
  80d485:	c7 44 24 08 82 33 81 	movl   $0x813382,0x8(%esp)
  80d48c:	00 
  80d48d:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  80d494:	00 
  80d495:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80d49c:	e8 4b 1d 00 00       	call   80f1ec <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80d4a1:	66 29 d1             	sub    %dx,%cx
        while (p->len < off) {
          off -= p->len;
  80d4a4:	29 c2                	sub    %eax,%edx
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  80d4a6:	66 89 4e 08          	mov    %cx,0x8(%esi)
          p->len = 0;
  80d4aa:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
          p = p->next;
  80d4b0:	8b 36                	mov    (%esi),%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  80d4b2:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80d4b6:	39 d0                	cmp    %edx,%eax
  80d4b8:	7c ea                	jl     80d4a4 <tcp_receive+0x537>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  80d4ba:	f7 da                	neg    %edx
  80d4bc:	0f bf c2             	movswl %dx,%eax
  80d4bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d4c3:	89 34 24             	mov    %esi,(%esp)
  80d4c6:	e8 fc 79 ff ff       	call   804ec7 <pbuf_header>
  80d4cb:	84 c0                	test   %al,%al
  80d4cd:	74 4d                	je     80d51c <tcp_receive+0x5af>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80d4cf:	c7 44 24 08 92 33 81 	movl   $0x813392,0x8(%esp)
  80d4d6:	00 
  80d4d7:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp)
  80d4de:	00 
  80d4df:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80d4e6:	e8 01 1d 00 00       	call   80f1ec <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80d4eb:	f7 da                	neg    %edx
  80d4ed:	0f bf c2             	movswl %dx,%eax
  80d4f0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d4f4:	89 34 24             	mov    %esi,(%esp)
  80d4f7:	e8 cb 79 ff ff       	call   804ec7 <pbuf_header>
  80d4fc:	84 c0                	test   %al,%al
  80d4fe:	74 1c                	je     80d51c <tcp_receive+0x5af>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80d500:	c7 44 24 08 92 33 81 	movl   $0x813392,0x8(%esp)
  80d507:	00 
  80d508:	c7 44 24 04 fa 03 00 	movl   $0x3fa,0x4(%esp)
  80d50f:	00 
  80d510:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80d517:	e8 d0 1c 00 00       	call   80f1ec <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  80d51c:	8b 46 04             	mov    0x4(%esi),%eax
  80d51f:	a3 a4 b1 b3 00       	mov    %eax,0xb3b1a4
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80d524:	b8 a8 b1 b3 00       	mov    $0xb3b1a8,%eax
  80d529:	8b 15 b8 b1 b3 00    	mov    0xb3b1b8,%edx
  80d52f:	66 03 10             	add    (%eax),%dx
  80d532:	66 2b 53 24          	sub    0x24(%ebx),%dx
  80d536:	66 89 10             	mov    %dx,(%eax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80d539:	8b 43 24             	mov    0x24(%ebx),%eax
  80d53c:	a3 b8 b1 b3 00       	mov    %eax,0xb3b1b8
  80d541:	8b 15 ac b1 b3 00    	mov    0xb3b1ac,%edx
  80d547:	89 42 04             	mov    %eax,0x4(%edx)
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80d54a:	eb 10                	jmp    80d55c <tcp_receive+0x5ef>
      inseg.dataptr = p->payload;
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80d54c:	39 d0                	cmp    %edx,%eax
  80d54e:	79 1c                	jns    80d56c <tcp_receive+0x5ff>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  80d550:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d554:	89 1c 24             	mov    %ebx,(%esp)
  80d557:	e8 6f af ff ff       	call   8084cb <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d55c:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80d561:	8b 53 24             	mov    0x24(%ebx),%edx
  80d564:	39 d0                	cmp    %edx,%eax
  80d566:	0f 88 ea 05 00 00    	js     80db56 <tcp_receive+0xbe9>
  80d56c:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d570:	89 c7                	mov    %eax,%edi
  80d572:	29 cf                	sub    %ecx,%edi
  80d574:	8d 4f 01             	lea    0x1(%edi),%ecx
  80d577:	29 d1                	sub    %edx,%ecx
  80d579:	85 c9                	test   %ecx,%ecx
  80d57b:	0f 8f d5 05 00 00    	jg     80db56 <tcp_receive+0xbe9>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  80d581:	39 d0                	cmp    %edx,%eax
  80d583:	0f 85 88 03 00 00    	jne    80d911 <tcp_receive+0x9a4>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80d589:	8b 53 7c             	mov    0x7c(%ebx),%edx
  80d58c:	85 d2                	test   %edx,%edx
  80d58e:	0f 84 86 00 00 00    	je     80d61a <tcp_receive+0x6ad>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80d594:	8b 4a 10             	mov    0x10(%edx),%ecx
  80d597:	8b 49 04             	mov    0x4(%ecx),%ecx
  80d59a:	0f b7 35 a8 b1 b3 00 	movzwl 0xb3b1a8,%esi
  80d5a1:	89 cf                	mov    %ecx,%edi
  80d5a3:	29 f7                	sub    %esi,%edi
  80d5a5:	89 fe                	mov    %edi,%esi
  80d5a7:	29 c6                	sub    %eax,%esi
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80d5a9:	85 f6                	test   %esi,%esi
  80d5ab:	7f 6d                	jg     80d61a <tcp_receive+0x6ad>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  80d5ad:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  80d5b2:	74 20                	je     80d5d4 <tcp_receive+0x667>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80d5b4:	66 29 c1             	sub    %ax,%cx
  80d5b7:	66 89 0d a8 b1 b3 00 	mov    %cx,0xb3b1a8
            pbuf_realloc(inseg.p, inseg.len);
  80d5be:	0f b7 c1             	movzwl %cx,%eax
  80d5c1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d5c5:	a1 a0 b1 b3 00       	mov    0xb3b1a0,%eax
  80d5ca:	89 04 24             	mov    %eax,(%esp)
  80d5cd:	e8 db 7d ff ff       	call   8053ad <pbuf_realloc>
  80d5d2:	eb 46                	jmp    80d61a <tcp_receive+0x6ad>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80d5d4:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d5d9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5dd:	89 04 24             	mov    %eax,(%esp)
  80d5e0:	e8 87 a8 ff ff       	call   807e6c <ntohs>
  80d5e5:	89 c6                	mov    %eax,%esi
  80d5e7:	8b 43 7c             	mov    0x7c(%ebx),%eax
  80d5ea:	8b 40 10             	mov    0x10(%eax),%eax
  80d5ed:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5f1:	89 04 24             	mov    %eax,(%esp)
  80d5f4:	e8 73 a8 ff ff       	call   807e6c <ntohs>
  80d5f9:	31 c6                	xor    %eax,%esi
  80d5fb:	66 f7 c6 03 00       	test   $0x3,%si
  80d600:	75 18                	jne    80d61a <tcp_receive+0x6ad>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80d602:	8b 43 7c             	mov    0x7c(%ebx),%eax
              pcb->ooseq = pcb->ooseq->next;
  80d605:	8b 10                	mov    (%eax),%edx
  80d607:	89 53 7c             	mov    %edx,0x7c(%ebx)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80d60a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d60e:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80d615:	e8 aa 74 ff ff       	call   804ac4 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  80d61a:	0f b7 35 a8 b1 b3 00 	movzwl 0xb3b1a8,%esi
  80d621:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d626:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d62a:	89 04 24             	mov    %eax,(%esp)
  80d62d:	e8 3a a8 ff ff       	call   807e6c <ntohs>
  80d632:	a8 01                	test   $0x1,%al
  80d634:	75 1a                	jne    80d650 <tcp_receive+0x6e3>
  80d636:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d63b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d63f:	89 04 24             	mov    %eax,(%esp)
  80d642:	e8 25 a8 ff ff       	call   807e6c <ntohs>
  80d647:	ba 00 00 00 00       	mov    $0x0,%edx
  80d64c:	a8 02                	test   $0x2,%al
  80d64e:	74 05                	je     80d655 <tcp_receive+0x6e8>
  80d650:	ba 01 00 00 00       	mov    $0x1,%edx
  80d655:	01 d6                	add    %edx,%esi
  80d657:	66 89 35 c2 b1 b3 00 	mov    %si,0xb3b1c2

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  80d65e:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  80d662:	74 06                	je     80d66a <tcp_receive+0x6fd>
          pcb->rcv_nxt += tcplen;
  80d664:	0f b7 f6             	movzwl %si,%esi
  80d667:	01 73 24             	add    %esi,0x24(%ebx)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  80d66a:	0f b7 53 28          	movzwl 0x28(%ebx),%edx
  80d66e:	0f b7 05 c2 b1 b3 00 	movzwl 0xb3b1c2,%eax
  80d675:	66 39 c2             	cmp    %ax,%dx
  80d678:	73 08                	jae    80d682 <tcp_receive+0x715>
          pcb->rcv_wnd = 0;
  80d67a:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  80d680:	eb 07                	jmp    80d689 <tcp_receive+0x71c>
        } else {
          pcb->rcv_wnd -= tcplen;
  80d682:	66 29 c2             	sub    %ax,%dx
  80d685:	66 89 53 28          	mov    %dx,0x28(%ebx)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  80d689:	0f b7 53 2a          	movzwl 0x2a(%ebx),%edx
  80d68d:	0f b7 05 c2 b1 b3 00 	movzwl 0xb3b1c2,%eax
  80d694:	66 39 c2             	cmp    %ax,%dx
  80d697:	73 08                	jae    80d6a1 <tcp_receive+0x734>
          pcb->rcv_ann_wnd = 0;
  80d699:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  80d69f:	eb 07                	jmp    80d6a8 <tcp_receive+0x73b>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  80d6a1:	66 29 c2             	sub    %ax,%dx
  80d6a4:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  80d6a8:	a1 a0 b1 b3 00       	mov    0xb3b1a0,%eax
  80d6ad:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d6b2:	74 0f                	je     80d6c3 <tcp_receive+0x756>
          recv_data = inseg.p;
  80d6b4:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  80d6b9:	c7 05 a0 b1 b3 00 00 	movl   $0x0,0xb3b1a0
  80d6c0:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80d6c3:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d6c8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d6cc:	89 04 24             	mov    %eax,(%esp)
  80d6cf:	e8 98 a7 ff ff       	call   807e6c <ntohs>
  80d6d4:	a8 01                	test   $0x1,%al
  80d6d6:	0f 84 ea 01 00 00    	je     80d8c6 <tcp_receive+0x959>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  80d6dc:	c6 05 c4 b1 b3 00 20 	movb   $0x20,0xb3b1c4
  80d6e3:	e9 de 01 00 00       	jmp    80d8c6 <tcp_receive+0x959>
           is now in sequence. */
        while (pcb->ooseq != NULL &&
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  80d6e8:	a3 b8 b1 b3 00       	mov    %eax,0xb3b1b8

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80d6ed:	8b 46 24             	mov    0x24(%esi),%eax
  80d6f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d6f3:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80d6f7:	8b 43 10             	mov    0x10(%ebx),%eax
  80d6fa:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d6fe:	89 04 24             	mov    %eax,(%esp)
  80d701:	e8 66 a7 ff ff       	call   807e6c <ntohs>
  80d706:	a8 01                	test   $0x1,%al
  80d708:	75 18                	jne    80d722 <tcp_receive+0x7b5>
  80d70a:	8b 43 10             	mov    0x10(%ebx),%eax
  80d70d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d711:	89 04 24             	mov    %eax,(%esp)
  80d714:	e8 53 a7 ff ff       	call   807e6c <ntohs>
  80d719:	ba 00 00 00 00       	mov    $0x0,%edx
  80d71e:	a8 02                	test   $0x2,%al
  80d720:	74 05                	je     80d727 <tcp_receive+0x7ba>
  80d722:	ba 01 00 00 00       	mov    $0x1,%edx
  80d727:	0f b7 ff             	movzwl %di,%edi
  80d72a:	01 fa                	add    %edi,%edx
  80d72c:	03 55 e4             	add    -0x1c(%ebp),%edx
  80d72f:	89 56 24             	mov    %edx,0x24(%esi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80d732:	0f b7 7e 28          	movzwl 0x28(%esi),%edi
  80d736:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80d73a:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  80d73e:	8b 43 10             	mov    0x10(%ebx),%eax
  80d741:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d745:	89 04 24             	mov    %eax,(%esp)
  80d748:	e8 1f a7 ff ff       	call   807e6c <ntohs>
  80d74d:	a8 01                	test   $0x1,%al
  80d74f:	75 18                	jne    80d769 <tcp_receive+0x7fc>
  80d751:	8b 43 10             	mov    0x10(%ebx),%eax
  80d754:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d758:	89 04 24             	mov    %eax,(%esp)
  80d75b:	e8 0c a7 ff ff       	call   807e6c <ntohs>
  80d760:	ba 00 00 00 00       	mov    $0x0,%edx
  80d765:	a8 02                	test   $0x2,%al
  80d767:	74 05                	je     80d76e <tcp_receive+0x801>
  80d769:	ba 01 00 00 00       	mov    $0x1,%edx
  80d76e:	0f b7 ff             	movzwl %di,%edi
  80d771:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80d775:	01 c2                	add    %eax,%edx
  80d777:	39 d7                	cmp    %edx,%edi
  80d779:	7d 08                	jge    80d783 <tcp_receive+0x816>
            pcb->rcv_wnd = 0;
  80d77b:	66 c7 46 28 00 00    	movw   $0x0,0x28(%esi)
  80d781:	eb 47                	jmp    80d7ca <tcp_receive+0x85d>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80d783:	0f b7 7e 28          	movzwl 0x28(%esi),%edi
  80d787:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d78b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80d78f:	8b 43 10             	mov    0x10(%ebx),%eax
  80d792:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d796:	89 04 24             	mov    %eax,(%esp)
  80d799:	e8 ce a6 ff ff       	call   807e6c <ntohs>
  80d79e:	a8 01                	test   $0x1,%al
  80d7a0:	75 18                	jne    80d7ba <tcp_receive+0x84d>
  80d7a2:	8b 43 10             	mov    0x10(%ebx),%eax
  80d7a5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d7a9:	89 04 24             	mov    %eax,(%esp)
  80d7ac:	e8 bb a6 ff ff       	call   807e6c <ntohs>
  80d7b1:	ba 00 00 00 00       	mov    $0x0,%edx
  80d7b6:	a8 02                	test   $0x2,%al
  80d7b8:	74 05                	je     80d7bf <tcp_receive+0x852>
  80d7ba:	ba 01 00 00 00       	mov    $0x1,%edx
  80d7bf:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  80d7c3:	66 29 d7             	sub    %dx,%di
  80d7c6:	66 89 7e 28          	mov    %di,0x28(%esi)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80d7ca:	0f b7 7e 2a          	movzwl 0x2a(%esi),%edi
  80d7ce:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80d7d2:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  80d7d6:	8b 43 10             	mov    0x10(%ebx),%eax
  80d7d9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d7dd:	89 04 24             	mov    %eax,(%esp)
  80d7e0:	e8 87 a6 ff ff       	call   807e6c <ntohs>
  80d7e5:	a8 01                	test   $0x1,%al
  80d7e7:	75 18                	jne    80d801 <tcp_receive+0x894>
  80d7e9:	8b 43 10             	mov    0x10(%ebx),%eax
  80d7ec:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d7f0:	89 04 24             	mov    %eax,(%esp)
  80d7f3:	e8 74 a6 ff ff       	call   807e6c <ntohs>
  80d7f8:	ba 00 00 00 00       	mov    $0x0,%edx
  80d7fd:	a8 02                	test   $0x2,%al
  80d7ff:	74 05                	je     80d806 <tcp_receive+0x899>
  80d801:	ba 01 00 00 00       	mov    $0x1,%edx
  80d806:	0f b7 ff             	movzwl %di,%edi
  80d809:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80d80d:	01 c2                	add    %eax,%edx
  80d80f:	39 d7                	cmp    %edx,%edi
  80d811:	7d 08                	jge    80d81b <tcp_receive+0x8ae>
            pcb->rcv_ann_wnd = 0;
  80d813:	66 c7 46 2a 00 00    	movw   $0x0,0x2a(%esi)
  80d819:	eb 47                	jmp    80d862 <tcp_receive+0x8f5>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80d81b:	0f b7 7e 2a          	movzwl 0x2a(%esi),%edi
  80d81f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d823:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80d827:	8b 43 10             	mov    0x10(%ebx),%eax
  80d82a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d82e:	89 04 24             	mov    %eax,(%esp)
  80d831:	e8 36 a6 ff ff       	call   807e6c <ntohs>
  80d836:	a8 01                	test   $0x1,%al
  80d838:	75 18                	jne    80d852 <tcp_receive+0x8e5>
  80d83a:	8b 43 10             	mov    0x10(%ebx),%eax
  80d83d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d841:	89 04 24             	mov    %eax,(%esp)
  80d844:	e8 23 a6 ff ff       	call   807e6c <ntohs>
  80d849:	ba 00 00 00 00       	mov    $0x0,%edx
  80d84e:	a8 02                	test   $0x2,%al
  80d850:	74 05                	je     80d857 <tcp_receive+0x8ea>
  80d852:	ba 01 00 00 00       	mov    $0x1,%edx
  80d857:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  80d85b:	66 29 d7             	sub    %dx,%di
  80d85e:	66 89 7e 2a          	mov    %di,0x2a(%esi)
          }

          if (cseg->p->tot_len > 0) {
  80d862:	8b 43 04             	mov    0x4(%ebx),%eax
  80d865:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d86a:	74 24                	je     80d890 <tcp_receive+0x923>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  80d86c:	8b 15 c8 b1 b3 00    	mov    0xb3b1c8,%edx
  80d872:	85 d2                	test   %edx,%edx
  80d874:	74 0e                	je     80d884 <tcp_receive+0x917>
              pbuf_cat(recv_data, cseg->p);
  80d876:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d87a:	89 14 24             	mov    %edx,(%esp)
  80d87d:	e8 87 75 ff ff       	call   804e09 <pbuf_cat>
  80d882:	eb 05                	jmp    80d889 <tcp_receive+0x91c>
            } else {
              recv_data = cseg->p;
  80d884:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
            }
            cseg->p = NULL;
  80d889:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80d890:	8b 43 10             	mov    0x10(%ebx),%eax
  80d893:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d897:	89 04 24             	mov    %eax,(%esp)
  80d89a:	e8 cd a5 ff ff       	call   807e6c <ntohs>
  80d89f:	a8 01                	test   $0x1,%al
  80d8a1:	74 14                	je     80d8b7 <tcp_receive+0x94a>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  80d8a3:	c6 05 c4 b1 b3 00 20 	movb   $0x20,0xb3b1c4
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80d8aa:	83 7e 10 04          	cmpl   $0x4,0x10(%esi)
  80d8ae:	75 07                	jne    80d8b7 <tcp_receive+0x94a>
              pcb->state = CLOSE_WAIT;
  80d8b0:	c7 46 10 07 00 00 00 	movl   $0x7,0x10(%esi)
            } 
          }


          pcb->ooseq = cseg->next;
  80d8b7:	8b 03                	mov    (%ebx),%eax
  80d8b9:	89 46 7c             	mov    %eax,0x7c(%esi)
          tcp_seg_free(cseg);
  80d8bc:	89 1c 24             	mov    %ebx,(%esp)
  80d8bf:	e8 5e 84 ff ff       	call   805d22 <tcp_seg_free>
  80d8c4:	eb 02                	jmp    80d8c8 <tcp_receive+0x95b>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80d8c6:	89 de                	mov    %ebx,%esi
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80d8c8:	8b 5e 7c             	mov    0x7c(%esi),%ebx
  80d8cb:	85 db                	test   %ebx,%ebx
  80d8cd:	74 0f                	je     80d8de <tcp_receive+0x971>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80d8cf:	8b 43 10             	mov    0x10(%ebx),%eax
  80d8d2:	8b 40 04             	mov    0x4(%eax),%eax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80d8d5:	3b 46 24             	cmp    0x24(%esi),%eax
  80d8d8:	0f 84 0a fe ff ff    	je     80d6e8 <tcp_receive+0x77b>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80d8de:	0f b6 46 20          	movzbl 0x20(%esi),%eax
  80d8e2:	a8 01                	test   $0x1,%al
  80d8e4:	74 1b                	je     80d901 <tcp_receive+0x994>
  80d8e6:	83 e0 fe             	and    $0xfffffffe,%eax
  80d8e9:	83 c8 02             	or     $0x2,%eax
  80d8ec:	88 46 20             	mov    %al,0x20(%esi)
  80d8ef:	89 34 24             	mov    %esi,(%esp)
  80d8f2:	e8 d4 ab ff ff       	call   8084cb <tcp_output>
  80d8f7:	b8 01 00 00 00       	mov    $0x1,%eax
  80d8fc:	e9 9e 02 00 00       	jmp    80db9f <tcp_receive+0xc32>
  80d901:	83 c8 01             	or     $0x1,%eax
  80d904:	88 46 20             	mov    %al,0x20(%esi)
  80d907:	b8 01 00 00 00       	mov    $0x1,%eax
  80d90c:	e9 8e 02 00 00       	jmp    80db9f <tcp_receive+0xc32>

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  80d911:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d915:	89 1c 24             	mov    %ebx,(%esp)
  80d918:	e8 ae ab ff ff       	call   8084cb <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  80d91d:	8b 73 7c             	mov    0x7c(%ebx),%esi
  80d920:	85 f6                	test   %esi,%esi
  80d922:	75 19                	jne    80d93d <tcp_receive+0x9d0>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80d924:	c7 04 24 9c b1 b3 00 	movl   $0xb3b19c,(%esp)
  80d92b:	e8 af 83 ff ff       	call   805cdf <tcp_seg_copy>
  80d930:	89 43 7c             	mov    %eax,0x7c(%ebx)
  80d933:	b8 00 00 00 00       	mov    $0x0,%eax
  80d938:	e9 62 02 00 00       	jmp    80db9f <tcp_receive+0xc32>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80d93d:	8b 0d b8 b1 b3 00    	mov    0xb3b1b8,%ecx
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d943:	8d 41 01             	lea    0x1(%ecx),%eax
  80d946:	bf 00 00 00 00       	mov    $0x0,%edi
  80d94b:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80d94e:	89 c3                	mov    %eax,%ebx
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80d950:	8b 46 10             	mov    0x10(%esi),%eax
  80d953:	8b 40 04             	mov    0x4(%eax),%eax
  80d956:	39 c8                	cmp    %ecx,%eax
  80d958:	0f 85 96 00 00 00    	jne    80d9f4 <tcp_receive+0xa87>
  80d95e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  80d961:	0f b7 05 a8 b1 b3 00 	movzwl 0xb3b1a8,%eax
  80d968:	66 3b 46 0c          	cmp    0xc(%esi),%ax
  80d96c:	0f 86 28 02 00 00    	jbe    80db9a <tcp_receive+0xc2d>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  80d972:	c7 04 24 9c b1 b3 00 	movl   $0xb3b19c,(%esp)
  80d979:	e8 61 83 ff ff       	call   805cdf <tcp_seg_copy>
  80d97e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  80d981:	85 c0                	test   %eax,%eax
  80d983:	0f 84 11 02 00 00    	je     80db9a <tcp_receive+0xc2d>
                  cseg->next = next->next;
  80d989:	8b 06                	mov    (%esi),%eax
  80d98b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d98e:	89 02                	mov    %eax,(%edx)
                  if (prev != NULL) {
  80d990:	85 ff                	test   %edi,%edi
  80d992:	74 04                	je     80d998 <tcp_receive+0xa2b>
                    prev->next = cseg;
  80d994:	89 17                	mov    %edx,(%edi)
  80d996:	eb 06                	jmp    80d99e <tcp_receive+0xa31>
                  } else {
                    pcb->ooseq = cseg;
  80d998:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80d99b:	89 7b 7c             	mov    %edi,0x7c(%ebx)
                  }
                  tcp_seg_free(next);
  80d99e:	89 34 24             	mov    %esi,(%esp)
  80d9a1:	e8 7c 83 ff ff       	call   805d22 <tcp_seg_free>
                  if (cseg->next != NULL) {
  80d9a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80d9a9:	8b 10                	mov    (%eax),%edx
  80d9ab:	85 d2                	test   %edx,%edx
  80d9ad:	0f 84 e7 01 00 00    	je     80db9a <tcp_receive+0xc2d>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80d9b3:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80d9b8:	8b 52 10             	mov    0x10(%edx),%edx
  80d9bb:	8b 52 04             	mov    0x4(%edx),%edx
  80d9be:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80d9c1:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80d9c5:	29 d1                	sub    %edx,%ecx
  80d9c7:	01 c1                	add    %eax,%ecx
  80d9c9:	85 c9                	test   %ecx,%ecx
  80d9cb:	0f 8e c9 01 00 00    	jle    80db9a <tcp_receive+0xc2d>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80d9d1:	66 29 c2             	sub    %ax,%dx
  80d9d4:	66 89 53 0c          	mov    %dx,0xc(%ebx)
                      pbuf_realloc(cseg->p, cseg->len);
  80d9d8:	0f b7 c2             	movzwl %dx,%eax
  80d9db:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d9df:	8b 43 04             	mov    0x4(%ebx),%eax
  80d9e2:	89 04 24             	mov    %eax,(%esp)
  80d9e5:	e8 c3 79 ff ff       	call   8053ad <pbuf_realloc>
  80d9ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80d9ef:	e9 ab 01 00 00       	jmp    80db9f <tcp_receive+0xc32>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  80d9f4:	85 ff                	test   %edi,%edi
  80d9f6:	75 5b                	jne    80da53 <tcp_receive+0xae6>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80d9f8:	39 c1                	cmp    %eax,%ecx
  80d9fa:	0f 89 f3 00 00 00    	jns    80daf3 <tcp_receive+0xb86>
  80da00:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80da03:	0f b7 15 a8 b1 b3 00 	movzwl 0xb3b1a8,%edx
  80da0a:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  80da0d:	29 c2                	sub    %eax,%edx
  80da0f:	85 d2                	test   %edx,%edx
  80da11:	7e 1d                	jle    80da30 <tcp_receive+0xac3>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80da13:	66 29 c8             	sub    %cx,%ax
  80da16:	66 a3 a8 b1 b3 00    	mov    %ax,0xb3b1a8
                    pbuf_realloc(inseg.p, inseg.len);
  80da1c:	0f b7 c0             	movzwl %ax,%eax
  80da1f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80da23:	a1 a0 b1 b3 00       	mov    0xb3b1a0,%eax
  80da28:	89 04 24             	mov    %eax,(%esp)
  80da2b:	e8 7d 79 ff ff       	call   8053ad <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
  80da30:	c7 04 24 9c b1 b3 00 	movl   $0xb3b19c,(%esp)
  80da37:	e8 a3 82 ff ff       	call   805cdf <tcp_seg_copy>
                  if (cseg != NULL) {
  80da3c:	85 c0                	test   %eax,%eax
  80da3e:	0f 84 56 01 00 00    	je     80db9a <tcp_receive+0xc2d>
                    cseg->next = next;
  80da44:	89 30                	mov    %esi,(%eax)
                    pcb->ooseq = cseg;
  80da46:	89 43 7c             	mov    %eax,0x7c(%ebx)
  80da49:	b8 00 00 00 00       	mov    $0x0,%eax
  80da4e:	e9 4c 01 00 00       	jmp    80db9f <tcp_receive+0xc32>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80da53:	8b 57 10             	mov    0x10(%edi),%edx
  80da56:	8b 52 04             	mov    0x4(%edx),%edx
  80da59:	f7 d2                	not    %edx
  80da5b:	01 ca                	add    %ecx,%edx
  80da5d:	0f 88 90 00 00 00    	js     80daf3 <tcp_receive+0xb86>
  80da63:	89 da                	mov    %ebx,%edx
  80da65:	29 c2                	sub    %eax,%edx
  80da67:	85 d2                	test   %edx,%edx
  80da69:	0f 8f 84 00 00 00    	jg     80daf3 <tcp_receive+0xb86>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80da6f:	0f b7 15 a8 b1 b3 00 	movzwl 0xb3b1a8,%edx
  80da76:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  80da79:	29 c2                	sub    %eax,%edx
  80da7b:	85 d2                	test   %edx,%edx
  80da7d:	7e 1d                	jle    80da9c <tcp_receive+0xb2f>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80da7f:	66 29 c8             	sub    %cx,%ax
  80da82:	66 a3 a8 b1 b3 00    	mov    %ax,0xb3b1a8
                  pbuf_realloc(inseg.p, inseg.len);
  80da88:	0f b7 c0             	movzwl %ax,%eax
  80da8b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80da8f:	a1 a0 b1 b3 00       	mov    0xb3b1a0,%eax
  80da94:	89 04 24             	mov    %eax,(%esp)
  80da97:	e8 11 79 ff ff       	call   8053ad <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
  80da9c:	c7 04 24 9c b1 b3 00 	movl   $0xb3b19c,(%esp)
  80daa3:	e8 37 82 ff ff       	call   805cdf <tcp_seg_copy>
                if (cseg != NULL) {
  80daa8:	85 c0                	test   %eax,%eax
  80daaa:	0f 84 ea 00 00 00    	je     80db9a <tcp_receive+0xc2d>
                  cseg->next = next;
  80dab0:	89 30                	mov    %esi,(%eax)
                  prev->next = cseg;
  80dab2:	89 07                	mov    %eax,(%edi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80dab4:	8b 47 10             	mov    0x10(%edi),%eax
  80dab7:	8b 40 04             	mov    0x4(%eax),%eax
  80daba:	8b 15 b8 b1 b3 00    	mov    0xb3b1b8,%edx
  80dac0:	0f b7 4f 0c          	movzwl 0xc(%edi),%ecx
  80dac4:	29 d1                	sub    %edx,%ecx
  80dac6:	01 c1                	add    %eax,%ecx
  80dac8:	85 c9                	test   %ecx,%ecx
  80daca:	0f 8e ca 00 00 00    	jle    80db9a <tcp_receive+0xc2d>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80dad0:	66 29 c2             	sub    %ax,%dx
  80dad3:	66 89 57 0c          	mov    %dx,0xc(%edi)
                    pbuf_realloc(prev->p, prev->len);
  80dad7:	0f b7 c2             	movzwl %dx,%eax
  80dada:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dade:	8b 47 04             	mov    0x4(%edi),%eax
  80dae1:	89 04 24             	mov    %eax,(%esp)
  80dae4:	e8 c4 78 ff ff       	call   8053ad <pbuf_realloc>
  80dae9:	b8 00 00 00 00       	mov    $0x0,%eax
  80daee:	e9 ac 00 00 00       	jmp    80db9f <tcp_receive+0xc32>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80daf3:	8b 16                	mov    (%esi),%edx
  80daf5:	85 d2                	test   %edx,%edx
  80daf7:	74 09                	je     80db02 <tcp_receive+0xb95>
  80daf9:	89 f7                	mov    %esi,%edi
  80dafb:	89 d6                	mov    %edx,%esi
  80dafd:	e9 4e fe ff ff       	jmp    80d950 <tcp_receive+0x9e3>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80db02:	29 c1                	sub    %eax,%ecx
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80db04:	85 c9                	test   %ecx,%ecx
  80db06:	0f 8e 8e 00 00 00    	jle    80db9a <tcp_receive+0xc2d>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  80db0c:	c7 04 24 9c b1 b3 00 	movl   $0xb3b19c,(%esp)
  80db13:	e8 c7 81 ff ff       	call   805cdf <tcp_seg_copy>
  80db18:	89 06                	mov    %eax,(%esi)
                if (next->next != NULL) {
  80db1a:	85 c0                	test   %eax,%eax
  80db1c:	74 7c                	je     80db9a <tcp_receive+0xc2d>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80db1e:	8b 46 10             	mov    0x10(%esi),%eax
  80db21:	8b 40 04             	mov    0x4(%eax),%eax
  80db24:	8b 15 b8 b1 b3 00    	mov    0xb3b1b8,%edx
  80db2a:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80db2e:	29 d1                	sub    %edx,%ecx
  80db30:	01 c1                	add    %eax,%ecx
  80db32:	85 c9                	test   %ecx,%ecx
  80db34:	7e 64                	jle    80db9a <tcp_receive+0xc2d>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80db36:	66 29 c2             	sub    %ax,%dx
  80db39:	66 89 56 0c          	mov    %dx,0xc(%esi)
                    pbuf_realloc(next->p, next->len);
  80db3d:	0f b7 c2             	movzwl %dx,%eax
  80db40:	89 44 24 04          	mov    %eax,0x4(%esp)
  80db44:	8b 46 04             	mov    0x4(%esi),%eax
  80db47:	89 04 24             	mov    %eax,(%esp)
  80db4a:	e8 5e 78 ff ff       	call   8053ad <pbuf_realloc>
  80db4f:	b8 00 00 00 00       	mov    $0x0,%eax
  80db54:	eb 49                	jmp    80db9f <tcp_receive+0xc32>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  80db56:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80db5a:	89 1c 24             	mov    %ebx,(%esp)
  80db5d:	e8 69 a9 ff ff       	call   8084cb <tcp_output>
  80db62:	b8 00 00 00 00       	mov    $0x0,%eax
  80db67:	eb 36                	jmp    80db9f <tcp_receive+0xc32>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80db69:	8b 15 b8 b1 b3 00    	mov    0xb3b1b8,%edx
  80db6f:	8b 43 24             	mov    0x24(%ebx),%eax
  80db72:	39 c2                	cmp    %eax,%edx
  80db74:	78 11                	js     80db87 <tcp_receive+0xc1a>
  80db76:	83 c2 01             	add    $0x1,%edx
  80db79:	29 c2                	sub    %eax,%edx
  80db7b:	89 d0                	mov    %edx,%eax
  80db7d:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80db81:	29 c8                	sub    %ecx,%eax
  80db83:	85 c0                	test   %eax,%eax
  80db85:	7e 13                	jle    80db9a <tcp_receive+0xc2d>
      tcp_ack_now(pcb);
  80db87:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80db8b:	89 1c 24             	mov    %ebx,(%esp)
  80db8e:	e8 38 a9 ff ff       	call   8084cb <tcp_output>
  80db93:	b8 00 00 00 00       	mov    $0x0,%eax
  80db98:	eb 05                	jmp    80db9f <tcp_receive+0xc32>
  80db9a:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  return accepted_inseq;
}
  80db9f:	83 c4 2c             	add    $0x2c,%esp
  80dba2:	5b                   	pop    %ebx
  80dba3:	5e                   	pop    %esi
  80dba4:	5f                   	pop    %edi
  80dba5:	5d                   	pop    %ebp
  80dba6:	c3                   	ret    

0080dba7 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  80dba7:	55                   	push   %ebp
  80dba8:	89 e5                	mov    %esp,%ebp
  80dbaa:	57                   	push   %edi
  80dbab:	56                   	push   %esi
  80dbac:	53                   	push   %ebx
  80dbad:	83 ec 4c             	sub    $0x4c,%esp
  80dbb0:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  80dbb3:	8b 46 04             	mov    0x4(%esi),%eax
  80dbb6:	a3 b4 b1 b3 00       	mov    %eax,0xb3b1b4
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80dbbb:	8b 5e 04             	mov    0x4(%esi),%ebx
  80dbbe:	0f b7 00             	movzwl (%eax),%eax
  80dbc1:	89 04 24             	mov    %eax,(%esp)
  80dbc4:	e8 a3 a2 ff ff       	call   807e6c <ntohs>
  80dbc9:	c1 e8 06             	shr    $0x6,%eax
  80dbcc:	83 e0 3c             	and    $0x3c,%eax
  80dbcf:	01 c3                	add    %eax,%ebx
  80dbd1:	89 1d b0 b1 b3 00    	mov    %ebx,0xb3b1b0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80dbd7:	a1 b4 b1 b3 00       	mov    0xb3b1b4,%eax
  80dbdc:	0f b7 00             	movzwl (%eax),%eax
  80dbdf:	89 04 24             	mov    %eax,(%esp)
  80dbe2:	e8 85 a2 ff ff       	call   807e6c <ntohs>
  80dbe7:	66 c1 e8 06          	shr    $0x6,%ax
  80dbeb:	83 e0 3c             	and    $0x3c,%eax
  80dbee:	f7 d8                	neg    %eax
  80dbf0:	98                   	cwtl   
  80dbf1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dbf5:	89 34 24             	mov    %esi,(%esp)
  80dbf8:	e8 ca 72 ff ff       	call   804ec7 <pbuf_header>
  80dbfd:	84 c0                	test   %al,%al
  80dbff:	75 07                	jne    80dc08 <tcp_input+0x61>
  80dc01:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80dc06:	77 0d                	ja     80dc15 <tcp_input+0x6e>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80dc08:	89 34 24             	mov    %esi,(%esp)
  80dc0b:	e8 14 76 ff ff       	call   805224 <pbuf_free>
    return;
  80dc10:	e9 1c 0d 00 00       	jmp    80e931 <tcp_input+0xd8a>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80dc15:	8b 45 0c             	mov    0xc(%ebp),%eax
  80dc18:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dc1c:	a1 b4 b1 b3 00       	mov    0xb3b1b4,%eax
  80dc21:	83 c0 10             	add    $0x10,%eax
  80dc24:	89 04 24             	mov    %eax,(%esp)
  80dc27:	e8 14 8f ff ff       	call   806b40 <ip_addr_isbroadcast>
  80dc2c:	84 c0                	test   %al,%al
  80dc2e:	75 28                	jne    80dc58 <tcp_input+0xb1>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80dc30:	a1 b4 b1 b3 00       	mov    0xb3b1b4,%eax
  80dc35:	8b 78 10             	mov    0x10(%eax),%edi
  80dc38:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80dc3f:	e8 48 a4 ff ff       	call   80808c <ntohl>
  80dc44:	89 c3                	mov    %eax,%ebx
  80dc46:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80dc4d:	e8 3a a4 ff ff       	call   80808c <ntohl>
  80dc52:	21 fb                	and    %edi,%ebx
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80dc54:	39 c3                	cmp    %eax,%ebx
  80dc56:	75 0d                	jne    80dc65 <tcp_input+0xbe>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80dc58:	89 34 24             	mov    %esi,(%esp)
  80dc5b:	e8 c4 75 ff ff       	call   805224 <pbuf_free>
    return;
  80dc60:	e9 cc 0c 00 00       	jmp    80e931 <tcp_input+0xd8a>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  80dc65:	a1 b4 b1 b3 00       	mov    0xb3b1b4,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80dc6a:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80dc6e:	89 54 24 10          	mov    %edx,0x10(%esp)
  80dc72:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80dc79:	00 
  80dc7a:	8d 50 10             	lea    0x10(%eax),%edx
  80dc7d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80dc81:	83 c0 0c             	add    $0xc,%eax
  80dc84:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dc88:	89 34 24             	mov    %esi,(%esp)
  80dc8b:	e8 e8 9e ff ff       	call   807b78 <inet_chksum_pseudo>
  80dc90:	66 85 c0             	test   %ax,%ax
  80dc93:	74 0d                	je     80dca2 <tcp_input+0xfb>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80dc95:	89 34 24             	mov    %esi,(%esp)
  80dc98:	e8 87 75 ff ff       	call   805224 <pbuf_free>
    return;
  80dc9d:	e9 8f 0c 00 00       	jmp    80e931 <tcp_input+0xd8a>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  80dca2:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80dca7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80dcab:	89 04 24             	mov    %eax,(%esp)
  80dcae:	e8 b9 a1 ff ff       	call   807e6c <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80dcb3:	66 c1 e8 0c          	shr    $0xc,%ax
  80dcb7:	c1 e0 02             	shl    $0x2,%eax
  80dcba:	f7 d8                	neg    %eax
  80dcbc:	98                   	cwtl   
  80dcbd:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dcc1:	89 34 24             	mov    %esi,(%esp)
  80dcc4:	e8 fe 71 ff ff       	call   804ec7 <pbuf_header>
  80dcc9:	84 c0                	test   %al,%al
  80dccb:	74 0d                	je     80dcda <tcp_input+0x133>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80dccd:	89 34 24             	mov    %esi,(%esp)
  80dcd0:	e8 4f 75 ff ff       	call   805224 <pbuf_free>
    return;
  80dcd5:	e9 57 0c 00 00       	jmp    80e931 <tcp_input+0xd8a>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  80dcda:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80dce0:	0f b7 03             	movzwl (%ebx),%eax
  80dce3:	89 04 24             	mov    %eax,(%esp)
  80dce6:	e8 81 a1 ff ff       	call   807e6c <ntohs>
  80dceb:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80dcee:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80dcf4:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80dcf8:	89 04 24             	mov    %eax,(%esp)
  80dcfb:	e8 6c a1 ff ff       	call   807e6c <ntohs>
  80dd00:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80dd04:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80dd0a:	8b 43 04             	mov    0x4(%ebx),%eax
  80dd0d:	89 04 24             	mov    %eax,(%esp)
  80dd10:	e8 77 a3 ff ff       	call   80808c <ntohl>
  80dd15:	89 43 04             	mov    %eax,0x4(%ebx)
  80dd18:	a3 b8 b1 b3 00       	mov    %eax,0xb3b1b8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80dd1d:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80dd23:	8b 43 08             	mov    0x8(%ebx),%eax
  80dd26:	89 04 24             	mov    %eax,(%esp)
  80dd29:	e8 5e a3 ff ff       	call   80808c <ntohl>
  80dd2e:	89 43 08             	mov    %eax,0x8(%ebx)
  80dd31:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80dd36:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80dd3c:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80dd40:	89 04 24             	mov    %eax,(%esp)
  80dd43:	e8 24 a1 ff ff       	call   807e6c <ntohs>
  80dd48:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80dd4c:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80dd51:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80dd55:	89 04 24             	mov    %eax,(%esp)
  80dd58:	e8 0f a1 ff ff       	call   807e6c <ntohs>
  80dd5d:	83 e0 3f             	and    $0x3f,%eax
  80dd60:	a2 c0 b1 b3 00       	mov    %al,0xb3b1c0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80dd65:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  80dd69:	ba 01 00 00 00       	mov    $0x1,%edx
  80dd6e:	a8 01                	test   $0x1,%al
  80dd70:	75 07                	jne    80dd79 <tcp_input+0x1d2>
  80dd72:	d1 e8                	shr    %eax
  80dd74:	89 c2                	mov    %eax,%edx
  80dd76:	83 e2 01             	and    $0x1,%edx
  80dd79:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  80dd7c:	66 89 55 d6          	mov    %dx,-0x2a(%ebp)
  80dd80:	66 89 15 c2 b1 b3 00 	mov    %dx,0xb3b1c2
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dd87:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  80dd8d:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80dd92:	8b 15 b4 b1 b3 00    	mov    0xb3b1b4,%edx
  80dd98:	bf 00 00 00 00       	mov    $0x0,%edi
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dd9d:	e9 e5 00 00 00       	jmp    80de87 <tcp_input+0x2e0>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80dda2:	8b 4b 10             	mov    0x10(%ebx),%ecx
  80dda5:	85 c9                	test   %ecx,%ecx
  80dda7:	75 1c                	jne    80ddc5 <tcp_input+0x21e>
  80dda9:	c7 44 24 08 28 32 81 	movl   $0x813228,0x8(%esp)
  80ddb0:	00 
  80ddb1:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80ddb8:	00 
  80ddb9:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80ddc0:	e8 27 14 00 00       	call   80f1ec <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80ddc5:	83 f9 0a             	cmp    $0xa,%ecx
  80ddc8:	75 1c                	jne    80dde6 <tcp_input+0x23f>
  80ddca:	c7 44 24 08 50 32 81 	movl   $0x813250,0x8(%esp)
  80ddd1:	00 
  80ddd2:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
  80ddd9:	00 
  80ddda:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80dde1:	e8 06 14 00 00       	call   80f1ec <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80dde6:	83 f9 01             	cmp    $0x1,%ecx
  80dde9:	75 1c                	jne    80de07 <tcp_input+0x260>
  80ddeb:	c7 44 24 08 7c 32 81 	movl   $0x81327c,0x8(%esp)
  80ddf2:	00 
  80ddf3:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  80ddfa:	00 
  80ddfb:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80de02:	e8 e5 13 00 00       	call   80f1ec <_panic>
    if (pcb->remote_port == tcphdr->src &&
  80de07:	0f b7 4b 1e          	movzwl 0x1e(%ebx),%ecx
  80de0b:	66 3b 08             	cmp    (%eax),%cx
  80de0e:	75 72                	jne    80de82 <tcp_input+0x2db>
  80de10:	0f b7 4b 1c          	movzwl 0x1c(%ebx),%ecx
  80de14:	66 3b 48 02          	cmp    0x2(%eax),%cx
  80de18:	75 68                	jne    80de82 <tcp_input+0x2db>
  80de1a:	8b 4b 04             	mov    0x4(%ebx),%ecx
  80de1d:	3b 4a 0c             	cmp    0xc(%edx),%ecx
  80de20:	75 60                	jne    80de82 <tcp_input+0x2db>
  80de22:	8b 0b                	mov    (%ebx),%ecx
  80de24:	3b 4a 10             	cmp    0x10(%edx),%ecx
  80de27:	75 59                	jne    80de82 <tcp_input+0x2db>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80de29:	8b 43 0c             	mov    0xc(%ebx),%eax
  80de2c:	39 d8                	cmp    %ebx,%eax
  80de2e:	75 1c                	jne    80de4c <tcp_input+0x2a5>
  80de30:	c7 44 24 08 a4 32 81 	movl   $0x8132a4,0x8(%esp)
  80de37:	00 
  80de38:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  80de3f:	00 
  80de40:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80de47:	e8 a0 13 00 00       	call   80f1ec <_panic>
      if (prev != NULL) {
  80de4c:	85 ff                	test   %edi,%edi
  80de4e:	74 44                	je     80de94 <tcp_input+0x2ed>
        prev->next = pcb->next;
  80de50:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80de53:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80de58:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80de5b:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80de61:	39 5b 0c             	cmp    %ebx,0xc(%ebx)
  80de64:	75 2e                	jne    80de94 <tcp_input+0x2ed>
  80de66:	c7 44 24 08 d0 32 81 	movl   $0x8132d0,0x8(%esp)
  80de6d:	00 
  80de6e:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
  80de75:	00 
  80de76:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80de7d:	e8 6a 13 00 00       	call   80f1ec <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80de82:	89 df                	mov    %ebx,%edi
  80de84:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80de87:	85 db                	test   %ebx,%ebx
  80de89:	0f 85 13 ff ff ff    	jne    80dda2 <tcp_input+0x1fb>
  80de8f:	e9 67 0a 00 00       	jmp    80e8fb <tcp_input+0xd54>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  80de94:	c7 05 9c b1 b3 00 00 	movl   $0x0,0xb3b19c
  80de9b:	00 00 00 
    inseg.len = p->tot_len;
  80de9e:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80dea2:	66 a3 a8 b1 b3 00    	mov    %ax,0xb3b1a8
    inseg.dataptr = p->payload;
  80dea8:	8b 46 04             	mov    0x4(%esi),%eax
  80deab:	a3 a4 b1 b3 00       	mov    %eax,0xb3b1a4
    inseg.p = p;
  80deb0:	89 35 a0 b1 b3 00    	mov    %esi,0xb3b1a0
    inseg.tcphdr = tcphdr;
  80deb6:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80debb:	a3 ac b1 b3 00       	mov    %eax,0xb3b1ac

    recv_data = NULL;
  80dec0:	c7 05 c8 b1 b3 00 00 	movl   $0x0,0xb3b1c8
  80dec7:	00 00 00 
    recv_flags = 0;
  80deca:	c6 05 c4 b1 b3 00 00 	movb   $0x0,0xb3b1c4

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80ded1:	8b 93 80 00 00 00    	mov    0x80(%ebx),%edx
  80ded7:	85 d2                	test   %edx,%edx
  80ded9:	0f 85 7b 02 00 00    	jne    80e15a <tcp_input+0x5b3>
  80dedf:	e9 bf 02 00 00       	jmp    80e1a3 <tcp_input+0x5fc>

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80dee4:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80dee8:	74 1c                	je     80df06 <tcp_input+0x35f>
  80deea:	c7 44 24 08 fc 32 81 	movl   $0x8132fc,0x8(%esp)
  80def1:	00 
  80def2:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
  80def9:	00 
  80defa:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80df01:	e8 e6 12 00 00       	call   80f1ec <_panic>
      if (pcb->remote_port == tcphdr->src &&
  80df06:	0f b7 4b 1e          	movzwl 0x1e(%ebx),%ecx
  80df0a:	66 3b 08             	cmp    (%eax),%cx
  80df0d:	75 5a                	jne    80df69 <tcp_input+0x3c2>
  80df0f:	0f b7 4b 1c          	movzwl 0x1c(%ebx),%ecx
  80df13:	66 3b 48 02          	cmp    0x2(%eax),%cx
  80df17:	75 50                	jne    80df69 <tcp_input+0x3c2>
  80df19:	8b 4b 04             	mov    0x4(%ebx),%ecx
  80df1c:	3b 4a 0c             	cmp    0xc(%edx),%ecx
  80df1f:	75 48                	jne    80df69 <tcp_input+0x3c2>
  80df21:	8b 0b                	mov    (%ebx),%ecx
  80df23:	3b 4a 10             	cmp    0x10(%edx),%ecx
  80df26:	75 41                	jne    80df69 <tcp_input+0x3c2>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80df28:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80df2c:	03 05 b8 b1 b3 00    	add    0xb3b1b8,%eax
  80df32:	89 c2                	mov    %eax,%edx
  80df34:	2b 53 24             	sub    0x24(%ebx),%edx
  80df37:	85 d2                	test   %edx,%edx
  80df39:	7e 03                	jle    80df3e <tcp_input+0x397>
    pcb->rcv_nxt = seqno + tcplen;
  80df3b:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  80df3e:	66 83 3d c2 b1 b3 00 	cmpw   $0x0,0xb3b1c2
  80df45:	00 
  80df46:	74 0c                	je     80df54 <tcp_input+0x3ad>
    tcp_ack_now(pcb);
  80df48:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80df4c:	89 1c 24             	mov    %ebx,(%esp)
  80df4f:	e8 77 a5 ff ff       	call   8084cb <tcp_output>
  }
  return tcp_output(pcb);
  80df54:	89 1c 24             	mov    %ebx,(%esp)
  80df57:	e8 6f a5 ff ff       	call   8084cb <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  80df5c:	89 34 24             	mov    %esi,(%esp)
  80df5f:	e8 c0 72 ff ff       	call   805224 <pbuf_free>
        return;
  80df64:	e9 c8 09 00 00       	jmp    80e931 <tcp_input+0xd8a>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80df69:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80df6c:	85 db                	test   %ebx,%ebx
  80df6e:	0f 85 70 ff ff ff    	jne    80dee4 <tcp_input+0x33d>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80df74:	8b 1d 44 b2 b3 00    	mov    0xb3b244,%ebx
  80df7a:	bf 00 00 00 00       	mov    $0x0,%edi
  80df7f:	e9 c9 01 00 00       	jmp    80e14d <tcp_input+0x5a6>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80df84:	85 db                	test   %ebx,%ebx
  80df86:	74 0f                	je     80df97 <tcp_input+0x3f0>
  80df88:	8b 0b                	mov    (%ebx),%ecx
  80df8a:	85 c9                	test   %ecx,%ecx
  80df8c:	74 09                	je     80df97 <tcp_input+0x3f0>
  80df8e:	3b 4a 10             	cmp    0x10(%edx),%ecx
  80df91:	0f 85 b1 01 00 00    	jne    80e148 <tcp_input+0x5a1>
  80df97:	0f b7 4b 1c          	movzwl 0x1c(%ebx),%ecx
  80df9b:	66 3b 48 02          	cmp    0x2(%eax),%cx
  80df9f:	0f 85 a3 01 00 00    	jne    80e148 <tcp_input+0x5a1>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  80dfa5:	85 ff                	test   %edi,%edi
  80dfa7:	74 14                	je     80dfbd <tcp_input+0x416>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80dfa9:	8b 43 0c             	mov    0xc(%ebx),%eax
  80dfac:	89 47 0c             	mov    %eax,0xc(%edi)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80dfaf:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80dfb4:	89 43 0c             	mov    %eax,0xc(%ebx)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80dfb7:	89 1d 44 b2 b3 00    	mov    %ebx,0xb3b244
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  80dfbd:	0f b6 05 c0 b1 b3 00 	movzbl 0xb3b1c0,%eax
  80dfc4:	a8 10                	test   $0x10,%al
  80dfc6:	74 4e                	je     80e016 <tcp_input+0x46f>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  80dfc8:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
  80dfce:	a1 b4 b1 b3 00       	mov    0xb3b1b4,%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  80dfd3:	0f b7 0a             	movzwl (%edx),%ecx
  80dfd6:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80dfda:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80dfde:	89 54 24 10          	mov    %edx,0x10(%esp)
  80dfe2:	8d 50 0c             	lea    0xc(%eax),%edx
  80dfe5:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80dfe9:	83 c0 10             	add    $0x10,%eax
  80dfec:	89 44 24 08          	mov    %eax,0x8(%esp)
  80dff0:	0f b7 05 c2 b1 b3 00 	movzwl 0xb3b1c2,%eax
  80dff7:	03 05 b8 b1 b3 00    	add    0xb3b1b8,%eax
  80dffd:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e001:	a1 bc b1 b3 00       	mov    0xb3b1bc,%eax
  80e006:	83 c0 01             	add    $0x1,%eax
  80e009:	89 04 24             	mov    %eax,(%esp)
  80e00c:	e8 5b a3 ff ff       	call   80836c <tcp_rst>
  80e011:	e9 25 01 00 00       	jmp    80e13b <tcp_input+0x594>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  80e016:	a8 02                	test   $0x2,%al
  80e018:	0f 84 1d 01 00 00    	je     80e13b <tcp_input+0x594>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  80e01e:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  80e022:	89 04 24             	mov    %eax,(%esp)
  80e025:	e8 94 83 ff ff       	call   8063be <tcp_alloc>
  80e02a:	89 c7                	mov    %eax,%edi
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  80e02c:	85 c0                	test   %eax,%eax
  80e02e:	0f 84 07 01 00 00    	je     80e13b <tcp_input+0x594>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80e034:	8b 15 b4 b1 b3 00    	mov    0xb3b1b4,%edx
  80e03a:	b8 00 00 00 00       	mov    $0x0,%eax
  80e03f:	83 fa f0             	cmp    $0xfffffff0,%edx
  80e042:	74 03                	je     80e047 <tcp_input+0x4a0>
  80e044:	8b 42 10             	mov    0x10(%edx),%eax
  80e047:	89 07                	mov    %eax,(%edi)
    npcb->local_port = pcb->local_port;
  80e049:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  80e04d:	66 89 47 1c          	mov    %ax,0x1c(%edi)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80e051:	8b 15 b4 b1 b3 00    	mov    0xb3b1b4,%edx
  80e057:	b8 00 00 00 00       	mov    $0x0,%eax
  80e05c:	83 fa f4             	cmp    $0xfffffff4,%edx
  80e05f:	74 03                	je     80e064 <tcp_input+0x4bd>
  80e061:	8b 42 0c             	mov    0xc(%edx),%eax
  80e064:	89 47 04             	mov    %eax,0x4(%edi)
    npcb->remote_port = tcphdr->src;
  80e067:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80e06c:	0f b7 00             	movzwl (%eax),%eax
  80e06f:	66 89 47 1e          	mov    %ax,0x1e(%edi)
    npcb->state = SYN_RCVD;
  80e073:	c7 47 10 03 00 00 00 	movl   $0x3,0x10(%edi)
    npcb->rcv_nxt = seqno + 1;
  80e07a:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80e07f:	83 c0 01             	add    $0x1,%eax
  80e082:	89 47 24             	mov    %eax,0x24(%edi)
    npcb->snd_wnd = tcphdr->wnd;
  80e085:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80e08a:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  80e08e:	66 89 47 5c          	mov    %ax,0x5c(%edi)
    npcb->ssthresh = npcb->snd_wnd;
  80e092:	66 89 47 50          	mov    %ax,0x50(%edi)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80e096:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80e09b:	83 e8 01             	sub    $0x1,%eax
  80e09e:	89 47 60             	mov    %eax,0x60(%edi)
    npcb->callback_arg = pcb->callback_arg;
  80e0a1:	8b 43 18             	mov    0x18(%ebx),%eax
  80e0a4:	89 47 18             	mov    %eax,0x18(%edi)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  80e0a7:	8b 43 20             	mov    0x20(%ebx),%eax
  80e0aa:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80e0b0:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80e0b4:	66 25 99 01          	and    $0x199,%ax
  80e0b8:	66 89 47 08          	mov    %ax,0x8(%edi)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  80e0bc:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80e0c1:	89 47 0c             	mov    %eax,0xc(%edi)
  80e0c4:	89 3d 3c b2 b3 00    	mov    %edi,0xb3b23c
  80e0ca:	e8 ae 42 ff ff       	call   80237d <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  80e0cf:	89 f8                	mov    %edi,%eax
  80e0d1:	e8 ea ed ff ff       	call   80cec0 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80e0d6:	8d 47 04             	lea    0x4(%edi),%eax
  80e0d9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e0dd:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80e0e1:	89 04 24             	mov    %eax,(%esp)
  80e0e4:	e8 b3 7a ff ff       	call   805b9c <tcp_eff_send_mss>
  80e0e9:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  80e0ed:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80e0f4:	e8 87 9d ff ff       	call   807e80 <htonl>
  80e0f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80e0fc:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  80e103:	00 
  80e104:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e107:	89 44 24 14          	mov    %eax,0x14(%esp)
  80e10b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80e112:	00 
  80e113:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  80e11a:	00 
  80e11b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e122:	00 
  80e123:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e12a:	00 
  80e12b:	89 3c 24             	mov    %edi,(%esp)
  80e12e:	e8 d0 a8 ff ff       	call   808a03 <tcp_enqueue>
    return tcp_output(npcb);
  80e133:	89 3c 24             	mov    %edi,(%esp)
  80e136:	e8 90 a3 ff ff       	call   8084cb <tcp_output>
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  80e13b:	89 34 24             	mov    %esi,(%esp)
  80e13e:	e8 e1 70 ff ff       	call   805224 <pbuf_free>
        return;
  80e143:	e9 e9 07 00 00       	jmp    80e931 <tcp_input+0xd8a>
      }
      prev = (struct tcp_pcb *)lpcb;
  80e148:	89 df                	mov    %ebx,%edi
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80e14a:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80e14d:	85 db                	test   %ebx,%ebx
  80e14f:	0f 85 2f fe ff ff    	jne    80df84 <tcp_input+0x3dd>
  80e155:	e9 ac 07 00 00       	jmp    80e906 <tcp_input+0xd5f>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80e15a:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e160:	85 c0                	test   %eax,%eax
  80e162:	74 1e                	je     80e182 <tcp_input+0x5db>
  80e164:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80e16b:	00 
  80e16c:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e170:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e174:	8b 53 18             	mov    0x18(%ebx),%edx
  80e177:	89 14 24             	mov    %edx,(%esp)
  80e17a:	ff d0                	call   *%eax
      if (err == ERR_OK) {
  80e17c:	84 c0                	test   %al,%al
  80e17e:	74 0a                	je     80e18a <tcp_input+0x5e3>
  80e180:	eb 14                	jmp    80e196 <tcp_input+0x5ef>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80e182:	89 14 24             	mov    %edx,(%esp)
  80e185:	e8 9a 70 ff ff       	call   805224 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80e18a:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80e191:	00 00 00 
  80e194:	eb 0d                	jmp    80e1a3 <tcp_input+0x5fc>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  80e196:	89 34 24             	mov    %esi,(%esp)
  80e199:	e8 86 70 ff ff       	call   805224 <pbuf_free>
        return;
  80e19e:	e9 8e 07 00 00       	jmp    80e931 <tcp_input+0xd8a>
      }
    }

    tcp_input_pcb = pcb;
  80e1a3:	89 1d 58 b2 b3 00    	mov    %ebx,0xb3b258
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  80e1a9:	f6 05 c0 b1 b3 00 04 	testb  $0x4,0xb3b1c0
  80e1b0:	74 68                	je     80e21a <tcp_input+0x673>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  80e1b2:	8b 43 10             	mov    0x10(%ebx),%eax
  80e1b5:	83 f8 02             	cmp    $0x2,%eax
  80e1b8:	75 0e                	jne    80e1c8 <tcp_input+0x621>
  80e1ba:	8b 53 54             	mov    0x54(%ebx),%edx
  80e1bd:	3b 15 bc b1 b3 00    	cmp    0xb3b1bc,%edx
  80e1c3:	0f 94 c2             	sete   %dl
  80e1c6:	eb 1a                	jmp    80e1e2 <tcp_input+0x63b>
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80e1c8:	8b 15 b8 b1 b3 00    	mov    0xb3b1b8,%edx
  80e1ce:	2b 53 24             	sub    0x24(%ebx),%edx
  80e1d1:	0f 88 41 07 00 00    	js     80e918 <tcp_input+0xd71>
  80e1d7:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80e1db:	29 ca                	sub    %ecx,%edx
  80e1dd:	85 d2                	test   %edx,%edx
  80e1df:	0f 9e c2             	setle  %dl
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80e1e2:	84 d2                	test   %dl,%dl
  80e1e4:	0f 84 2e 07 00 00    	je     80e918 <tcp_input+0xd71>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80e1ea:	85 c0                	test   %eax,%eax
  80e1ec:	75 1c                	jne    80e20a <tcp_input+0x663>
  80e1ee:	c7 44 24 08 2c 33 81 	movl   $0x81332c,0x8(%esp)
  80e1f5:	00 
  80e1f6:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
  80e1fd:	00 
  80e1fe:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80e205:	e8 e2 0f 00 00       	call   80f1ec <_panic>
      recv_flags = TF_RESET;
  80e20a:	c6 05 c4 b1 b3 00 08 	movb   $0x8,0xb3b1c4
      pcb->flags &= ~TF_ACK_DELAY;
  80e211:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  80e215:	e9 fe 06 00 00       	jmp    80e918 <tcp_input+0xd71>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  80e21a:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80e21f:	89 43 2c             	mov    %eax,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80e222:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  80e229:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80e22d:	0f 87 04 05 00 00    	ja     80e737 <tcp_input+0xb90>
  80e233:	8b 43 10             	mov    0x10(%ebx),%eax
  80e236:	ff 24 85 d0 33 81 00 	jmp    *0x8133d0(,%eax,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80e23d:	0f b6 05 c0 b1 b3 00 	movzbl 0xb3b1c0,%eax
  80e244:	83 e0 12             	and    $0x12,%eax
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80e247:	83 f8 12             	cmp    $0x12,%eax
  80e24a:	0f 85 0c 01 00 00    	jne    80e35c <tcp_input+0x7b5>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80e250:	8b 43 78             	mov    0x78(%ebx),%eax
  80e253:	8b 40 10             	mov    0x10(%eax),%eax
  80e256:	8b 40 04             	mov    0x4(%eax),%eax
  80e259:	89 04 24             	mov    %eax,(%esp)
  80e25c:	e8 2b 9e ff ff       	call   80808c <ntohl>
  80e261:	83 c0 01             	add    $0x1,%eax
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80e264:	3b 05 bc b1 b3 00    	cmp    0xb3b1bc,%eax
  80e26a:	0f 85 ec 00 00 00    	jne    80e35c <tcp_input+0x7b5>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
  80e270:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80e275:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80e27a:	83 c0 01             	add    $0x1,%eax
  80e27d:	89 43 24             	mov    %eax,0x24(%ebx)
      pcb->lastack = ackno;
  80e280:	a1 bc b1 b3 00       	mov    0xb3b1bc,%eax
  80e285:	89 43 48             	mov    %eax,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80e288:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80e28d:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  80e291:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80e295:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80e29a:	83 e8 01             	sub    $0x1,%eax
  80e29d:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80e2a0:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  80e2a7:	89 d8                	mov    %ebx,%eax
  80e2a9:	e8 12 ec ff ff       	call   80cec0 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80e2ae:	8d 43 04             	lea    0x4(%ebx),%eax
  80e2b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e2b5:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80e2b9:	89 04 24             	mov    %eax,(%esp)
  80e2bc:	e8 db 78 ff ff       	call   805b9c <tcp_eff_send_mss>
  80e2c1:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  80e2c5:	6b d0 0a             	imul   $0xa,%eax,%edx
  80e2c8:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80e2cc:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80e2cf:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80e2d4:	0f 44 c2             	cmove  %edx,%eax
  80e2d7:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80e2db:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80e2df:	66 85 c0             	test   %ax,%ax
  80e2e2:	75 1c                	jne    80e300 <tcp_input+0x759>
  80e2e4:	c7 44 24 08 a5 33 81 	movl   $0x8133a5,0x8(%esp)
  80e2eb:	00 
  80e2ec:	c7 44 24 04 35 02 00 	movl   $0x235,0x4(%esp)
  80e2f3:	00 
  80e2f4:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80e2fb:	e8 ec 0e 00 00       	call   80f1ec <_panic>
      --pcb->snd_queuelen;
  80e300:	83 e8 01             	sub    $0x1,%eax
  80e303:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  80e307:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80e30a:	8b 10                	mov    (%eax),%edx
  80e30c:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80e30f:	85 d2                	test   %edx,%edx
  80e311:	75 08                	jne    80e31b <tcp_input+0x774>
        pcb->rtime = -1;
  80e313:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80e319:	eb 0a                	jmp    80e325 <tcp_input+0x77e>
      else {
        pcb->rtime = 0;
  80e31b:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80e321:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  80e325:	89 04 24             	mov    %eax,(%esp)
  80e328:	e8 f5 79 ff ff       	call   805d22 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80e32d:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80e333:	85 c0                	test   %eax,%eax
  80e335:	74 14                	je     80e34b <tcp_input+0x7a4>
  80e337:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e33e:	00 
  80e33f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e343:	8b 53 18             	mov    0x18(%ebx),%edx
  80e346:	89 14 24             	mov    %edx,(%esp)
  80e349:	ff d0                	call   *%eax
      tcp_ack_now(pcb);
  80e34b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e34f:	89 1c 24             	mov    %ebx,(%esp)
  80e352:	e8 74 a1 ff ff       	call   8084cb <tcp_output>
  80e357:	e9 bc 05 00 00       	jmp    80e918 <tcp_input+0xd71>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  80e35c:	f6 05 c0 b1 b3 00 10 	testb  $0x10,0xb3b1c0
  80e363:	0f 84 af 05 00 00    	je     80e918 <tcp_input+0xd71>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80e369:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80e36f:	a1 b4 b1 b3 00       	mov    0xb3b1b4,%eax
  80e374:	0f b7 0a             	movzwl (%edx),%ecx
  80e377:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80e37b:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e37f:	89 54 24 10          	mov    %edx,0x10(%esp)
  80e383:	8d 50 0c             	lea    0xc(%eax),%edx
  80e386:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e38a:	83 c0 10             	add    $0x10,%eax
  80e38d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e391:	0f b7 05 c2 b1 b3 00 	movzwl 0xb3b1c2,%eax
  80e398:	03 05 b8 b1 b3 00    	add    0xb3b1b8,%eax
  80e39e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e3a2:	a1 bc b1 b3 00       	mov    0xb3b1bc,%eax
  80e3a7:	89 04 24             	mov    %eax,(%esp)
  80e3aa:	e8 bd 9f ff ff       	call   80836c <tcp_rst>
  80e3af:	e9 64 05 00 00       	jmp    80e918 <tcp_input+0xd71>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  80e3b4:	0f b6 05 c0 b1 b3 00 	movzbl 0xb3b1c0,%eax
  80e3bb:	83 e0 14             	and    $0x14,%eax
  80e3be:	83 f8 10             	cmp    $0x10,%eax
  80e3c1:	0f 85 51 05 00 00    	jne    80e918 <tcp_input+0xd71>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80e3c7:	a1 bc b1 b3 00       	mov    0xb3b1bc,%eax
  80e3cc:	8b 53 48             	mov    0x48(%ebx),%edx
  80e3cf:	f7 d2                	not    %edx
  80e3d1:	01 c2                	add    %eax,%edx
  80e3d3:	0f 88 b7 00 00 00    	js     80e490 <tcp_input+0x8e9>
  80e3d9:	89 c2                	mov    %eax,%edx
  80e3db:	2b 53 54             	sub    0x54(%ebx),%edx
  80e3de:	85 d2                	test   %edx,%edx
  80e3e0:	0f 8f aa 00 00 00    	jg     80e490 <tcp_input+0x8e9>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  80e3e6:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80e3ed:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80e3f3:	85 c0                	test   %eax,%eax
  80e3f5:	75 1c                	jne    80e413 <tcp_input+0x86c>
  80e3f7:	c7 44 24 08 bb 33 81 	movl   $0x8133bb,0x8(%esp)
  80e3fe:	00 
  80e3ff:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
  80e406:	00 
  80e407:	c7 04 24 4c 33 81 00 	movl   $0x81334c,(%esp)
  80e40e:	e8 d9 0d 00 00       	call   80f1ec <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80e413:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e41a:	00 
  80e41b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e41f:	8b 53 18             	mov    0x18(%ebx),%edx
  80e422:	89 14 24             	mov    %edx,(%esp)
  80e425:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80e427:	84 c0                	test   %al,%al
  80e429:	74 17                	je     80e442 <tcp_input+0x89b>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  80e42b:	89 1c 24             	mov    %ebx,(%esp)
  80e42e:	e8 7b 7e ff ff       	call   8062ae <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e433:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80e43a:	00 00 00 
  80e43d:	e9 45 04 00 00       	jmp    80e887 <tcp_input+0xce0>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  80e442:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  80e446:	89 d8                	mov    %ebx,%eax
  80e448:	e8 20 eb ff ff       	call   80cf6d <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80e44d:	66 83 fe 01          	cmp    $0x1,%si
  80e451:	75 08                	jne    80e45b <tcp_input+0x8b4>
  80e453:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80e457:	01 d2                	add    %edx,%edx
  80e459:	eb 04                	jmp    80e45f <tcp_input+0x8b8>
  80e45b:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80e45f:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  80e463:	f6 05 c0 b1 b3 00 01 	testb  $0x1,0xb3b1c0
  80e46a:	0f 84 a8 04 00 00    	je     80e918 <tcp_input+0xd71>
  80e470:	84 c0                	test   %al,%al
  80e472:	0f 84 a0 04 00 00    	je     80e918 <tcp_input+0xd71>
          tcp_ack_now(pcb);
  80e478:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e47c:	89 1c 24             	mov    %ebx,(%esp)
  80e47f:	e8 47 a0 ff ff       	call   8084cb <tcp_output>
          pcb->state = CLOSE_WAIT;
  80e484:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80e48b:	e9 88 04 00 00       	jmp    80e918 <tcp_input+0xd71>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  80e490:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80e496:	8b 15 b4 b1 b3 00    	mov    0xb3b1b4,%edx
  80e49c:	0f b7 31             	movzwl (%ecx),%esi
  80e49f:	89 74 24 14          	mov    %esi,0x14(%esp)
  80e4a3:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80e4a7:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  80e4ab:	8d 4a 0c             	lea    0xc(%edx),%ecx
  80e4ae:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  80e4b2:	83 c2 10             	add    $0x10,%edx
  80e4b5:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e4b9:	0f b7 15 c2 b1 b3 00 	movzwl 0xb3b1c2,%edx
  80e4c0:	03 15 b8 b1 b3 00    	add    0xb3b1b8,%edx
  80e4c6:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e4ca:	89 04 24             	mov    %eax,(%esp)
  80e4cd:	e8 9a 9e ff ff       	call   80836c <tcp_rst>
  80e4d2:	e9 41 04 00 00       	jmp    80e918 <tcp_input+0xd71>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  80e4d7:	89 d8                	mov    %ebx,%eax
  80e4d9:	e8 8f ea ff ff       	call   80cf6d <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80e4de:	f6 05 c0 b1 b3 00 01 	testb  $0x1,0xb3b1c0
  80e4e5:	0f 84 2d 04 00 00    	je     80e918 <tcp_input+0xd71>
  80e4eb:	84 c0                	test   %al,%al
  80e4ed:	0f 84 25 04 00 00    	je     80e918 <tcp_input+0xd71>
      tcp_ack_now(pcb);
  80e4f3:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e4f7:	89 1c 24             	mov    %ebx,(%esp)
  80e4fa:	e8 cc 9f ff ff       	call   8084cb <tcp_output>
      pcb->state = CLOSE_WAIT;
  80e4ff:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80e506:	e9 0d 04 00 00       	jmp    80e918 <tcp_input+0xd71>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  80e50b:	89 d8                	mov    %ebx,%eax
  80e50d:	e8 5b ea ff ff       	call   80cf6d <tcp_receive>
    if (flags & TCP_FIN) {
  80e512:	0f b6 05 c0 b1 b3 00 	movzbl 0xb3b1c0,%eax
  80e519:	a8 01                	test   $0x1,%al
  80e51b:	0f 84 a1 00 00 00    	je     80e5c2 <tcp_input+0xa1b>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e521:	a8 10                	test   $0x10,%al
  80e523:	0f 84 81 00 00 00    	je     80e5aa <tcp_input+0xa03>
  80e529:	8b 43 54             	mov    0x54(%ebx),%eax
  80e52c:	3b 05 bc b1 b3 00    	cmp    0xb3b1bc,%eax
  80e532:	75 76                	jne    80e5aa <tcp_input+0xa03>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  80e534:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e538:	89 1c 24             	mov    %ebx,(%esp)
  80e53b:	e8 8b 9f ff ff       	call   8084cb <tcp_output>
        tcp_pcb_purge(pcb);
  80e540:	89 1c 24             	mov    %ebx,(%esp)
  80e543:	e8 4c 78 ff ff       	call   805d94 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80e548:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80e54d:	39 c3                	cmp    %eax,%ebx
  80e54f:	75 0a                	jne    80e55b <tcp_input+0x9b4>
  80e551:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e554:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80e559:	eb 29                	jmp    80e584 <tcp_input+0x9dd>
  80e55b:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80e560:	eb 19                	jmp    80e57b <tcp_input+0x9d4>
  80e562:	8b 50 0c             	mov    0xc(%eax),%edx
  80e565:	85 d2                	test   %edx,%edx
  80e567:	74 0c                	je     80e575 <tcp_input+0x9ce>
  80e569:	39 d3                	cmp    %edx,%ebx
  80e56b:	75 08                	jne    80e575 <tcp_input+0x9ce>
  80e56d:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e570:	89 50 0c             	mov    %edx,0xc(%eax)
  80e573:	eb 0f                	jmp    80e584 <tcp_input+0x9dd>
  80e575:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80e57b:	a1 48 b2 b3 00       	mov    0xb3b248,%eax
  80e580:	85 c0                	test   %eax,%eax
  80e582:	75 de                	jne    80e562 <tcp_input+0x9bb>
  80e584:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
        pcb->state = TIME_WAIT;
  80e58b:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80e592:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80e597:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e59a:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80e5a0:	e8 d8 3d ff ff       	call   80237d <tcp_timer_needed>
  80e5a5:	e9 6e 03 00 00       	jmp    80e918 <tcp_input+0xd71>
      } else {
        tcp_ack_now(pcb);
  80e5aa:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e5ae:	89 1c 24             	mov    %ebx,(%esp)
  80e5b1:	e8 15 9f ff ff       	call   8084cb <tcp_output>
        pcb->state = CLOSING;
  80e5b6:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80e5bd:	e9 56 03 00 00       	jmp    80e918 <tcp_input+0xd71>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e5c2:	a8 10                	test   $0x10,%al
  80e5c4:	0f 84 4e 03 00 00    	je     80e918 <tcp_input+0xd71>
  80e5ca:	8b 43 54             	mov    0x54(%ebx),%eax
  80e5cd:	3b 05 bc b1 b3 00    	cmp    0xb3b1bc,%eax
  80e5d3:	0f 85 3f 03 00 00    	jne    80e918 <tcp_input+0xd71>
      pcb->state = FIN_WAIT_2;
  80e5d9:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80e5e0:	e9 33 03 00 00       	jmp    80e918 <tcp_input+0xd71>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  80e5e5:	89 d8                	mov    %ebx,%eax
  80e5e7:	e8 81 e9 ff ff       	call   80cf6d <tcp_receive>
    if (flags & TCP_FIN) {
  80e5ec:	f6 05 c0 b1 b3 00 01 	testb  $0x1,0xb3b1c0
  80e5f3:	0f 84 1f 03 00 00    	je     80e918 <tcp_input+0xd71>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80e5f9:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e5fd:	89 1c 24             	mov    %ebx,(%esp)
  80e600:	e8 c6 9e ff ff       	call   8084cb <tcp_output>
      tcp_pcb_purge(pcb);
  80e605:	89 1c 24             	mov    %ebx,(%esp)
  80e608:	e8 87 77 ff ff       	call   805d94 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80e60d:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80e612:	39 c3                	cmp    %eax,%ebx
  80e614:	75 0a                	jne    80e620 <tcp_input+0xa79>
  80e616:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e619:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80e61e:	eb 29                	jmp    80e649 <tcp_input+0xaa2>
  80e620:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80e625:	eb 18                	jmp    80e63f <tcp_input+0xa98>
  80e627:	8b 42 0c             	mov    0xc(%edx),%eax
  80e62a:	85 c0                	test   %eax,%eax
  80e62c:	74 0c                	je     80e63a <tcp_input+0xa93>
  80e62e:	39 c3                	cmp    %eax,%ebx
  80e630:	75 08                	jne    80e63a <tcp_input+0xa93>
  80e632:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e635:	89 42 0c             	mov    %eax,0xc(%edx)
  80e638:	eb 0f                	jmp    80e649 <tcp_input+0xaa2>
  80e63a:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80e63f:	8b 15 48 b2 b3 00    	mov    0xb3b248,%edx
  80e645:	85 d2                	test   %edx,%edx
  80e647:	75 de                	jne    80e627 <tcp_input+0xa80>
  80e649:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      pcb->state = TIME_WAIT;
  80e650:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80e657:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80e65c:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e65f:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80e665:	e8 13 3d ff ff       	call   80237d <tcp_timer_needed>
  80e66a:	e9 a9 02 00 00       	jmp    80e918 <tcp_input+0xd71>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  80e66f:	89 d8                	mov    %ebx,%eax
  80e671:	e8 f7 e8 ff ff       	call   80cf6d <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e676:	f6 05 c0 b1 b3 00 10 	testb  $0x10,0xb3b1c0
  80e67d:	0f 84 95 02 00 00    	je     80e918 <tcp_input+0xd71>
  80e683:	8b 43 54             	mov    0x54(%ebx),%eax
  80e686:	3b 05 bc b1 b3 00    	cmp    0xb3b1bc,%eax
  80e68c:	0f 85 86 02 00 00    	jne    80e918 <tcp_input+0xd71>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80e692:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e696:	89 1c 24             	mov    %ebx,(%esp)
  80e699:	e8 2d 9e ff ff       	call   8084cb <tcp_output>
      tcp_pcb_purge(pcb);
  80e69e:	89 1c 24             	mov    %ebx,(%esp)
  80e6a1:	e8 ee 76 ff ff       	call   805d94 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80e6a6:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80e6ab:	39 c3                	cmp    %eax,%ebx
  80e6ad:	75 0a                	jne    80e6b9 <tcp_input+0xb12>
  80e6af:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e6b2:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80e6b7:	eb 29                	jmp    80e6e2 <tcp_input+0xb3b>
  80e6b9:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80e6be:	eb 19                	jmp    80e6d9 <tcp_input+0xb32>
  80e6c0:	8b 50 0c             	mov    0xc(%eax),%edx
  80e6c3:	85 d2                	test   %edx,%edx
  80e6c5:	74 0c                	je     80e6d3 <tcp_input+0xb2c>
  80e6c7:	39 d3                	cmp    %edx,%ebx
  80e6c9:	75 08                	jne    80e6d3 <tcp_input+0xb2c>
  80e6cb:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e6ce:	89 50 0c             	mov    %edx,0xc(%eax)
  80e6d1:	eb 0f                	jmp    80e6e2 <tcp_input+0xb3b>
  80e6d3:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80e6d9:	a1 48 b2 b3 00       	mov    0xb3b248,%eax
  80e6de:	85 c0                	test   %eax,%eax
  80e6e0:	75 de                	jne    80e6c0 <tcp_input+0xb19>
  80e6e2:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      pcb->state = TIME_WAIT;
  80e6e9:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80e6f0:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80e6f5:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e6f8:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80e6fe:	e8 7a 3c ff ff       	call   80237d <tcp_timer_needed>
  80e703:	e9 10 02 00 00       	jmp    80e918 <tcp_input+0xd71>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  80e708:	89 d8                	mov    %ebx,%eax
  80e70a:	e8 5e e8 ff ff       	call   80cf6d <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e70f:	f6 05 c0 b1 b3 00 10 	testb  $0x10,0xb3b1c0
  80e716:	0f 84 fc 01 00 00    	je     80e918 <tcp_input+0xd71>
  80e71c:	8b 43 54             	mov    0x54(%ebx),%eax
  80e71f:	3b 05 bc b1 b3 00    	cmp    0xb3b1bc,%eax
  80e725:	0f 85 ed 01 00 00    	jne    80e918 <tcp_input+0xd71>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  80e72b:	c6 05 c4 b1 b3 00 10 	movb   $0x10,0xb3b1c4
  80e732:	e9 e1 01 00 00       	jmp    80e918 <tcp_input+0xd71>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e737:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80e73e:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  80e741:	0f b6 05 c4 b1 b3 00 	movzbl 0xb3b1c4,%eax
  80e748:	a8 08                	test   $0x8,%al
  80e74a:	74 3f                	je     80e78b <tcp_input+0xbe4>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80e74c:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80e752:	85 c0                	test   %eax,%eax
  80e754:	74 10                	je     80e766 <tcp_input+0xbbf>
  80e756:	c7 44 24 04 fa ff ff 	movl   $0xfffffffa,0x4(%esp)
  80e75d:	ff 
  80e75e:	8b 53 18             	mov    0x18(%ebx),%edx
  80e761:	89 14 24             	mov    %edx,(%esp)
  80e764:	ff d0                	call   *%eax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e766:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e76a:	c7 04 24 3c b2 b3 00 	movl   $0xb3b23c,(%esp)
  80e771:	e8 97 76 ff ff       	call   805e0d <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e776:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e77a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e781:	e8 3e 63 ff ff       	call   804ac4 <memp_free>
  80e786:	e9 fc 00 00 00       	jmp    80e887 <tcp_input+0xce0>
      } else if (recv_flags & TF_CLOSED) {
  80e78b:	a8 10                	test   $0x10,%al
  80e78d:	74 25                	je     80e7b4 <tcp_input+0xc0d>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e78f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e793:	c7 04 24 3c b2 b3 00 	movl   $0xb3b23c,(%esp)
  80e79a:	e8 6e 76 ff ff       	call   805e0d <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e79f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e7a3:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e7aa:	e8 15 63 ff ff       	call   804ac4 <memp_free>
  80e7af:	e9 d3 00 00 00       	jmp    80e887 <tcp_input+0xce0>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80e7b4:	0f b7 43 6c          	movzwl 0x6c(%ebx),%eax
  80e7b8:	66 85 c0             	test   %ax,%ax
  80e7bb:	74 1f                	je     80e7dc <tcp_input+0xc35>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80e7bd:	8b 93 84 00 00 00    	mov    0x84(%ebx),%edx
  80e7c3:	85 d2                	test   %edx,%edx
  80e7c5:	74 15                	je     80e7dc <tcp_input+0xc35>
  80e7c7:	0f b7 c0             	movzwl %ax,%eax
  80e7ca:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e7ce:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e7d2:	8b 43 18             	mov    0x18(%ebx),%eax
  80e7d5:	89 04 24             	mov    %eax,(%esp)
  80e7d8:	ff d2                	call   *%edx
  80e7da:	eb 05                	jmp    80e7e1 <tcp_input+0xc3a>
  80e7dc:	b8 00 00 00 00       	mov    $0x0,%eax
        }
      
        if (recv_data != NULL) {
  80e7e1:	8b 15 c8 b1 b3 00    	mov    0xb3b1c8,%edx
  80e7e7:	85 d2                	test   %edx,%edx
  80e7e9:	74 61                	je     80e84c <tcp_input+0xca5>
          if(flags & TCP_PSH) {
  80e7eb:	f6 05 c0 b1 b3 00 08 	testb  $0x8,0xb3b1c0
  80e7f2:	74 04                	je     80e7f8 <tcp_input+0xc51>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80e7f4:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e7f8:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e7fe:	85 c0                	test   %eax,%eax
  80e800:	74 24                	je     80e826 <tcp_input+0xc7f>
  80e802:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80e809:	00 
  80e80a:	8b 15 c8 b1 b3 00    	mov    0xb3b1c8,%edx
  80e810:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e814:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e818:	8b 53 18             	mov    0x18(%ebx),%edx
  80e81b:	89 14 24             	mov    %edx,(%esp)
  80e81e:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  80e820:	84 c0                	test   %al,%al
  80e822:	75 1c                	jne    80e840 <tcp_input+0xc99>
  80e824:	eb 26                	jmp    80e84c <tcp_input+0xca5>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e826:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e82b:	85 c0                	test   %eax,%eax
  80e82d:	0f 84 f4 00 00 00    	je     80e927 <tcp_input+0xd80>
  80e833:	89 04 24             	mov    %eax,(%esp)
  80e836:	e8 e9 69 ff ff       	call   805224 <pbuf_free>
  80e83b:	e9 e7 00 00 00       	jmp    80e927 <tcp_input+0xd80>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  80e840:	8b 15 c8 b1 b3 00    	mov    0xb3b1c8,%edx
  80e846:	89 93 80 00 00 00    	mov    %edx,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80e84c:	f6 05 c4 b1 b3 00 20 	testb  $0x20,0xb3b1c4
  80e853:	74 26                	je     80e87b <tcp_input+0xcd4>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80e855:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e85b:	85 c0                	test   %eax,%eax
  80e85d:	74 20                	je     80e87f <tcp_input+0xcd8>
  80e85f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80e866:	00 
  80e867:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e86e:	00 
  80e86f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e873:	8b 53 18             	mov    0x18(%ebx),%edx
  80e876:	89 14 24             	mov    %edx,(%esp)
  80e879:	ff d0                	call   *%eax
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  80e87b:	84 c0                	test   %al,%al
  80e87d:	75 08                	jne    80e887 <tcp_input+0xce0>
          tcp_output(pcb);
  80e87f:	89 1c 24             	mov    %ebx,(%esp)
  80e882:	e8 44 9c ff ff       	call   8084cb <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  80e887:	a1 a0 b1 b3 00       	mov    0xb3b1a0,%eax
  80e88c:	85 c0                	test   %eax,%eax
  80e88e:	0f 84 9d 00 00 00    	je     80e931 <tcp_input+0xd8a>
    {
      pbuf_free(inseg.p);
  80e894:	89 04 24             	mov    %eax,(%esp)
  80e897:	e8 88 69 ff ff       	call   805224 <pbuf_free>
      inseg.p = NULL;
  80e89c:	c7 05 a0 b1 b3 00 00 	movl   $0x0,0xb3b1a0
  80e8a3:	00 00 00 
  80e8a6:	e9 86 00 00 00       	jmp    80e931 <tcp_input+0xd8a>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80e8ab:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  80e8b1:	a1 b4 b1 b3 00       	mov    0xb3b1b4,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  80e8b6:	0f b7 0a             	movzwl (%edx),%ecx
  80e8b9:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80e8bd:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e8c1:	89 54 24 10          	mov    %edx,0x10(%esp)
  80e8c5:	8d 50 0c             	lea    0xc(%eax),%edx
  80e8c8:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e8cc:	83 c0 10             	add    $0x10,%eax
  80e8cf:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e8d3:	0f b7 05 c2 b1 b3 00 	movzwl 0xb3b1c2,%eax
  80e8da:	03 05 b8 b1 b3 00    	add    0xb3b1b8,%eax
  80e8e0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e8e4:	a1 bc b1 b3 00       	mov    0xb3b1bc,%eax
  80e8e9:	89 04 24             	mov    %eax,(%esp)
  80e8ec:	e8 7b 9a ff ff       	call   80836c <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  80e8f1:	89 34 24             	mov    %esi,(%esp)
  80e8f4:	e8 2b 69 ff ff       	call   805224 <pbuf_free>
  80e8f9:	eb 36                	jmp    80e931 <tcp_input+0xd8a>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80e8fb:	8b 1d 50 b2 b3 00    	mov    0xb3b250,%ebx
  80e901:	e9 66 f6 ff ff       	jmp    80df6c <tcp_input+0x3c5>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80e906:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80e90a:	89 04 24             	mov    %eax,(%esp)
  80e90d:	e8 5a 95 ff ff       	call   807e6c <ntohs>
  80e912:	a8 04                	test   $0x4,%al
  80e914:	75 db                	jne    80e8f1 <tcp_input+0xd4a>
  80e916:	eb 93                	jmp    80e8ab <tcp_input+0xd04>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e918:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80e91f:	00 00 00 
  80e922:	e9 1a fe ff ff       	jmp    80e741 <tcp_input+0xb9a>
  80e927:	b8 00 00 00 00       	mov    $0x0,%eax
  80e92c:	e9 1b ff ff ff       	jmp    80e84c <tcp_input+0xca5>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  80e931:	83 c4 4c             	add    $0x4c,%esp
  80e934:	5b                   	pop    %ebx
  80e935:	5e                   	pop    %esi
  80e936:	5f                   	pop    %edi
  80e937:	5d                   	pop    %ebp
  80e938:	c3                   	ret    
  80e939:	00 00                	add    %al,(%eax)
	...

0080e93c <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e93c:	55                   	push   %ebp
  80e93d:	89 e5                	mov    %esp,%ebp
  80e93f:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  80e942:	b8 00 00 00 00       	mov    $0x0,%eax
  80e947:	85 d2                	test   %edx,%edx
  80e949:	74 02                	je     80e94d <raw_bind+0x11>
  80e94b:	8b 02                	mov    (%edx),%eax
  80e94d:	8b 55 08             	mov    0x8(%ebp),%edx
  80e950:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  80e952:	b8 00 00 00 00       	mov    $0x0,%eax
  80e957:	5d                   	pop    %ebp
  80e958:	c3                   	ret    

0080e959 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e959:	55                   	push   %ebp
  80e95a:	89 e5                	mov    %esp,%ebp
  80e95c:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80e95f:	b8 00 00 00 00       	mov    $0x0,%eax
  80e964:	85 d2                	test   %edx,%edx
  80e966:	74 02                	je     80e96a <raw_connect+0x11>
  80e968:	8b 02                	mov    (%edx),%eax
  80e96a:	8b 55 08             	mov    0x8(%ebp),%edx
  80e96d:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  80e970:	b8 00 00 00 00       	mov    $0x0,%eax
  80e975:	5d                   	pop    %ebp
  80e976:	c3                   	ret    

0080e977 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80e977:	55                   	push   %ebp
  80e978:	89 e5                	mov    %esp,%ebp
  80e97a:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80e97d:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e980:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80e983:	8b 55 10             	mov    0x10(%ebp),%edx
  80e986:	89 50 18             	mov    %edx,0x18(%eax)
}
  80e989:	5d                   	pop    %ebp
  80e98a:	c3                   	ret    

0080e98b <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80e98b:	55                   	push   %ebp
  80e98c:	89 e5                	mov    %esp,%ebp
  80e98e:	83 ec 18             	sub    $0x18,%esp
  80e991:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80e994:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80e997:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80e99b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e9a2:	e8 61 61 ff ff       	call   804b08 <memp_malloc>
  80e9a7:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80e9a9:	85 c0                	test   %eax,%eax
  80e9ab:	74 2f                	je     80e9dc <raw_new+0x51>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80e9ad:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80e9b4:	00 
  80e9b5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e9bc:	00 
  80e9bd:	89 04 24             	mov    %eax,(%esp)
  80e9c0:	e8 8b 10 00 00       	call   80fa50 <memset>
    pcb->protocol = proto;
  80e9c5:	89 f0                	mov    %esi,%eax
  80e9c7:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80e9ca:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80e9ce:	a1 cc b1 b3 00       	mov    0xb3b1cc,%eax
  80e9d3:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80e9d6:	89 1d cc b1 b3 00    	mov    %ebx,0xb3b1cc
  }
  return pcb;
}
  80e9dc:	89 d8                	mov    %ebx,%eax
  80e9de:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80e9e1:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80e9e4:	89 ec                	mov    %ebp,%esp
  80e9e6:	5d                   	pop    %ebp
  80e9e7:	c3                   	ret    

0080e9e8 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80e9e8:	55                   	push   %ebp
  80e9e9:	89 e5                	mov    %esp,%ebp
  80e9eb:	83 ec 18             	sub    $0x18,%esp
  80e9ee:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80e9f1:	a1 cc b1 b3 00       	mov    0xb3b1cc,%eax
  80e9f6:	39 c8                	cmp    %ecx,%eax
  80e9f8:	75 1e                	jne    80ea18 <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80e9fa:	8b 40 0c             	mov    0xc(%eax),%eax
  80e9fd:	a3 cc b1 b3 00       	mov    %eax,0xb3b1cc
  80ea02:	eb 18                	jmp    80ea1c <raw_remove+0x34>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80ea04:	8b 50 0c             	mov    0xc(%eax),%edx
  80ea07:	85 d2                	test   %edx,%edx
  80ea09:	74 0a                	je     80ea15 <raw_remove+0x2d>
  80ea0b:	39 d1                	cmp    %edx,%ecx
  80ea0d:	75 06                	jne    80ea15 <raw_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80ea0f:	8b 51 0c             	mov    0xc(%ecx),%edx
  80ea12:	89 50 0c             	mov    %edx,0xc(%eax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80ea15:	8b 40 0c             	mov    0xc(%eax),%eax
  80ea18:	85 c0                	test   %eax,%eax
  80ea1a:	75 e8                	jne    80ea04 <raw_remove+0x1c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80ea1c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80ea20:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ea27:	e8 98 60 ff ff       	call   804ac4 <memp_free>
}
  80ea2c:	c9                   	leave  
  80ea2d:	c3                   	ret    

0080ea2e <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80ea2e:	55                   	push   %ebp
  80ea2f:	89 e5                	mov    %esp,%ebp
  80ea31:	57                   	push   %edi
  80ea32:	56                   	push   %esi
  80ea33:	53                   	push   %ebx
  80ea34:	83 ec 3c             	sub    $0x3c,%esp
  80ea37:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ea3a:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80ea3d:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80ea44:	00 
  80ea45:	89 3c 24             	mov    %edi,(%esp)
  80ea48:	e8 7a 64 ff ff       	call   804ec7 <pbuf_header>
  80ea4d:	84 c0                	test   %al,%al
  80ea4f:	74 38                	je     80ea89 <raw_sendto+0x5b>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80ea51:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ea58:	00 
  80ea59:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ea60:	00 
  80ea61:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ea68:	e8 72 6a ff ff       	call   8054df <pbuf_alloc>
  80ea6d:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80ea6f:	c6 45 e7 ff          	movb   $0xff,-0x19(%ebp)
  80ea73:	85 c0                	test   %eax,%eax
  80ea75:	0f 84 b1 00 00 00    	je     80eb2c <raw_sendto+0xfe>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80ea7b:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80ea7f:	89 04 24             	mov    %eax,(%esp)
  80ea82:	e8 19 64 ff ff       	call   804ea0 <pbuf_chain>
  80ea87:	eb 32                	jmp    80eabb <raw_sendto+0x8d>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  80ea89:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80ea90:	ff 
  80ea91:	89 3c 24             	mov    %edi,(%esp)
  80ea94:	e8 2e 64 ff ff       	call   804ec7 <pbuf_header>
  80ea99:	84 c0                	test   %al,%al
  80ea9b:	74 1c                	je     80eab9 <raw_sendto+0x8b>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80ea9d:	c7 44 24 08 f8 33 81 	movl   $0x8133f8,0x8(%esp)
  80eaa4:	00 
  80eaa5:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  80eaac:	00 
  80eaad:	c7 04 24 1e 34 81 00 	movl   $0x81341e,(%esp)
  80eab4:	e8 33 07 00 00       	call   80f1ec <_panic>
  80eab9:	89 fe                	mov    %edi,%esi
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80eabb:	8b 45 10             	mov    0x10(%ebp),%eax
  80eabe:	89 04 24             	mov    %eax,(%esp)
  80eac1:	e8 7b 82 ff ff       	call   806d41 <ip_route>
  80eac6:	85 c0                	test   %eax,%eax
  80eac8:	75 16                	jne    80eae0 <raw_sendto+0xb2>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80eaca:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  80eace:	39 fe                	cmp    %edi,%esi
  80ead0:	74 5a                	je     80eb2c <raw_sendto+0xfe>
      pbuf_free(q);
  80ead2:	89 34 24             	mov    %esi,(%esp)
  80ead5:	e8 4a 67 ff ff       	call   805224 <pbuf_free>
  80eada:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  80eade:	eb 4c                	jmp    80eb2c <raw_sendto+0xfe>
    }
    return ERR_RTE;
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80eae0:	89 da                	mov    %ebx,%edx
  80eae2:	85 db                	test   %ebx,%ebx
  80eae4:	74 05                	je     80eaeb <raw_sendto+0xbd>
  80eae6:	83 3b 00             	cmpl   $0x0,(%ebx)
  80eae9:	75 03                	jne    80eaee <raw_sendto+0xc0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80eaeb:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80eaee:	89 44 24 18          	mov    %eax,0x18(%esp)
  80eaf2:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80eaf6:	89 44 24 14          	mov    %eax,0x14(%esp)
  80eafa:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80eafe:	89 44 24 10          	mov    %eax,0x10(%esp)
  80eb02:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80eb06:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80eb0a:	8b 45 10             	mov    0x10(%ebp),%eax
  80eb0d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80eb11:	89 54 24 04          	mov    %edx,0x4(%esp)
  80eb15:	89 34 24             	mov    %esi,(%esp)
  80eb18:	e8 73 80 ff ff       	call   806b90 <ip_output_if>
  80eb1d:	88 45 e7             	mov    %al,-0x19(%ebp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80eb20:	39 fe                	cmp    %edi,%esi
  80eb22:	74 08                	je     80eb2c <raw_sendto+0xfe>
    /* free the header */
    pbuf_free(q);
  80eb24:	89 34 24             	mov    %esi,(%esp)
  80eb27:	e8 f8 66 ff ff       	call   805224 <pbuf_free>
  }
  return err;
}
  80eb2c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80eb30:	83 c4 3c             	add    $0x3c,%esp
  80eb33:	5b                   	pop    %ebx
  80eb34:	5e                   	pop    %esi
  80eb35:	5f                   	pop    %edi
  80eb36:	5d                   	pop    %ebp
  80eb37:	c3                   	ret    

0080eb38 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80eb38:	55                   	push   %ebp
  80eb39:	89 e5                	mov    %esp,%ebp
  80eb3b:	83 ec 18             	sub    $0x18,%esp
  80eb3e:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80eb41:	8d 50 04             	lea    0x4(%eax),%edx
  80eb44:	89 54 24 08          	mov    %edx,0x8(%esp)
  80eb48:	8b 55 0c             	mov    0xc(%ebp),%edx
  80eb4b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80eb4f:	89 04 24             	mov    %eax,(%esp)
  80eb52:	e8 d7 fe ff ff       	call   80ea2e <raw_sendto>
}
  80eb57:	c9                   	leave  
  80eb58:	c3                   	ret    

0080eb59 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80eb59:	55                   	push   %ebp
  80eb5a:	89 e5                	mov    %esp,%ebp
  80eb5c:	57                   	push   %edi
  80eb5d:	56                   	push   %esi
  80eb5e:	53                   	push   %ebx
  80eb5f:	83 ec 2c             	sub    $0x2c,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80eb62:	8b 45 08             	mov    0x8(%ebp),%eax
  80eb65:	8b 70 04             	mov    0x4(%eax),%esi
  proto = IPH_PROTO(iphdr);
  80eb68:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80eb6c:	89 04 24             	mov    %eax,(%esp)
  80eb6f:	e8 f8 92 ff ff       	call   807e6c <ntohs>

  prev = NULL;
  pcb = raw_pcbs;
  80eb74:	8b 1d cc b1 b3 00    	mov    0xb3b1cc,%ebx
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80eb7a:	83 c6 0c             	add    $0xc,%esi
  80eb7d:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80eb80:	be 00 00 00 00       	mov    $0x0,%esi
  80eb85:	bf 00 00 00 00       	mov    $0x0,%edi
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  80eb8a:	0f b6 c0             	movzbl %al,%eax
  80eb8d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80eb90:	eb 5e                	jmp    80ebf0 <raw_input+0x97>
    if (pcb->protocol == proto) {
  80eb92:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80eb96:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  80eb99:	75 50                	jne    80ebeb <raw_input+0x92>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  80eb9b:	8b 43 14             	mov    0x14(%ebx),%eax
  80eb9e:	85 c0                	test   %eax,%eax
  80eba0:	74 49                	je     80ebeb <raw_input+0x92>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80eba2:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80eba5:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80eba9:	8b 55 08             	mov    0x8(%ebp),%edx
  80ebac:	89 54 24 08          	mov    %edx,0x8(%esp)
  80ebb0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ebb4:	8b 53 18             	mov    0x18(%ebx),%edx
  80ebb7:	89 14 24             	mov    %edx,(%esp)
  80ebba:	ff d0                	call   *%eax
  80ebbc:	84 c0                	test   %al,%al
  80ebbe:	74 2b                	je     80ebeb <raw_input+0x92>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  80ebc0:	be 01 00 00 00       	mov    $0x1,%esi
  80ebc5:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80ebcc:	85 ff                	test   %edi,%edi
  80ebce:	74 1b                	je     80ebeb <raw_input+0x92>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  80ebd0:	8b 43 0c             	mov    0xc(%ebx),%eax
  80ebd3:	89 47 0c             	mov    %eax,0xc(%edi)
            pcb->next = raw_pcbs;
  80ebd6:	a1 cc b1 b3 00       	mov    0xb3b1cc,%eax
  80ebdb:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80ebde:	89 1d cc b1 b3 00    	mov    %ebx,0xb3b1cc
  80ebe4:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  80ebeb:	89 df                	mov    %ebx,%edi
  80ebed:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80ebf0:	89 f0                	mov    %esi,%eax
  80ebf2:	84 c0                	test   %al,%al
  80ebf4:	75 04                	jne    80ebfa <raw_input+0xa1>
  80ebf6:	85 db                	test   %ebx,%ebx
  80ebf8:	75 98                	jne    80eb92 <raw_input+0x39>
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  80ebfa:	89 f0                	mov    %esi,%eax
  80ebfc:	83 c4 2c             	add    $0x2c,%esp
  80ebff:	5b                   	pop    %ebx
  80ec00:	5e                   	pop    %esi
  80ec01:	5f                   	pop    %edi
  80ec02:	5d                   	pop    %ebp
  80ec03:	c3                   	ret    
	...

0080ec10 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80ec10:	55                   	push   %ebp
  80ec11:	89 e5                	mov    %esp,%ebp
  80ec13:	57                   	push   %edi
  80ec14:	56                   	push   %esi
  80ec15:	53                   	push   %ebx
  80ec16:	83 ec 3c             	sub    $0x3c,%esp
  80ec19:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80ec1c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ec23:	00 
  80ec24:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  80ec2b:	00 
  80ec2c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ec33:	e8 a7 68 ff ff       	call   8054df <pbuf_alloc>
  80ec38:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80ec3a:	85 c0                	test   %eax,%eax
  80ec3c:	0f 84 d8 00 00 00    	je     80ed1a <icmp_time_exceeded+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80ec42:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80ec47:	77 1c                	ja     80ec65 <icmp_time_exceeded+0x55>
  80ec49:	c7 44 24 08 34 34 81 	movl   $0x813434,0x8(%esp)
  80ec50:	00 
  80ec51:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
  80ec58:	00 
  80ec59:	c7 04 24 26 35 81 00 	movl   $0x813526,(%esp)
  80ec60:	e8 87 05 00 00       	call   80f1ec <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80ec65:	8b 47 04             	mov    0x4(%edi),%eax
  80ec68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80ec6b:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80ec6e:	0f b7 06             	movzwl (%esi),%eax
  80ec71:	89 04 24             	mov    %eax,(%esp)
  80ec74:	e8 f3 91 ff ff       	call   807e6c <ntohs>
  80ec79:	0f b6 c0             	movzbl %al,%eax
  80ec7c:	80 cc 0b             	or     $0xb,%ah
  80ec7f:	89 04 24             	mov    %eax,(%esp)
  80ec82:	e8 d8 91 ff ff       	call   807e5f <htons>
  80ec87:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80ec8a:	0f b7 c0             	movzwl %ax,%eax
  80ec8d:	89 04 24             	mov    %eax,(%esp)
  80ec90:	e8 d7 91 ff ff       	call   807e6c <ntohs>
  80ec95:	b0 00                	mov    $0x0,%al
  80ec97:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80ec9b:	0f b7 c0             	movzwl %ax,%eax
  80ec9e:	89 04 24             	mov    %eax,(%esp)
  80eca1:	e8 b9 91 ff ff       	call   807e5f <htons>
  80eca6:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80eca9:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80ecb0:	00 
  80ecb1:	8b 47 04             	mov    0x4(%edi),%eax
  80ecb4:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ecb8:	8b 43 04             	mov    0x4(%ebx),%eax
  80ecbb:	83 c0 08             	add    $0x8,%eax
  80ecbe:	89 04 24             	mov    %eax,(%esp)
  80ecc1:	e8 65 0e 00 00       	call   80fb2b <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80ecc6:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80eccc:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80ecd0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ecd4:	89 34 24             	mov    %esi,(%esp)
  80ecd7:	e8 86 8e ff ff       	call   807b62 <inet_chksum>
  80ecdc:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80ece0:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80ece7:	00 
  80ece8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80ecef:	00 
  80ecf0:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80ecf7:	00 
  80ecf8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ecfb:	83 c0 0c             	add    $0xc,%eax
  80ecfe:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ed02:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ed09:	00 
  80ed0a:	89 1c 24             	mov    %ebx,(%esp)
  80ed0d:	e8 81 80 ff ff       	call   806d93 <ip_output>
  pbuf_free(q);
  80ed12:	89 1c 24             	mov    %ebx,(%esp)
  80ed15:	e8 0a 65 ff ff       	call   805224 <pbuf_free>
}
  80ed1a:	83 c4 3c             	add    $0x3c,%esp
  80ed1d:	5b                   	pop    %ebx
  80ed1e:	5e                   	pop    %esi
  80ed1f:	5f                   	pop    %edi
  80ed20:	5d                   	pop    %ebp
  80ed21:	c3                   	ret    

0080ed22 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80ed22:	55                   	push   %ebp
  80ed23:	89 e5                	mov    %esp,%ebp
  80ed25:	57                   	push   %edi
  80ed26:	56                   	push   %esi
  80ed27:	53                   	push   %ebx
  80ed28:	83 ec 3c             	sub    $0x3c,%esp
  80ed2b:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80ed2e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ed35:	00 
  80ed36:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  80ed3d:	00 
  80ed3e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ed45:	e8 95 67 ff ff       	call   8054df <pbuf_alloc>
  80ed4a:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80ed4c:	85 c0                	test   %eax,%eax
  80ed4e:	0f 84 d8 00 00 00    	je     80ee2c <icmp_dest_unreach+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80ed54:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80ed59:	77 1c                	ja     80ed77 <icmp_dest_unreach+0x55>
  80ed5b:	c7 44 24 08 34 34 81 	movl   $0x813434,0x8(%esp)
  80ed62:	00 
  80ed63:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
  80ed6a:	00 
  80ed6b:	c7 04 24 26 35 81 00 	movl   $0x813526,(%esp)
  80ed72:	e8 75 04 00 00       	call   80f1ec <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80ed77:	8b 47 04             	mov    0x4(%edi),%eax
  80ed7a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  idur = q->payload;
  80ed7d:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80ed80:	0f b7 06             	movzwl (%esi),%eax
  80ed83:	89 04 24             	mov    %eax,(%esp)
  80ed86:	e8 e1 90 ff ff       	call   807e6c <ntohs>
  80ed8b:	0f b6 c0             	movzbl %al,%eax
  80ed8e:	80 cc 03             	or     $0x3,%ah
  80ed91:	89 04 24             	mov    %eax,(%esp)
  80ed94:	e8 c6 90 ff ff       	call   807e5f <htons>
  80ed99:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80ed9c:	0f b7 c0             	movzwl %ax,%eax
  80ed9f:	89 04 24             	mov    %eax,(%esp)
  80eda2:	e8 c5 90 ff ff       	call   807e6c <ntohs>
  80eda7:	b0 00                	mov    $0x0,%al
  80eda9:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80edad:	0f b7 c0             	movzwl %ax,%eax
  80edb0:	89 04 24             	mov    %eax,(%esp)
  80edb3:	e8 a7 90 ff ff       	call   807e5f <htons>
  80edb8:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80edbb:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80edc2:	00 
  80edc3:	8b 47 04             	mov    0x4(%edi),%eax
  80edc6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80edca:	8b 43 04             	mov    0x4(%ebx),%eax
  80edcd:	83 c0 08             	add    $0x8,%eax
  80edd0:	89 04 24             	mov    %eax,(%esp)
  80edd3:	e8 53 0d 00 00       	call   80fb2b <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80edd8:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80edde:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80ede2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ede6:	89 34 24             	mov    %esi,(%esp)
  80ede9:	e8 74 8d ff ff       	call   807b62 <inet_chksum>
  80edee:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80edf2:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80edf9:	00 
  80edfa:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80ee01:	00 
  80ee02:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80ee09:	00 
  80ee0a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ee0d:	83 c0 0c             	add    $0xc,%eax
  80ee10:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ee14:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ee1b:	00 
  80ee1c:	89 1c 24             	mov    %ebx,(%esp)
  80ee1f:	e8 6f 7f ff ff       	call   806d93 <ip_output>
  pbuf_free(q);
  80ee24:	89 1c 24             	mov    %ebx,(%esp)
  80ee27:	e8 f8 63 ff ff       	call   805224 <pbuf_free>
}
  80ee2c:	83 c4 3c             	add    $0x3c,%esp
  80ee2f:	5b                   	pop    %ebx
  80ee30:	5e                   	pop    %esi
  80ee31:	5f                   	pop    %edi
  80ee32:	5d                   	pop    %ebp
  80ee33:	c3                   	ret    

0080ee34 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80ee34:	55                   	push   %ebp
  80ee35:	89 e5                	mov    %esp,%ebp
  80ee37:	83 ec 48             	sub    $0x48,%esp
  80ee3a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ee3d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ee40:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80ee43:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80ee46:	8b 73 04             	mov    0x4(%ebx),%esi
  hlen = IPH_HL(iphdr) * 4;
  80ee49:	0f b7 06             	movzwl (%esi),%eax
  80ee4c:	89 04 24             	mov    %eax,(%esp)
  80ee4f:	e8 18 90 ff ff       	call   807e6c <ntohs>
  80ee54:	66 c1 e8 06          	shr    $0x6,%ax
  80ee58:	83 e0 3c             	and    $0x3c,%eax
  80ee5b:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80ee5f:	89 c7                	mov    %eax,%edi
  80ee61:	f7 df                	neg    %edi
  80ee63:	0f bf ff             	movswl %di,%edi
  80ee66:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80ee6a:	89 1c 24             	mov    %ebx,(%esp)
  80ee6d:	e8 55 60 ff ff       	call   804ec7 <pbuf_header>
  80ee72:	84 c0                	test   %al,%al
  80ee74:	0f 85 ec 02 00 00    	jne    80f166 <icmp_input+0x332>
  80ee7a:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80ee7f:	0f 86 e1 02 00 00    	jbe    80f166 <icmp_input+0x332>

  type = *((u8_t *)p->payload);
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80ee85:	8b 43 04             	mov    0x4(%ebx),%eax
  80ee88:	80 38 08             	cmpb   $0x8,(%eax)
  80ee8b:	0f 85 cb 02 00 00    	jne    80f15c <icmp_input+0x328>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80ee91:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ee94:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ee98:	8d 46 10             	lea    0x10(%esi),%eax
  80ee9b:	89 04 24             	mov    %eax,(%esp)
  80ee9e:	e8 9d 7c ff ff       	call   806b40 <ip_addr_isbroadcast>
  80eea3:	84 c0                	test   %al,%al
  80eea5:	75 2b                	jne    80eed2 <icmp_input+0x9e>
  80eea7:	8b 56 10             	mov    0x10(%esi),%edx
  80eeaa:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eead:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80eeb4:	e8 d3 91 ff ff       	call   80808c <ntohl>
  80eeb9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80eebc:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80eec3:	e8 c4 91 ff ff       	call   80808c <ntohl>
  80eec8:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80eecb:	23 55 dc             	and    -0x24(%ebp),%edx
  80eece:	39 c2                	cmp    %eax,%edx
  80eed0:	75 0d                	jne    80eedf <icmp_input+0xab>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  80eed2:	89 1c 24             	mov    %ebx,(%esp)
  80eed5:	e8 4a 63 ff ff       	call   805224 <pbuf_free>
      return;
  80eeda:	e9 9b 02 00 00       	jmp    80f17a <icmp_input+0x346>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80eedf:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80eee4:	0f 86 7c 02 00 00    	jbe    80f166 <icmp_input+0x332>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  80eeea:	89 1c 24             	mov    %ebx,(%esp)
  80eeed:	e8 ed 8b ff ff       	call   807adf <inet_chksum_pbuf>
  80eef2:	66 85 c0             	test   %ax,%ax
  80eef5:	74 0e                	je     80ef05 <icmp_input+0xd1>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  80eef7:	89 1c 24             	mov    %ebx,(%esp)
  80eefa:	e8 25 63 ff ff       	call   805224 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  80eeff:	90                   	nop
  80ef00:	e9 75 02 00 00       	jmp    80f17a <icmp_input+0x346>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80ef05:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  80ef0c:	00 
  80ef0d:	89 1c 24             	mov    %ebx,(%esp)
  80ef10:	e8 b2 5f ff ff       	call   804ec7 <pbuf_header>
  80ef15:	84 c0                	test   %al,%al
  80ef17:	0f 84 f0 00 00 00    	je     80f00d <icmp_input+0x1d9>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  80ef1d:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80ef21:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ef25:	89 1c 24             	mov    %ebx,(%esp)
  80ef28:	e8 9a 5f ff ff       	call   804ec7 <pbuf_header>
  80ef2d:	84 c0                	test   %al,%al
  80ef2f:	74 1c                	je     80ef4d <icmp_input+0x119>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80ef31:	c7 44 24 08 60 34 81 	movl   $0x813460,0x8(%esp)
  80ef38:	00 
  80ef39:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  80ef40:	00 
  80ef41:	c7 04 24 26 35 81 00 	movl   $0x813526,(%esp)
  80ef48:	e8 9f 02 00 00       	call   80f1ec <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80ef4d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ef54:	00 
  80ef55:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80ef59:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ef5d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80ef64:	e8 76 65 ff ff       	call   8054df <pbuf_alloc>
  80ef69:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80ef6c:	85 c0                	test   %eax,%eax
  80ef6e:	0f 84 fe 01 00 00    	je     80f172 <icmp_input+0x33e>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80ef74:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80ef78:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80ef7c:	83 c0 08             	add    $0x8,%eax
  80ef7f:	39 c2                	cmp    %eax,%edx
  80ef81:	73 1c                	jae    80ef9f <icmp_input+0x16b>
  80ef83:	c7 44 24 08 94 34 81 	movl   $0x813494,0x8(%esp)
  80ef8a:	00 
  80ef8b:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  80ef92:	00 
  80ef93:	c7 04 24 26 35 81 00 	movl   $0x813526,(%esp)
  80ef9a:	e8 4d 02 00 00       	call   80f1ec <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  80ef9f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80efa3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80efa6:	89 04 24             	mov    %eax,(%esp)
  80efa9:	e8 d7 60 ff ff       	call   805085 <pbuf_copy>
  80efae:	84 c0                	test   %al,%al
  80efb0:	74 1c                	je     80efce <icmp_input+0x19a>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80efb2:	c7 44 24 08 cc 34 81 	movl   $0x8134cc,0x8(%esp)
  80efb9:	00 
  80efba:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
  80efc1:	00 
  80efc2:	c7 04 24 26 35 81 00 	movl   $0x813526,(%esp)
  80efc9:	e8 1e 02 00 00       	call   80f1ec <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  80efce:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80efd1:	8b 72 04             	mov    0x4(%edx),%esi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  80efd4:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80efd8:	89 14 24             	mov    %edx,(%esp)
  80efdb:	e8 e7 5e ff ff       	call   804ec7 <pbuf_header>
  80efe0:	84 c0                	test   %al,%al
  80efe2:	74 1c                	je     80f000 <icmp_input+0x1cc>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80efe4:	c7 44 24 08 f4 34 81 	movl   $0x8134f4,0x8(%esp)
  80efeb:	00 
  80efec:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80eff3:	00 
  80eff4:	c7 04 24 26 35 81 00 	movl   $0x813526,(%esp)
  80effb:	e8 ec 01 00 00       	call   80f1ec <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  80f000:	89 1c 24             	mov    %ebx,(%esp)
  80f003:	e8 1c 62 ff ff       	call   805224 <pbuf_free>
  80f008:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80f00b:	eb 30                	jmp    80f03d <icmp_input+0x209>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80f00d:	c7 44 24 04 de ff ff 	movl   $0xffffffde,0x4(%esp)
  80f014:	ff 
  80f015:	89 1c 24             	mov    %ebx,(%esp)
  80f018:	e8 aa 5e ff ff       	call   804ec7 <pbuf_header>
  80f01d:	84 c0                	test   %al,%al
  80f01f:	74 1c                	je     80f03d <icmp_input+0x209>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80f021:	c7 44 24 08 f4 34 81 	movl   $0x8134f4,0x8(%esp)
  80f028:	00 
  80f029:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80f030:	00 
  80f031:	c7 04 24 26 35 81 00 	movl   $0x813526,(%esp)
  80f038:	e8 af 01 00 00       	call   80f1ec <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  80f03d:	8b 7b 04             	mov    0x4(%ebx),%edi
    tmpaddr.addr = iphdr->src.addr;
  80f040:	8b 46 0c             	mov    0xc(%esi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80f043:	8b 56 10             	mov    0x10(%esi),%edx
  80f046:	89 56 0c             	mov    %edx,0xc(%esi)
    iphdr->dest.addr = tmpaddr.addr;
  80f049:	89 46 10             	mov    %eax,0x10(%esi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80f04c:	0f b7 07             	movzwl (%edi),%eax
  80f04f:	89 04 24             	mov    %eax,(%esp)
  80f052:	e8 15 8e ff ff       	call   807e6c <ntohs>
  80f057:	0f b6 c0             	movzbl %al,%eax
  80f05a:	89 04 24             	mov    %eax,(%esp)
  80f05d:	e8 fd 8d ff ff       	call   807e5f <htons>
  80f062:	66 89 07             	mov    %ax,(%edi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80f065:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80f069:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80f06d:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80f074:	e8 e6 8d ff ff       	call   807e5f <htons>
  80f079:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80f07d:	72 22                	jb     80f0a1 <icmp_input+0x26d>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80f07f:	0f b7 57 02          	movzwl 0x2(%edi),%edx
  80f083:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
  80f087:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80f08e:	e8 cc 8d ff ff       	call   807e5f <htons>
  80f093:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
  80f097:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  80f09b:	66 89 47 02          	mov    %ax,0x2(%edi)
  80f09f:	eb 1c                	jmp    80f0bd <icmp_input+0x289>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  80f0a1:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80f0a5:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80f0a9:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80f0b0:	e8 aa 8d ff ff       	call   807e5f <htons>
  80f0b5:	66 03 45 e0          	add    -0x20(%ebp),%ax
  80f0b9:	66 89 47 02          	mov    %ax,0x2(%edi)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80f0bd:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f0c1:	89 04 24             	mov    %eax,(%esp)
  80f0c4:	e8 a3 8d ff ff       	call   807e6c <ntohs>
  80f0c9:	66 0d 00 ff          	or     $0xff00,%ax
  80f0cd:	0f b7 c0             	movzwl %ax,%eax
  80f0d0:	89 04 24             	mov    %eax,(%esp)
  80f0d3:	e8 87 8d ff ff       	call   807e5f <htons>
  80f0d8:	66 89 46 08          	mov    %ax,0x8(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  80f0dc:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80f0e2:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80f0e9:	00 
  80f0ea:	89 34 24             	mov    %esi,(%esp)
  80f0ed:	e8 70 8a ff ff       	call   807b62 <inet_chksum>
  80f0f2:	66 89 46 0a          	mov    %ax,0xa(%esi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  80f0f6:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80f0fa:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f0fe:	89 1c 24             	mov    %ebx,(%esp)
  80f101:	e8 c1 5d ff ff       	call   804ec7 <pbuf_header>
  80f106:	84 c0                	test   %al,%al
  80f108:	74 1c                	je     80f126 <icmp_input+0x2f2>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80f10a:	c7 44 24 08 24 25 81 	movl   $0x812524,0x8(%esp)
  80f111:	00 
  80f112:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  80f119:	00 
  80f11a:	c7 04 24 26 35 81 00 	movl   $0x813526,(%esp)
  80f121:	e8 c6 00 00 00       	call   80f1ec <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80f126:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f129:	89 54 24 18          	mov    %edx,0x18(%esp)
  80f12d:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80f134:	00 
  80f135:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80f13c:	00 
  80f13d:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80f144:	00 
  80f145:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f14c:	00 
  80f14d:	83 c6 0c             	add    $0xc,%esi
  80f150:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f154:	89 1c 24             	mov    %ebx,(%esp)
  80f157:	e8 34 7a ff ff       	call   806b90 <ip_output_if>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80f15c:	89 1c 24             	mov    %ebx,(%esp)
  80f15f:	e8 c0 60 ff ff       	call   805224 <pbuf_free>
  return;
  80f164:	eb 14                	jmp    80f17a <icmp_input+0x346>
lenerr:
  pbuf_free(p);
  80f166:	89 1c 24             	mov    %ebx,(%esp)
  80f169:	e8 b6 60 ff ff       	call   805224 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80f16e:	66 90                	xchg   %ax,%ax
  80f170:	eb 08                	jmp    80f17a <icmp_input+0x346>
memerr:
  pbuf_free(p);
  80f172:	89 1c 24             	mov    %ebx,(%esp)
  80f175:	e8 aa 60 ff ff       	call   805224 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80f17a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f17d:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f180:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f183:	89 ec                	mov    %ebp,%esp
  80f185:	5d                   	pop    %ebp
  80f186:	c3                   	ret    
	...

0080f188 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80f188:	55                   	push   %ebp
  80f189:	89 e5                	mov    %esp,%ebp
  80f18b:	83 ec 18             	sub    $0x18,%esp
  80f18e:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f191:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f194:	8b 75 08             	mov    0x8(%ebp),%esi
  80f197:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = (struct Env *)UENVS + ENVX(sys_getenvid());
  80f19a:	e8 42 0f 00 00       	call   8100e1 <sys_getenvid>
  80f19f:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f1a4:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f1a7:	2d 00 00 40 11       	sub    $0x11400000,%eax
  80f1ac:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80f1b1:	85 f6                	test   %esi,%esi
  80f1b3:	7e 07                	jle    80f1bc <libmain+0x34>
		binaryname = argv[0];
  80f1b5:	8b 03                	mov    (%ebx),%eax
  80f1b7:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	// call user main routine
	umain(argc, argv);
  80f1bc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f1c0:	89 34 24             	mov    %esi,(%esp)
  80f1c3:	e8 8c 0e ff ff       	call   800054 <umain>

	// exit gracefully
	exit();
  80f1c8:	e8 0b 00 00 00       	call   80f1d8 <exit>
}
  80f1cd:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f1d0:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f1d3:	89 ec                	mov    %ebp,%esp
  80f1d5:	5d                   	pop    %ebp
  80f1d6:	c3                   	ret    
	...

0080f1d8 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80f1d8:	55                   	push   %ebp
  80f1d9:	89 e5                	mov    %esp,%ebp
  80f1db:	83 ec 18             	sub    $0x18,%esp
	//close_all();
	sys_env_destroy(0);
  80f1de:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f1e5:	e8 2b 0f 00 00       	call   810115 <sys_env_destroy>
}
  80f1ea:	c9                   	leave  
  80f1eb:	c3                   	ret    

0080f1ec <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80f1ec:	55                   	push   %ebp
  80f1ed:	89 e5                	mov    %esp,%ebp
  80f1ef:	56                   	push   %esi
  80f1f0:	53                   	push   %ebx
  80f1f1:	83 ec 20             	sub    $0x20,%esp
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
  80f1f4:	8d 75 14             	lea    0x14(%ebp),%esi
	va_list ap;

	va_start(ap, fmt);

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80f1f7:	8b 1d e8 42 81 00    	mov    0x8142e8,%ebx
  80f1fd:	e8 df 0e 00 00       	call   8100e1 <sys_getenvid>
  80f202:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f205:	89 54 24 10          	mov    %edx,0x10(%esp)
  80f209:	8b 55 08             	mov    0x8(%ebp),%edx
  80f20c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f210:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80f214:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f218:	c7 04 24 4c 35 81 00 	movl   $0x81354c,(%esp)
  80f21f:	e8 81 00 00 00       	call   80f2a5 <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80f224:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f228:	8b 45 10             	mov    0x10(%ebp),%eax
  80f22b:	89 04 24             	mov    %eax,(%esp)
  80f22e:	e8 11 00 00 00       	call   80f244 <vcprintf>
	cprintf("\n");
  80f233:	c7 04 24 6a 0f 81 00 	movl   $0x810f6a,(%esp)
  80f23a:	e8 66 00 00 00       	call   80f2a5 <cprintf>

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80f23f:	cc                   	int3   
  80f240:	eb fd                	jmp    80f23f <_panic+0x53>
	...

0080f244 <vcprintf>:
	b->cnt++;
}

int
vcprintf(const char *fmt, va_list ap)
{
  80f244:	55                   	push   %ebp
  80f245:	89 e5                	mov    %esp,%ebp
  80f247:	81 ec 28 01 00 00    	sub    $0x128,%esp
	struct printbuf b;

	b.idx = 0;
  80f24d:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80f254:	00 00 00 
	b.cnt = 0;
  80f257:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80f25e:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80f261:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f264:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f268:	8b 45 08             	mov    0x8(%ebp),%eax
  80f26b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f26f:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80f275:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f279:	c7 04 24 bf f2 80 00 	movl   $0x80f2bf,(%esp)
  80f280:	e8 be 01 00 00       	call   80f443 <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80f285:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
  80f28b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f28f:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80f295:	89 04 24             	mov    %eax,(%esp)
  80f298:	e8 23 0a 00 00       	call   80fcc0 <sys_cputs>

	return b.cnt;
}
  80f29d:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80f2a3:	c9                   	leave  
  80f2a4:	c3                   	ret    

0080f2a5 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80f2a5:	55                   	push   %ebp
  80f2a6:	89 e5                	mov    %esp,%ebp
  80f2a8:	83 ec 18             	sub    $0x18,%esp

	return b.cnt;
}

int
cprintf(const char *fmt, ...)
  80f2ab:	8d 45 0c             	lea    0xc(%ebp),%eax
{
	va_list ap;
	int cnt;

	va_start(ap, fmt);
	cnt = vcprintf(fmt, ap);
  80f2ae:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f2b2:	8b 45 08             	mov    0x8(%ebp),%eax
  80f2b5:	89 04 24             	mov    %eax,(%esp)
  80f2b8:	e8 87 ff ff ff       	call   80f244 <vcprintf>
	va_end(ap);

	return cnt;
}
  80f2bd:	c9                   	leave  
  80f2be:	c3                   	ret    

0080f2bf <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80f2bf:	55                   	push   %ebp
  80f2c0:	89 e5                	mov    %esp,%ebp
  80f2c2:	53                   	push   %ebx
  80f2c3:	83 ec 14             	sub    $0x14,%esp
  80f2c6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80f2c9:	8b 03                	mov    (%ebx),%eax
  80f2cb:	8b 55 08             	mov    0x8(%ebp),%edx
  80f2ce:	88 54 03 08          	mov    %dl,0x8(%ebx,%eax,1)
  80f2d2:	83 c0 01             	add    $0x1,%eax
  80f2d5:	89 03                	mov    %eax,(%ebx)
	if (b->idx == 256-1) {
  80f2d7:	3d ff 00 00 00       	cmp    $0xff,%eax
  80f2dc:	75 19                	jne    80f2f7 <putch+0x38>
		sys_cputs(b->buf, b->idx);
  80f2de:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80f2e5:	00 
  80f2e6:	8d 43 08             	lea    0x8(%ebx),%eax
  80f2e9:	89 04 24             	mov    %eax,(%esp)
  80f2ec:	e8 cf 09 00 00       	call   80fcc0 <sys_cputs>
		b->idx = 0;
  80f2f1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	}
	b->cnt++;
  80f2f7:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80f2fb:	83 c4 14             	add    $0x14,%esp
  80f2fe:	5b                   	pop    %ebx
  80f2ff:	5d                   	pop    %ebp
  80f300:	c3                   	ret    
  80f301:	00 00                	add    %al,(%eax)
	...

0080f304 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80f304:	55                   	push   %ebp
  80f305:	89 e5                	mov    %esp,%ebp
  80f307:	57                   	push   %edi
  80f308:	56                   	push   %esi
  80f309:	53                   	push   %ebx
  80f30a:	83 ec 4c             	sub    $0x4c,%esp
  80f30d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f310:	89 d6                	mov    %edx,%esi
  80f312:	8b 45 08             	mov    0x8(%ebp),%eax
  80f315:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80f318:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f31b:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80f31e:	8b 45 10             	mov    0x10(%ebp),%eax
  80f321:	8b 5d 14             	mov    0x14(%ebp),%ebx
  80f324:	8b 7d 18             	mov    0x18(%ebp),%edi
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80f327:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80f32a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f32f:	39 d1                	cmp    %edx,%ecx
  80f331:	72 07                	jb     80f33a <printnum+0x36>
  80f333:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80f336:	39 d0                	cmp    %edx,%eax
  80f338:	77 69                	ja     80f3a3 <printnum+0x9f>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80f33a:	89 7c 24 10          	mov    %edi,0x10(%esp)
  80f33e:	83 eb 01             	sub    $0x1,%ebx
  80f341:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80f345:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f349:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  80f34d:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  80f351:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  80f354:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  80f357:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  80f35a:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80f35e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80f365:	00 
  80f366:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80f369:	89 04 24             	mov    %eax,(%esp)
  80f36c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80f36f:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f373:	e8 e8 18 00 00       	call   810c60 <__udivdi3>
  80f378:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80f37b:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  80f37e:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f382:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80f386:	89 04 24             	mov    %eax,(%esp)
  80f389:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f38d:	89 f2                	mov    %esi,%edx
  80f38f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f392:	e8 6d ff ff ff       	call   80f304 <printnum>
  80f397:	eb 11                	jmp    80f3aa <printnum+0xa6>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80f399:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f39d:	89 3c 24             	mov    %edi,(%esp)
  80f3a0:	ff 55 e4             	call   *-0x1c(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80f3a3:	83 eb 01             	sub    $0x1,%ebx
  80f3a6:	85 db                	test   %ebx,%ebx
  80f3a8:	7f ef                	jg     80f399 <printnum+0x95>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80f3aa:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f3ae:	8b 74 24 04          	mov    0x4(%esp),%esi
  80f3b2:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80f3b5:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f3b9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80f3c0:	00 
  80f3c1:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80f3c4:	89 14 24             	mov    %edx,(%esp)
  80f3c7:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80f3ca:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80f3ce:	e8 bd 19 00 00       	call   810d90 <__umoddi3>
  80f3d3:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f3d7:	0f be 80 6f 35 81 00 	movsbl 0x81356f(%eax),%eax
  80f3de:	89 04 24             	mov    %eax,(%esp)
  80f3e1:	ff 55 e4             	call   *-0x1c(%ebp)
}
  80f3e4:	83 c4 4c             	add    $0x4c,%esp
  80f3e7:	5b                   	pop    %ebx
  80f3e8:	5e                   	pop    %esi
  80f3e9:	5f                   	pop    %edi
  80f3ea:	5d                   	pop    %ebp
  80f3eb:	c3                   	ret    

0080f3ec <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  80f3ec:	55                   	push   %ebp
  80f3ed:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  80f3ef:	83 fa 01             	cmp    $0x1,%edx
  80f3f2:	7e 0e                	jle    80f402 <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  80f3f4:	8b 10                	mov    (%eax),%edx
  80f3f6:	8d 4a 08             	lea    0x8(%edx),%ecx
  80f3f9:	89 08                	mov    %ecx,(%eax)
  80f3fb:	8b 02                	mov    (%edx),%eax
  80f3fd:	8b 52 04             	mov    0x4(%edx),%edx
  80f400:	eb 22                	jmp    80f424 <getuint+0x38>
	else if (lflag)
  80f402:	85 d2                	test   %edx,%edx
  80f404:	74 10                	je     80f416 <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  80f406:	8b 10                	mov    (%eax),%edx
  80f408:	8d 4a 04             	lea    0x4(%edx),%ecx
  80f40b:	89 08                	mov    %ecx,(%eax)
  80f40d:	8b 02                	mov    (%edx),%eax
  80f40f:	ba 00 00 00 00       	mov    $0x0,%edx
  80f414:	eb 0e                	jmp    80f424 <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  80f416:	8b 10                	mov    (%eax),%edx
  80f418:	8d 4a 04             	lea    0x4(%edx),%ecx
  80f41b:	89 08                	mov    %ecx,(%eax)
  80f41d:	8b 02                	mov    (%edx),%eax
  80f41f:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80f424:	5d                   	pop    %ebp
  80f425:	c3                   	ret    

0080f426 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80f426:	55                   	push   %ebp
  80f427:	89 e5                	mov    %esp,%ebp
  80f429:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80f42c:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80f430:	8b 10                	mov    (%eax),%edx
  80f432:	3b 50 04             	cmp    0x4(%eax),%edx
  80f435:	73 0a                	jae    80f441 <sprintputch+0x1b>
		*b->buf++ = ch;
  80f437:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f43a:	88 0a                	mov    %cl,(%edx)
  80f43c:	83 c2 01             	add    $0x1,%edx
  80f43f:	89 10                	mov    %edx,(%eax)
}
  80f441:	5d                   	pop    %ebp
  80f442:	c3                   	ret    

0080f443 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80f443:	55                   	push   %ebp
  80f444:	89 e5                	mov    %esp,%ebp
  80f446:	57                   	push   %edi
  80f447:	56                   	push   %esi
  80f448:	53                   	push   %ebx
  80f449:	83 ec 4c             	sub    $0x4c,%esp
  80f44c:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f44f:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f452:	8b 5d 10             	mov    0x10(%ebp),%ebx
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  80f455:	c7 45 c8 ff ff ff ff 	movl   $0xffffffff,-0x38(%ebp)
  80f45c:	eb 11                	jmp    80f46f <vprintfmt+0x2c>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  80f45e:	85 c0                	test   %eax,%eax
  80f460:	0f 84 b6 03 00 00    	je     80f81c <vprintfmt+0x3d9>
				return;
			putch(ch, putdat);
  80f466:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f46a:	89 04 24             	mov    %eax,(%esp)
  80f46d:	ff d7                	call   *%edi
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80f46f:	0f b6 03             	movzbl (%ebx),%eax
  80f472:	83 c3 01             	add    $0x1,%ebx
  80f475:	83 f8 25             	cmp    $0x25,%eax
  80f478:	75 e4                	jne    80f45e <vprintfmt+0x1b>
  80f47a:	c6 45 e0 20          	movb   $0x20,-0x20(%ebp)
  80f47e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80f485:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,-0x34(%ebp)
  80f48c:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
  80f493:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f498:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80f49b:	eb 06                	jmp    80f4a3 <vprintfmt+0x60>
  80f49d:	c6 45 e0 2d          	movb   $0x2d,-0x20(%ebp)
  80f4a1:	89 d3                	mov    %edx,%ebx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f4a3:	0f b6 0b             	movzbl (%ebx),%ecx
  80f4a6:	0f b6 c1             	movzbl %cl,%eax
  80f4a9:	8d 53 01             	lea    0x1(%ebx),%edx
  80f4ac:	83 e9 23             	sub    $0x23,%ecx
  80f4af:	80 f9 55             	cmp    $0x55,%cl
  80f4b2:	0f 87 47 03 00 00    	ja     80f7ff <vprintfmt+0x3bc>
  80f4b8:	0f b6 c9             	movzbl %cl,%ecx
  80f4bb:	ff 24 8d c0 36 81 00 	jmp    *0x8136c0(,%ecx,4)
  80f4c2:	c6 45 e0 30          	movb   $0x30,-0x20(%ebp)
  80f4c6:	eb d9                	jmp    80f4a1 <vprintfmt+0x5e>
  80f4c8:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  80f4cf:	b9 00 00 00 00       	mov    $0x0,%ecx
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  80f4d4:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  80f4d7:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
				ch = *fmt;
  80f4db:	0f be 02             	movsbl (%edx),%eax
				if (ch < '0' || ch > '9')
  80f4de:	8d 58 d0             	lea    -0x30(%eax),%ebx
  80f4e1:	83 fb 09             	cmp    $0x9,%ebx
  80f4e4:	77 30                	ja     80f516 <vprintfmt+0xd3>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80f4e6:	83 c2 01             	add    $0x1,%edx
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80f4e9:	eb e9                	jmp    80f4d4 <vprintfmt+0x91>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  80f4eb:	8b 45 14             	mov    0x14(%ebp),%eax
  80f4ee:	8d 48 04             	lea    0x4(%eax),%ecx
  80f4f1:	89 4d 14             	mov    %ecx,0x14(%ebp)
  80f4f4:	8b 00                	mov    (%eax),%eax
  80f4f6:	89 45 cc             	mov    %eax,-0x34(%ebp)
			goto process_precision;
  80f4f9:	eb 1e                	jmp    80f519 <vprintfmt+0xd6>

		case '.':
			if (width < 0)
  80f4fb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80f4ff:	b8 00 00 00 00       	mov    $0x0,%eax
  80f504:	0f 49 45 e4          	cmovns -0x1c(%ebp),%eax
  80f508:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f50b:	eb 94                	jmp    80f4a1 <vprintfmt+0x5e>
  80f50d:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
			goto reswitch;
  80f514:	eb 8b                	jmp    80f4a1 <vprintfmt+0x5e>
  80f516:	89 4d cc             	mov    %ecx,-0x34(%ebp)

		process_precision:
			if (width < 0)
  80f519:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80f51d:	79 82                	jns    80f4a1 <vprintfmt+0x5e>
  80f51f:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80f522:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f525:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80f528:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  80f52b:	e9 71 ff ff ff       	jmp    80f4a1 <vprintfmt+0x5e>
				width = precision, precision = -1;
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  80f530:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
			goto reswitch;
  80f534:	e9 68 ff ff ff       	jmp    80f4a1 <vprintfmt+0x5e>
  80f539:	89 55 d0             	mov    %edx,-0x30(%ebp)

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  80f53c:	8b 45 14             	mov    0x14(%ebp),%eax
  80f53f:	8d 50 04             	lea    0x4(%eax),%edx
  80f542:	89 55 14             	mov    %edx,0x14(%ebp)
  80f545:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f549:	8b 00                	mov    (%eax),%eax
  80f54b:	89 04 24             	mov    %eax,(%esp)
  80f54e:	ff d7                	call   *%edi
  80f550:	8b 5d d0             	mov    -0x30(%ebp),%ebx
			break;
  80f553:	e9 17 ff ff ff       	jmp    80f46f <vprintfmt+0x2c>
  80f558:	89 55 d0             	mov    %edx,-0x30(%ebp)

		// error message
		case 'e':
			err = va_arg(ap, int);
  80f55b:	8b 45 14             	mov    0x14(%ebp),%eax
  80f55e:	8d 50 04             	lea    0x4(%eax),%edx
  80f561:	89 55 14             	mov    %edx,0x14(%ebp)
  80f564:	8b 00                	mov    (%eax),%eax
  80f566:	89 c2                	mov    %eax,%edx
  80f568:	c1 fa 1f             	sar    $0x1f,%edx
  80f56b:	31 d0                	xor    %edx,%eax
  80f56d:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80f56f:	83 f8 11             	cmp    $0x11,%eax
  80f572:	7f 0b                	jg     80f57f <vprintfmt+0x13c>
  80f574:	8b 14 85 20 38 81 00 	mov    0x813820(,%eax,4),%edx
  80f57b:	85 d2                	test   %edx,%edx
  80f57d:	75 20                	jne    80f59f <vprintfmt+0x15c>
				printfmt(putch, putdat, "error %d", err);
  80f57f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f583:	c7 44 24 08 80 35 81 	movl   $0x813580,0x8(%esp)
  80f58a:	00 
  80f58b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f58f:	89 3c 24             	mov    %edi,(%esp)
  80f592:	e8 0d 03 00 00       	call   80f8a4 <printfmt>
  80f597:	8b 5d d0             	mov    -0x30(%ebp),%ebx
		// error message
		case 'e':
			err = va_arg(ap, int);
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80f59a:	e9 d0 fe ff ff       	jmp    80f46f <vprintfmt+0x2c>
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  80f59f:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f5a3:	c7 44 24 08 ea 25 81 	movl   $0x8125ea,0x8(%esp)
  80f5aa:	00 
  80f5ab:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f5af:	89 3c 24             	mov    %edi,(%esp)
  80f5b2:	e8 ed 02 00 00       	call   80f8a4 <printfmt>
  80f5b7:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  80f5ba:	e9 b0 fe ff ff       	jmp    80f46f <vprintfmt+0x2c>
  80f5bf:	89 55 d0             	mov    %edx,-0x30(%ebp)
  80f5c2:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  80f5c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f5c8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  80f5cb:	8b 45 14             	mov    0x14(%ebp),%eax
  80f5ce:	8d 50 04             	lea    0x4(%eax),%edx
  80f5d1:	89 55 14             	mov    %edx,0x14(%ebp)
  80f5d4:	8b 18                	mov    (%eax),%ebx
  80f5d6:	85 db                	test   %ebx,%ebx
  80f5d8:	b8 89 35 81 00       	mov    $0x813589,%eax
  80f5dd:	0f 44 d8             	cmove  %eax,%ebx
				p = "(null)";
			if (width > 0 && padc != '-')
  80f5e0:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80f5e4:	7e 76                	jle    80f65c <vprintfmt+0x219>
  80f5e6:	80 7d e0 2d          	cmpb   $0x2d,-0x20(%ebp)
  80f5ea:	74 7a                	je     80f666 <vprintfmt+0x223>
				for (width -= strnlen(p, precision); width > 0; width--)
  80f5ec:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80f5f0:	89 1c 24             	mov    %ebx,(%esp)
  80f5f3:	e8 f0 02 00 00       	call   80f8e8 <strnlen>
  80f5f8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80f5fb:	29 c2                	sub    %eax,%edx
					putch(padc, putdat);
  80f5fd:	0f be 4d e0          	movsbl -0x20(%ebp),%ecx
  80f601:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80f604:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  80f607:	89 d3                	mov    %edx,%ebx
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80f609:	eb 0f                	jmp    80f61a <vprintfmt+0x1d7>
					putch(padc, putdat);
  80f60b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f60f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f612:	89 04 24             	mov    %eax,(%esp)
  80f615:	ff d7                	call   *%edi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80f617:	83 eb 01             	sub    $0x1,%ebx
  80f61a:	85 db                	test   %ebx,%ebx
  80f61c:	7f ed                	jg     80f60b <vprintfmt+0x1c8>
  80f61e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80f621:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  80f624:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80f627:	89 f7                	mov    %esi,%edi
  80f629:	8b 75 cc             	mov    -0x34(%ebp),%esi
  80f62c:	eb 40                	jmp    80f66e <vprintfmt+0x22b>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  80f62e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80f632:	74 18                	je     80f64c <vprintfmt+0x209>
  80f634:	8d 50 e0             	lea    -0x20(%eax),%edx
  80f637:	83 fa 5e             	cmp    $0x5e,%edx
  80f63a:	76 10                	jbe    80f64c <vprintfmt+0x209>
					putch('?', putdat);
  80f63c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f640:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  80f647:	ff 55 e0             	call   *-0x20(%ebp)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  80f64a:	eb 0a                	jmp    80f656 <vprintfmt+0x213>
					putch('?', putdat);
				else
					putch(ch, putdat);
  80f64c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f650:	89 04 24             	mov    %eax,(%esp)
  80f653:	ff 55 e0             	call   *-0x20(%ebp)
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80f656:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
  80f65a:	eb 12                	jmp    80f66e <vprintfmt+0x22b>
  80f65c:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80f65f:	89 f7                	mov    %esi,%edi
  80f661:	8b 75 cc             	mov    -0x34(%ebp),%esi
  80f664:	eb 08                	jmp    80f66e <vprintfmt+0x22b>
  80f666:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80f669:	89 f7                	mov    %esi,%edi
  80f66b:	8b 75 cc             	mov    -0x34(%ebp),%esi
  80f66e:	0f be 03             	movsbl (%ebx),%eax
  80f671:	83 c3 01             	add    $0x1,%ebx
  80f674:	85 c0                	test   %eax,%eax
  80f676:	74 25                	je     80f69d <vprintfmt+0x25a>
  80f678:	85 f6                	test   %esi,%esi
  80f67a:	78 b2                	js     80f62e <vprintfmt+0x1eb>
  80f67c:	83 ee 01             	sub    $0x1,%esi
  80f67f:	79 ad                	jns    80f62e <vprintfmt+0x1eb>
  80f681:	89 fe                	mov    %edi,%esi
  80f683:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80f686:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80f689:	eb 1a                	jmp    80f6a5 <vprintfmt+0x262>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  80f68b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f68f:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80f696:	ff d7                	call   *%edi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80f698:	83 eb 01             	sub    $0x1,%ebx
  80f69b:	eb 08                	jmp    80f6a5 <vprintfmt+0x262>
  80f69d:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80f6a0:	89 fe                	mov    %edi,%esi
  80f6a2:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80f6a5:	85 db                	test   %ebx,%ebx
  80f6a7:	7f e2                	jg     80f68b <vprintfmt+0x248>
  80f6a9:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  80f6ac:	e9 be fd ff ff       	jmp    80f46f <vprintfmt+0x2c>
  80f6b1:	89 55 d0             	mov    %edx,-0x30(%ebp)
  80f6b4:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80f6b7:	83 f9 01             	cmp    $0x1,%ecx
  80f6ba:	7e 16                	jle    80f6d2 <vprintfmt+0x28f>
		return va_arg(*ap, long long);
  80f6bc:	8b 45 14             	mov    0x14(%ebp),%eax
  80f6bf:	8d 50 08             	lea    0x8(%eax),%edx
  80f6c2:	89 55 14             	mov    %edx,0x14(%ebp)
  80f6c5:	8b 10                	mov    (%eax),%edx
  80f6c7:	8b 48 04             	mov    0x4(%eax),%ecx
  80f6ca:	89 55 d8             	mov    %edx,-0x28(%ebp)
  80f6cd:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80f6d0:	eb 32                	jmp    80f704 <vprintfmt+0x2c1>
	else if (lflag)
  80f6d2:	85 c9                	test   %ecx,%ecx
  80f6d4:	74 18                	je     80f6ee <vprintfmt+0x2ab>
		return va_arg(*ap, long);
  80f6d6:	8b 45 14             	mov    0x14(%ebp),%eax
  80f6d9:	8d 50 04             	lea    0x4(%eax),%edx
  80f6dc:	89 55 14             	mov    %edx,0x14(%ebp)
  80f6df:	8b 00                	mov    (%eax),%eax
  80f6e1:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80f6e4:	89 c1                	mov    %eax,%ecx
  80f6e6:	c1 f9 1f             	sar    $0x1f,%ecx
  80f6e9:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80f6ec:	eb 16                	jmp    80f704 <vprintfmt+0x2c1>
	else
		return va_arg(*ap, int);
  80f6ee:	8b 45 14             	mov    0x14(%ebp),%eax
  80f6f1:	8d 50 04             	lea    0x4(%eax),%edx
  80f6f4:	89 55 14             	mov    %edx,0x14(%ebp)
  80f6f7:	8b 00                	mov    (%eax),%eax
  80f6f9:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80f6fc:	89 c2                	mov    %eax,%edx
  80f6fe:	c1 fa 1f             	sar    $0x1f,%edx
  80f701:	89 55 dc             	mov    %edx,-0x24(%ebp)
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  80f704:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80f707:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  80f70a:	b8 0a 00 00 00       	mov    $0xa,%eax
			if ((long long) num < 0) {
  80f70f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80f713:	0f 89 a7 00 00 00    	jns    80f7c0 <vprintfmt+0x37d>
				putch('-', putdat);
  80f719:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f71d:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  80f724:	ff d7                	call   *%edi
				num = -(long long) num;
  80f726:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80f729:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  80f72c:	f7 d9                	neg    %ecx
  80f72e:	83 d3 00             	adc    $0x0,%ebx
  80f731:	f7 db                	neg    %ebx
  80f733:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f738:	e9 83 00 00 00       	jmp    80f7c0 <vprintfmt+0x37d>
  80f73d:	89 55 d0             	mov    %edx,-0x30(%ebp)
  80f740:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
			base = 10;
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  80f743:	89 ca                	mov    %ecx,%edx
  80f745:	8d 45 14             	lea    0x14(%ebp),%eax
  80f748:	e8 9f fc ff ff       	call   80f3ec <getuint>
  80f74d:	89 c1                	mov    %eax,%ecx
  80f74f:	89 d3                	mov    %edx,%ebx
  80f751:	b8 0a 00 00 00       	mov    $0xa,%eax
			base = 10;
			goto number;
  80f756:	eb 68                	jmp    80f7c0 <vprintfmt+0x37d>
  80f758:	89 55 d0             	mov    %edx,-0x30(%ebp)
  80f75b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getuint(&ap, lflag);
  80f75e:	89 ca                	mov    %ecx,%edx
  80f760:	8d 45 14             	lea    0x14(%ebp),%eax
  80f763:	e8 84 fc ff ff       	call   80f3ec <getuint>
  80f768:	89 c1                	mov    %eax,%ecx
  80f76a:	89 d3                	mov    %edx,%ebx
  80f76c:	b8 08 00 00 00       	mov    $0x8,%eax
			base = 8;
			goto number;
  80f771:	eb 4d                	jmp    80f7c0 <vprintfmt+0x37d>
  80f773:	89 55 d0             	mov    %edx,-0x30(%ebp)

		// pointer
		case 'p':
			putch('0', putdat);
  80f776:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f77a:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  80f781:	ff d7                	call   *%edi
			putch('x', putdat);
  80f783:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f787:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  80f78e:	ff d7                	call   *%edi
			num = (unsigned long long)
  80f790:	8b 45 14             	mov    0x14(%ebp),%eax
  80f793:	8d 50 04             	lea    0x4(%eax),%edx
  80f796:	89 55 14             	mov    %edx,0x14(%ebp)
  80f799:	8b 08                	mov    (%eax),%ecx
  80f79b:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f7a0:	b8 10 00 00 00       	mov    $0x10,%eax
				(uintptr_t) va_arg(ap, void *);
			base = 16;
			goto number;
  80f7a5:	eb 19                	jmp    80f7c0 <vprintfmt+0x37d>
  80f7a7:	89 55 d0             	mov    %edx,-0x30(%ebp)
  80f7aa:	8b 4d d4             	mov    -0x2c(%ebp),%ecx

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  80f7ad:	89 ca                	mov    %ecx,%edx
  80f7af:	8d 45 14             	lea    0x14(%ebp),%eax
  80f7b2:	e8 35 fc ff ff       	call   80f3ec <getuint>
  80f7b7:	89 c1                	mov    %eax,%ecx
  80f7b9:	89 d3                	mov    %edx,%ebx
  80f7bb:	b8 10 00 00 00       	mov    $0x10,%eax
			base = 16;
		number:
			printnum(putch, putdat, num, base, width, padc);
  80f7c0:	0f be 55 e0          	movsbl -0x20(%ebp),%edx
  80f7c4:	89 54 24 10          	mov    %edx,0x10(%esp)
  80f7c8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80f7cb:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f7cf:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f7d3:	89 0c 24             	mov    %ecx,(%esp)
  80f7d6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f7da:	89 f2                	mov    %esi,%edx
  80f7dc:	89 f8                	mov    %edi,%eax
  80f7de:	e8 21 fb ff ff       	call   80f304 <printnum>
  80f7e3:	8b 5d d0             	mov    -0x30(%ebp),%ebx
			break;
  80f7e6:	e9 84 fc ff ff       	jmp    80f46f <vprintfmt+0x2c>
  80f7eb:	89 55 d0             	mov    %edx,-0x30(%ebp)

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  80f7ee:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f7f2:	89 04 24             	mov    %eax,(%esp)
  80f7f5:	ff d7                	call   *%edi
  80f7f7:	8b 5d d0             	mov    -0x30(%ebp),%ebx
			break;
  80f7fa:	e9 70 fc ff ff       	jmp    80f46f <vprintfmt+0x2c>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  80f7ff:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f803:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  80f80a:	ff d7                	call   *%edi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80f80c:	8d 43 ff             	lea    -0x1(%ebx),%eax
  80f80f:	80 38 25             	cmpb   $0x25,(%eax)
  80f812:	0f 84 57 fc ff ff    	je     80f46f <vprintfmt+0x2c>
  80f818:	89 c3                	mov    %eax,%ebx
  80f81a:	eb f0                	jmp    80f80c <vprintfmt+0x3c9>
				/* do nothing */;
			break;
		}
	}
}
  80f81c:	83 c4 4c             	add    $0x4c,%esp
  80f81f:	5b                   	pop    %ebx
  80f820:	5e                   	pop    %esi
  80f821:	5f                   	pop    %edi
  80f822:	5d                   	pop    %ebp
  80f823:	c3                   	ret    

0080f824 <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80f824:	55                   	push   %ebp
  80f825:	89 e5                	mov    %esp,%ebp
  80f827:	83 ec 28             	sub    $0x28,%esp
  80f82a:	8b 45 08             	mov    0x8(%ebp),%eax
  80f82d:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
  80f830:	85 c0                	test   %eax,%eax
  80f832:	74 04                	je     80f838 <vsnprintf+0x14>
  80f834:	85 d2                	test   %edx,%edx
  80f836:	7f 07                	jg     80f83f <vsnprintf+0x1b>
  80f838:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f83d:	eb 3b                	jmp    80f87a <vsnprintf+0x56>
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};
  80f83f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80f842:	8d 44 10 ff          	lea    -0x1(%eax,%edx,1),%eax
  80f846:	89 45 f0             	mov    %eax,-0x10(%ebp)
  80f849:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80f850:	8b 45 14             	mov    0x14(%ebp),%eax
  80f853:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f857:	8b 45 10             	mov    0x10(%ebp),%eax
  80f85a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f85e:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80f861:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f865:	c7 04 24 26 f4 80 00 	movl   $0x80f426,(%esp)
  80f86c:	e8 d2 fb ff ff       	call   80f443 <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80f871:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80f874:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80f877:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  80f87a:	c9                   	leave  
  80f87b:	c3                   	ret    

0080f87c <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80f87c:	55                   	push   %ebp
  80f87d:	89 e5                	mov    %esp,%ebp
  80f87f:	83 ec 18             	sub    $0x18,%esp

	return b.cnt;
}

int
snprintf(char *buf, int n, const char *fmt, ...)
  80f882:	8d 45 14             	lea    0x14(%ebp),%eax
{
	va_list ap;
	int rc;

	va_start(ap, fmt);
	rc = vsnprintf(buf, n, fmt, ap);
  80f885:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f889:	8b 45 10             	mov    0x10(%ebp),%eax
  80f88c:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f890:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f893:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f897:	8b 45 08             	mov    0x8(%ebp),%eax
  80f89a:	89 04 24             	mov    %eax,(%esp)
  80f89d:	e8 82 ff ff ff       	call   80f824 <vsnprintf>
	va_end(ap);

	return rc;
}
  80f8a2:	c9                   	leave  
  80f8a3:	c3                   	ret    

0080f8a4 <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  80f8a4:	55                   	push   %ebp
  80f8a5:	89 e5                	mov    %esp,%ebp
  80f8a7:	83 ec 18             	sub    $0x18,%esp
		}
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
  80f8aa:	8d 45 14             	lea    0x14(%ebp),%eax
{
	va_list ap;

	va_start(ap, fmt);
	vprintfmt(putch, putdat, fmt, ap);
  80f8ad:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f8b1:	8b 45 10             	mov    0x10(%ebp),%eax
  80f8b4:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f8b8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f8bb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f8bf:	8b 45 08             	mov    0x8(%ebp),%eax
  80f8c2:	89 04 24             	mov    %eax,(%esp)
  80f8c5:	e8 79 fb ff ff       	call   80f443 <vprintfmt>
	va_end(ap);
}
  80f8ca:	c9                   	leave  
  80f8cb:	c3                   	ret    
  80f8cc:	00 00                	add    %al,(%eax)
	...

0080f8d0 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80f8d0:	55                   	push   %ebp
  80f8d1:	89 e5                	mov    %esp,%ebp
  80f8d3:	8b 55 08             	mov    0x8(%ebp),%edx
  80f8d6:	b8 00 00 00 00       	mov    $0x0,%eax
	int n;

	for (n = 0; *s != '\0'; s++)
  80f8db:	eb 03                	jmp    80f8e0 <strlen+0x10>
		n++;
  80f8dd:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  80f8e0:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80f8e4:	75 f7                	jne    80f8dd <strlen+0xd>
		n++;
	return n;
}
  80f8e6:	5d                   	pop    %ebp
  80f8e7:	c3                   	ret    

0080f8e8 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80f8e8:	55                   	push   %ebp
  80f8e9:	89 e5                	mov    %esp,%ebp
  80f8eb:	53                   	push   %ebx
  80f8ec:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80f8ef:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f8f2:	b8 00 00 00 00       	mov    $0x0,%eax
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f8f7:	eb 03                	jmp    80f8fc <strnlen+0x14>
		n++;
  80f8f9:	83 c0 01             	add    $0x1,%eax
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f8fc:	39 c1                	cmp    %eax,%ecx
  80f8fe:	74 06                	je     80f906 <strnlen+0x1e>
  80f900:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
  80f904:	75 f3                	jne    80f8f9 <strnlen+0x11>
		n++;
	return n;
}
  80f906:	5b                   	pop    %ebx
  80f907:	5d                   	pop    %ebp
  80f908:	c3                   	ret    

0080f909 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80f909:	55                   	push   %ebp
  80f90a:	89 e5                	mov    %esp,%ebp
  80f90c:	53                   	push   %ebx
  80f90d:	8b 45 08             	mov    0x8(%ebp),%eax
  80f910:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80f913:	ba 00 00 00 00       	mov    $0x0,%edx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80f918:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  80f91c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  80f91f:	83 c2 01             	add    $0x1,%edx
  80f922:	84 c9                	test   %cl,%cl
  80f924:	75 f2                	jne    80f918 <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  80f926:	5b                   	pop    %ebx
  80f927:	5d                   	pop    %ebp
  80f928:	c3                   	ret    

0080f929 <strcat>:

char *
strcat(char *dst, const char *src)
{
  80f929:	55                   	push   %ebp
  80f92a:	89 e5                	mov    %esp,%ebp
  80f92c:	53                   	push   %ebx
  80f92d:	83 ec 08             	sub    $0x8,%esp
  80f930:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80f933:	89 1c 24             	mov    %ebx,(%esp)
  80f936:	e8 95 ff ff ff       	call   80f8d0 <strlen>
	strcpy(dst + len, src);
  80f93b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f93e:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f942:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  80f945:	89 04 24             	mov    %eax,(%esp)
  80f948:	e8 bc ff ff ff       	call   80f909 <strcpy>
	return dst;
}
  80f94d:	89 d8                	mov    %ebx,%eax
  80f94f:	83 c4 08             	add    $0x8,%esp
  80f952:	5b                   	pop    %ebx
  80f953:	5d                   	pop    %ebp
  80f954:	c3                   	ret    

0080f955 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80f955:	55                   	push   %ebp
  80f956:	89 e5                	mov    %esp,%ebp
  80f958:	56                   	push   %esi
  80f959:	53                   	push   %ebx
  80f95a:	8b 45 08             	mov    0x8(%ebp),%eax
  80f95d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f960:	8b 75 10             	mov    0x10(%ebp),%esi
  80f963:	ba 00 00 00 00       	mov    $0x0,%edx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f968:	eb 0f                	jmp    80f979 <strncpy+0x24>
		*dst++ = *src;
  80f96a:	0f b6 19             	movzbl (%ecx),%ebx
  80f96d:	88 1c 10             	mov    %bl,(%eax,%edx,1)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80f970:	80 39 01             	cmpb   $0x1,(%ecx)
  80f973:	83 d9 ff             	sbb    $0xffffffff,%ecx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f976:	83 c2 01             	add    $0x1,%edx
  80f979:	39 f2                	cmp    %esi,%edx
  80f97b:	72 ed                	jb     80f96a <strncpy+0x15>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  80f97d:	5b                   	pop    %ebx
  80f97e:	5e                   	pop    %esi
  80f97f:	5d                   	pop    %ebp
  80f980:	c3                   	ret    

0080f981 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80f981:	55                   	push   %ebp
  80f982:	89 e5                	mov    %esp,%ebp
  80f984:	56                   	push   %esi
  80f985:	53                   	push   %ebx
  80f986:	8b 75 08             	mov    0x8(%ebp),%esi
  80f989:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f98c:	8b 55 10             	mov    0x10(%ebp),%edx
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80f98f:	89 f0                	mov    %esi,%eax
  80f991:	85 d2                	test   %edx,%edx
  80f993:	75 0a                	jne    80f99f <strlcpy+0x1e>
  80f995:	eb 17                	jmp    80f9ae <strlcpy+0x2d>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  80f997:	88 18                	mov    %bl,(%eax)
  80f999:	83 c0 01             	add    $0x1,%eax
  80f99c:	83 c1 01             	add    $0x1,%ecx
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  80f99f:	83 ea 01             	sub    $0x1,%edx
  80f9a2:	74 07                	je     80f9ab <strlcpy+0x2a>
  80f9a4:	0f b6 19             	movzbl (%ecx),%ebx
  80f9a7:	84 db                	test   %bl,%bl
  80f9a9:	75 ec                	jne    80f997 <strlcpy+0x16>
			*dst++ = *src++;
		*dst = '\0';
  80f9ab:	c6 00 00             	movb   $0x0,(%eax)
  80f9ae:	29 f0                	sub    %esi,%eax
	}
	return dst - dst_in;
}
  80f9b0:	5b                   	pop    %ebx
  80f9b1:	5e                   	pop    %esi
  80f9b2:	5d                   	pop    %ebp
  80f9b3:	c3                   	ret    

0080f9b4 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80f9b4:	55                   	push   %ebp
  80f9b5:	89 e5                	mov    %esp,%ebp
  80f9b7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f9ba:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80f9bd:	eb 06                	jmp    80f9c5 <strcmp+0x11>
		p++, q++;
  80f9bf:	83 c1 01             	add    $0x1,%ecx
  80f9c2:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80f9c5:	0f b6 01             	movzbl (%ecx),%eax
  80f9c8:	84 c0                	test   %al,%al
  80f9ca:	74 04                	je     80f9d0 <strcmp+0x1c>
  80f9cc:	3a 02                	cmp    (%edx),%al
  80f9ce:	74 ef                	je     80f9bf <strcmp+0xb>
  80f9d0:	0f b6 c0             	movzbl %al,%eax
  80f9d3:	0f b6 12             	movzbl (%edx),%edx
  80f9d6:	29 d0                	sub    %edx,%eax
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
}
  80f9d8:	5d                   	pop    %ebp
  80f9d9:	c3                   	ret    

0080f9da <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80f9da:	55                   	push   %ebp
  80f9db:	89 e5                	mov    %esp,%ebp
  80f9dd:	53                   	push   %ebx
  80f9de:	8b 45 08             	mov    0x8(%ebp),%eax
  80f9e1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f9e4:	8b 55 10             	mov    0x10(%ebp),%edx
	while (n > 0 && *p && *p == *q)
  80f9e7:	eb 09                	jmp    80f9f2 <strncmp+0x18>
		n--, p++, q++;
  80f9e9:	83 ea 01             	sub    $0x1,%edx
  80f9ec:	83 c0 01             	add    $0x1,%eax
  80f9ef:	83 c1 01             	add    $0x1,%ecx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80f9f2:	85 d2                	test   %edx,%edx
  80f9f4:	75 07                	jne    80f9fd <strncmp+0x23>
  80f9f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80f9fb:	eb 13                	jmp    80fa10 <strncmp+0x36>
  80f9fd:	0f b6 18             	movzbl (%eax),%ebx
  80fa00:	84 db                	test   %bl,%bl
  80fa02:	74 04                	je     80fa08 <strncmp+0x2e>
  80fa04:	3a 19                	cmp    (%ecx),%bl
  80fa06:	74 e1                	je     80f9e9 <strncmp+0xf>
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80fa08:	0f b6 00             	movzbl (%eax),%eax
  80fa0b:	0f b6 11             	movzbl (%ecx),%edx
  80fa0e:	29 d0                	sub    %edx,%eax
}
  80fa10:	5b                   	pop    %ebx
  80fa11:	5d                   	pop    %ebp
  80fa12:	c3                   	ret    

0080fa13 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80fa13:	55                   	push   %ebp
  80fa14:	89 e5                	mov    %esp,%ebp
  80fa16:	8b 45 08             	mov    0x8(%ebp),%eax
  80fa19:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80fa1d:	eb 07                	jmp    80fa26 <strchr+0x13>
		if (*s == c)
  80fa1f:	38 ca                	cmp    %cl,%dl
  80fa21:	74 0f                	je     80fa32 <strchr+0x1f>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80fa23:	83 c0 01             	add    $0x1,%eax
  80fa26:	0f b6 10             	movzbl (%eax),%edx
  80fa29:	84 d2                	test   %dl,%dl
  80fa2b:	75 f2                	jne    80fa1f <strchr+0xc>
  80fa2d:	b8 00 00 00 00       	mov    $0x0,%eax
		if (*s == c)
			return (char *) s;
	return 0;
}
  80fa32:	5d                   	pop    %ebp
  80fa33:	c3                   	ret    

0080fa34 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80fa34:	55                   	push   %ebp
  80fa35:	89 e5                	mov    %esp,%ebp
  80fa37:	8b 45 08             	mov    0x8(%ebp),%eax
  80fa3a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80fa3e:	eb 07                	jmp    80fa47 <strfind+0x13>
		if (*s == c)
  80fa40:	38 ca                	cmp    %cl,%dl
  80fa42:	74 0a                	je     80fa4e <strfind+0x1a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  80fa44:	83 c0 01             	add    $0x1,%eax
  80fa47:	0f b6 10             	movzbl (%eax),%edx
  80fa4a:	84 d2                	test   %dl,%dl
  80fa4c:	75 f2                	jne    80fa40 <strfind+0xc>
		if (*s == c)
			break;
	return (char *) s;
}
  80fa4e:	5d                   	pop    %ebp
  80fa4f:	c3                   	ret    

0080fa50 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80fa50:	55                   	push   %ebp
  80fa51:	89 e5                	mov    %esp,%ebp
  80fa53:	83 ec 0c             	sub    $0xc,%esp
  80fa56:	89 1c 24             	mov    %ebx,(%esp)
  80fa59:	89 74 24 04          	mov    %esi,0x4(%esp)
  80fa5d:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80fa61:	8b 7d 08             	mov    0x8(%ebp),%edi
  80fa64:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fa67:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80fa6a:	85 c9                	test   %ecx,%ecx
  80fa6c:	74 30                	je     80fa9e <memset+0x4e>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80fa6e:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80fa74:	75 25                	jne    80fa9b <memset+0x4b>
  80fa76:	f6 c1 03             	test   $0x3,%cl
  80fa79:	75 20                	jne    80fa9b <memset+0x4b>
		c &= 0xFF;
  80fa7b:	0f b6 d0             	movzbl %al,%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80fa7e:	89 d3                	mov    %edx,%ebx
  80fa80:	c1 e3 08             	shl    $0x8,%ebx
  80fa83:	89 d6                	mov    %edx,%esi
  80fa85:	c1 e6 18             	shl    $0x18,%esi
  80fa88:	89 d0                	mov    %edx,%eax
  80fa8a:	c1 e0 10             	shl    $0x10,%eax
  80fa8d:	09 f0                	or     %esi,%eax
  80fa8f:	09 d0                	or     %edx,%eax
		asm volatile("cld; rep stosl\n"
  80fa91:	09 d8                	or     %ebx,%eax
  80fa93:	c1 e9 02             	shr    $0x2,%ecx
  80fa96:	fc                   	cld    
  80fa97:	f3 ab                	rep stos %eax,%es:(%edi)
{
	char *p;

	if (n == 0)
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80fa99:	eb 03                	jmp    80fa9e <memset+0x4e>
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80fa9b:	fc                   	cld    
  80fa9c:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80fa9e:	89 f8                	mov    %edi,%eax
  80faa0:	8b 1c 24             	mov    (%esp),%ebx
  80faa3:	8b 74 24 04          	mov    0x4(%esp),%esi
  80faa7:	8b 7c 24 08          	mov    0x8(%esp),%edi
  80faab:	89 ec                	mov    %ebp,%esp
  80faad:	5d                   	pop    %ebp
  80faae:	c3                   	ret    

0080faaf <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80faaf:	55                   	push   %ebp
  80fab0:	89 e5                	mov    %esp,%ebp
  80fab2:	83 ec 08             	sub    $0x8,%esp
  80fab5:	89 34 24             	mov    %esi,(%esp)
  80fab8:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80fabc:	8b 45 08             	mov    0x8(%ebp),%eax
  80fabf:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
  80fac2:	8b 75 0c             	mov    0xc(%ebp),%esi
	d = dst;
  80fac5:	89 c7                	mov    %eax,%edi
	if (s < d && s + n > d) {
  80fac7:	39 c6                	cmp    %eax,%esi
  80fac9:	73 35                	jae    80fb00 <memmove+0x51>
  80facb:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80face:	39 d0                	cmp    %edx,%eax
  80fad0:	73 2e                	jae    80fb00 <memmove+0x51>
		s += n;
		d += n;
  80fad2:	01 cf                	add    %ecx,%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80fad4:	f6 c2 03             	test   $0x3,%dl
  80fad7:	75 1b                	jne    80faf4 <memmove+0x45>
  80fad9:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80fadf:	75 13                	jne    80faf4 <memmove+0x45>
  80fae1:	f6 c1 03             	test   $0x3,%cl
  80fae4:	75 0e                	jne    80faf4 <memmove+0x45>
			asm volatile("std; rep movsl\n"
  80fae6:	83 ef 04             	sub    $0x4,%edi
  80fae9:	8d 72 fc             	lea    -0x4(%edx),%esi
  80faec:	c1 e9 02             	shr    $0x2,%ecx
  80faef:	fd                   	std    
  80faf0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80faf2:	eb 09                	jmp    80fafd <memmove+0x4e>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80faf4:	83 ef 01             	sub    $0x1,%edi
  80faf7:	8d 72 ff             	lea    -0x1(%edx),%esi
  80fafa:	fd                   	std    
  80fafb:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80fafd:	fc                   	cld    
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80fafe:	eb 20                	jmp    80fb20 <memmove+0x71>
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80fb00:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80fb06:	75 15                	jne    80fb1d <memmove+0x6e>
  80fb08:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80fb0e:	75 0d                	jne    80fb1d <memmove+0x6e>
  80fb10:	f6 c1 03             	test   $0x3,%cl
  80fb13:	75 08                	jne    80fb1d <memmove+0x6e>
			asm volatile("cld; rep movsl\n"
  80fb15:	c1 e9 02             	shr    $0x2,%ecx
  80fb18:	fc                   	cld    
  80fb19:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80fb1b:	eb 03                	jmp    80fb20 <memmove+0x71>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80fb1d:	fc                   	cld    
  80fb1e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80fb20:	8b 34 24             	mov    (%esp),%esi
  80fb23:	8b 7c 24 04          	mov    0x4(%esp),%edi
  80fb27:	89 ec                	mov    %ebp,%esp
  80fb29:	5d                   	pop    %ebp
  80fb2a:	c3                   	ret    

0080fb2b <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80fb2b:	55                   	push   %ebp
  80fb2c:	89 e5                	mov    %esp,%ebp
  80fb2e:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80fb31:	8b 45 10             	mov    0x10(%ebp),%eax
  80fb34:	89 44 24 08          	mov    %eax,0x8(%esp)
  80fb38:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fb3b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80fb3f:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb42:	89 04 24             	mov    %eax,(%esp)
  80fb45:	e8 65 ff ff ff       	call   80faaf <memmove>
}
  80fb4a:	c9                   	leave  
  80fb4b:	c3                   	ret    

0080fb4c <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80fb4c:	55                   	push   %ebp
  80fb4d:	89 e5                	mov    %esp,%ebp
  80fb4f:	57                   	push   %edi
  80fb50:	56                   	push   %esi
  80fb51:	53                   	push   %ebx
  80fb52:	8b 7d 08             	mov    0x8(%ebp),%edi
  80fb55:	8b 75 0c             	mov    0xc(%ebp),%esi
  80fb58:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80fb5b:	ba 00 00 00 00       	mov    $0x0,%edx
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80fb60:	eb 1c                	jmp    80fb7e <memcmp+0x32>
		if (*s1 != *s2)
  80fb62:	0f b6 04 17          	movzbl (%edi,%edx,1),%eax
  80fb66:	0f b6 1c 16          	movzbl (%esi,%edx,1),%ebx
  80fb6a:	83 c2 01             	add    $0x1,%edx
  80fb6d:	83 e9 01             	sub    $0x1,%ecx
  80fb70:	38 d8                	cmp    %bl,%al
  80fb72:	74 0a                	je     80fb7e <memcmp+0x32>
			return (int) *s1 - (int) *s2;
  80fb74:	0f b6 c0             	movzbl %al,%eax
  80fb77:	0f b6 db             	movzbl %bl,%ebx
  80fb7a:	29 d8                	sub    %ebx,%eax
  80fb7c:	eb 09                	jmp    80fb87 <memcmp+0x3b>
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80fb7e:	85 c9                	test   %ecx,%ecx
  80fb80:	75 e0                	jne    80fb62 <memcmp+0x16>
  80fb82:	b8 00 00 00 00       	mov    $0x0,%eax
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
}
  80fb87:	5b                   	pop    %ebx
  80fb88:	5e                   	pop    %esi
  80fb89:	5f                   	pop    %edi
  80fb8a:	5d                   	pop    %ebp
  80fb8b:	c3                   	ret    

0080fb8c <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80fb8c:	55                   	push   %ebp
  80fb8d:	89 e5                	mov    %esp,%ebp
  80fb8f:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb92:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80fb95:	89 c2                	mov    %eax,%edx
  80fb97:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80fb9a:	eb 07                	jmp    80fba3 <memfind+0x17>
		if (*(const unsigned char *) s == (unsigned char) c)
  80fb9c:	38 08                	cmp    %cl,(%eax)
  80fb9e:	74 07                	je     80fba7 <memfind+0x1b>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80fba0:	83 c0 01             	add    $0x1,%eax
  80fba3:	39 d0                	cmp    %edx,%eax
  80fba5:	72 f5                	jb     80fb9c <memfind+0x10>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  80fba7:	5d                   	pop    %ebp
  80fba8:	c3                   	ret    

0080fba9 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80fba9:	55                   	push   %ebp
  80fbaa:	89 e5                	mov    %esp,%ebp
  80fbac:	57                   	push   %edi
  80fbad:	56                   	push   %esi
  80fbae:	53                   	push   %ebx
  80fbaf:	83 ec 04             	sub    $0x4,%esp
  80fbb2:	8b 55 08             	mov    0x8(%ebp),%edx
  80fbb5:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80fbb8:	eb 03                	jmp    80fbbd <strtol+0x14>
		s++;
  80fbba:	83 c2 01             	add    $0x1,%edx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80fbbd:	0f b6 02             	movzbl (%edx),%eax
  80fbc0:	3c 20                	cmp    $0x20,%al
  80fbc2:	74 f6                	je     80fbba <strtol+0x11>
  80fbc4:	3c 09                	cmp    $0x9,%al
  80fbc6:	74 f2                	je     80fbba <strtol+0x11>
		s++;

	// plus/minus sign
	if (*s == '+')
  80fbc8:	3c 2b                	cmp    $0x2b,%al
  80fbca:	75 0c                	jne    80fbd8 <strtol+0x2f>
		s++;
  80fbcc:	8d 52 01             	lea    0x1(%edx),%edx
  80fbcf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  80fbd6:	eb 15                	jmp    80fbed <strtol+0x44>
	else if (*s == '-')
  80fbd8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  80fbdf:	3c 2d                	cmp    $0x2d,%al
  80fbe1:	75 0a                	jne    80fbed <strtol+0x44>
		s++, neg = 1;
  80fbe3:	8d 52 01             	lea    0x1(%edx),%edx
  80fbe6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80fbed:	85 db                	test   %ebx,%ebx
  80fbef:	0f 94 c0             	sete   %al
  80fbf2:	74 05                	je     80fbf9 <strtol+0x50>
  80fbf4:	83 fb 10             	cmp    $0x10,%ebx
  80fbf7:	75 15                	jne    80fc0e <strtol+0x65>
  80fbf9:	80 3a 30             	cmpb   $0x30,(%edx)
  80fbfc:	75 10                	jne    80fc0e <strtol+0x65>
  80fbfe:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80fc02:	75 0a                	jne    80fc0e <strtol+0x65>
		s += 2, base = 16;
  80fc04:	83 c2 02             	add    $0x2,%edx
  80fc07:	bb 10 00 00 00       	mov    $0x10,%ebx
		s++;
	else if (*s == '-')
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80fc0c:	eb 13                	jmp    80fc21 <strtol+0x78>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80fc0e:	84 c0                	test   %al,%al
  80fc10:	74 0f                	je     80fc21 <strtol+0x78>
  80fc12:	bb 0a 00 00 00       	mov    $0xa,%ebx
  80fc17:	80 3a 30             	cmpb   $0x30,(%edx)
  80fc1a:	75 05                	jne    80fc21 <strtol+0x78>
		s++, base = 8;
  80fc1c:	83 c2 01             	add    $0x1,%edx
  80fc1f:	b3 08                	mov    $0x8,%bl
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80fc21:	b8 00 00 00 00       	mov    $0x0,%eax
  80fc26:	89 de                	mov    %ebx,%esi

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80fc28:	0f b6 0a             	movzbl (%edx),%ecx
  80fc2b:	89 cf                	mov    %ecx,%edi
  80fc2d:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  80fc30:	80 fb 09             	cmp    $0x9,%bl
  80fc33:	77 08                	ja     80fc3d <strtol+0x94>
			dig = *s - '0';
  80fc35:	0f be c9             	movsbl %cl,%ecx
  80fc38:	83 e9 30             	sub    $0x30,%ecx
  80fc3b:	eb 1e                	jmp    80fc5b <strtol+0xb2>
		else if (*s >= 'a' && *s <= 'z')
  80fc3d:	8d 5f 9f             	lea    -0x61(%edi),%ebx
  80fc40:	80 fb 19             	cmp    $0x19,%bl
  80fc43:	77 08                	ja     80fc4d <strtol+0xa4>
			dig = *s - 'a' + 10;
  80fc45:	0f be c9             	movsbl %cl,%ecx
  80fc48:	83 e9 57             	sub    $0x57,%ecx
  80fc4b:	eb 0e                	jmp    80fc5b <strtol+0xb2>
		else if (*s >= 'A' && *s <= 'Z')
  80fc4d:	8d 5f bf             	lea    -0x41(%edi),%ebx
  80fc50:	80 fb 19             	cmp    $0x19,%bl
  80fc53:	77 15                	ja     80fc6a <strtol+0xc1>
			dig = *s - 'A' + 10;
  80fc55:	0f be c9             	movsbl %cl,%ecx
  80fc58:	83 e9 37             	sub    $0x37,%ecx
		else
			break;
		if (dig >= base)
  80fc5b:	39 f1                	cmp    %esi,%ecx
  80fc5d:	7d 0b                	jge    80fc6a <strtol+0xc1>
			break;
		s++, val = (val * base) + dig;
  80fc5f:	83 c2 01             	add    $0x1,%edx
  80fc62:	0f af c6             	imul   %esi,%eax
  80fc65:	8d 04 01             	lea    (%ecx,%eax,1),%eax
		// we don't properly detect overflow!
	}
  80fc68:	eb be                	jmp    80fc28 <strtol+0x7f>
  80fc6a:	89 c1                	mov    %eax,%ecx

	if (endptr)
  80fc6c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80fc70:	74 05                	je     80fc77 <strtol+0xce>
		*endptr = (char *) s;
  80fc72:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80fc75:	89 13                	mov    %edx,(%ebx)
	return (neg ? -val : val);
  80fc77:	89 ca                	mov    %ecx,%edx
  80fc79:	f7 da                	neg    %edx
  80fc7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  80fc7f:	0f 45 c2             	cmovne %edx,%eax
}
  80fc82:	83 c4 04             	add    $0x4,%esp
  80fc85:	5b                   	pop    %ebx
  80fc86:	5e                   	pop    %esi
  80fc87:	5f                   	pop    %edi
  80fc88:	5d                   	pop    %ebp
  80fc89:	c3                   	ret    
	...

0080fc8c <sys_cgetc>:
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}

int
sys_cgetc(void)
{
  80fc8c:	55                   	push   %ebp
  80fc8d:	89 e5                	mov    %esp,%ebp
  80fc8f:	83 ec 0c             	sub    $0xc,%esp
  80fc92:	89 1c 24             	mov    %ebx,(%esp)
  80fc95:	89 74 24 04          	mov    %esi,0x4(%esp)
  80fc99:	89 7c 24 08          	mov    %edi,0x8(%esp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fc9d:	ba 00 00 00 00       	mov    $0x0,%edx
  80fca2:	b8 01 00 00 00       	mov    $0x1,%eax
  80fca7:	89 d1                	mov    %edx,%ecx
  80fca9:	89 d3                	mov    %edx,%ebx
  80fcab:	89 d7                	mov    %edx,%edi
  80fcad:	89 d6                	mov    %edx,%esi
  80fcaf:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80fcb1:	8b 1c 24             	mov    (%esp),%ebx
  80fcb4:	8b 74 24 04          	mov    0x4(%esp),%esi
  80fcb8:	8b 7c 24 08          	mov    0x8(%esp),%edi
  80fcbc:	89 ec                	mov    %ebp,%esp
  80fcbe:	5d                   	pop    %ebp
  80fcbf:	c3                   	ret    

0080fcc0 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80fcc0:	55                   	push   %ebp
  80fcc1:	89 e5                	mov    %esp,%ebp
  80fcc3:	83 ec 0c             	sub    $0xc,%esp
  80fcc6:	89 1c 24             	mov    %ebx,(%esp)
  80fcc9:	89 74 24 04          	mov    %esi,0x4(%esp)
  80fccd:	89 7c 24 08          	mov    %edi,0x8(%esp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fcd1:	b8 00 00 00 00       	mov    $0x0,%eax
  80fcd6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fcd9:	8b 55 08             	mov    0x8(%ebp),%edx
  80fcdc:	89 c3                	mov    %eax,%ebx
  80fcde:	89 c7                	mov    %eax,%edi
  80fce0:	89 c6                	mov    %eax,%esi
  80fce2:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80fce4:	8b 1c 24             	mov    (%esp),%ebx
  80fce7:	8b 74 24 04          	mov    0x4(%esp),%esi
  80fceb:	8b 7c 24 08          	mov    0x8(%esp),%edi
  80fcef:	89 ec                	mov    %ebp,%esp
  80fcf1:	5d                   	pop    %ebp
  80fcf2:	c3                   	ret    

0080fcf3 <sys_time_msec>:
	return syscall(SYS_net_recv, 1, (uint32_t)buf, (uint32_t)size, 0, 0, 0);
}

unsigned int
sys_time_msec(void)
{
  80fcf3:	55                   	push   %ebp
  80fcf4:	89 e5                	mov    %esp,%ebp
  80fcf6:	83 ec 0c             	sub    $0xc,%esp
  80fcf9:	89 1c 24             	mov    %ebx,(%esp)
  80fcfc:	89 74 24 04          	mov    %esi,0x4(%esp)
  80fd00:	89 7c 24 08          	mov    %edi,0x8(%esp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fd04:	ba 00 00 00 00       	mov    $0x0,%edx
  80fd09:	b8 10 00 00 00       	mov    $0x10,%eax
  80fd0e:	89 d1                	mov    %edx,%ecx
  80fd10:	89 d3                	mov    %edx,%ebx
  80fd12:	89 d7                	mov    %edx,%edi
  80fd14:	89 d6                	mov    %edx,%esi
  80fd16:	cd 30                	int    $0x30

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80fd18:	8b 1c 24             	mov    (%esp),%ebx
  80fd1b:	8b 74 24 04          	mov    0x4(%esp),%esi
  80fd1f:	8b 7c 24 08          	mov    0x8(%esp),%edi
  80fd23:	89 ec                	mov    %ebp,%esp
  80fd25:	5d                   	pop    %ebp
  80fd26:	c3                   	ret    

0080fd27 <sys_net_receive>:
	return syscall(SYS_net_send, 1, (uint32_t)buf, size, 0, 0, 0);
}

int
sys_net_receive(uint32_t * buf, uint32_t *size)
{
  80fd27:	55                   	push   %ebp
  80fd28:	89 e5                	mov    %esp,%ebp
  80fd2a:	83 ec 38             	sub    $0x38,%esp
  80fd2d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80fd30:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80fd33:	89 7d fc             	mov    %edi,-0x4(%ebp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fd36:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fd3b:	b8 0f 00 00 00       	mov    $0xf,%eax
  80fd40:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fd43:	8b 55 08             	mov    0x8(%ebp),%edx
  80fd46:	89 df                	mov    %ebx,%edi
  80fd48:	89 de                	mov    %ebx,%esi
  80fd4a:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fd4c:	85 c0                	test   %eax,%eax
  80fd4e:	7e 28                	jle    80fd78 <sys_net_receive+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fd50:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fd54:	c7 44 24 0c 0f 00 00 	movl   $0xf,0xc(%esp)
  80fd5b:	00 
  80fd5c:	c7 44 24 08 87 38 81 	movl   $0x813887,0x8(%esp)
  80fd63:	00 
  80fd64:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fd6b:	00 
  80fd6c:	c7 04 24 a4 38 81 00 	movl   $0x8138a4,(%esp)
  80fd73:	e8 74 f4 ff ff       	call   80f1ec <_panic>

int
sys_net_receive(uint32_t * buf, uint32_t *size)
{
	return syscall(SYS_net_recv, 1, (uint32_t)buf, (uint32_t)size, 0, 0, 0);
}
  80fd78:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fd7b:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fd7e:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fd81:	89 ec                	mov    %ebp,%esp
  80fd83:	5d                   	pop    %ebp
  80fd84:	c3                   	ret    

0080fd85 <sys_net_send>:
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}

int
sys_net_send(void *buf, uint32_t size)
{
  80fd85:	55                   	push   %ebp
  80fd86:	89 e5                	mov    %esp,%ebp
  80fd88:	83 ec 38             	sub    $0x38,%esp
  80fd8b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80fd8e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80fd91:	89 7d fc             	mov    %edi,-0x4(%ebp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fd94:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fd99:	b8 0e 00 00 00       	mov    $0xe,%eax
  80fd9e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fda1:	8b 55 08             	mov    0x8(%ebp),%edx
  80fda4:	89 df                	mov    %ebx,%edi
  80fda6:	89 de                	mov    %ebx,%esi
  80fda8:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fdaa:	85 c0                	test   %eax,%eax
  80fdac:	7e 28                	jle    80fdd6 <sys_net_send+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fdae:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fdb2:	c7 44 24 0c 0e 00 00 	movl   $0xe,0xc(%esp)
  80fdb9:	00 
  80fdba:	c7 44 24 08 87 38 81 	movl   $0x813887,0x8(%esp)
  80fdc1:	00 
  80fdc2:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fdc9:	00 
  80fdca:	c7 04 24 a4 38 81 00 	movl   $0x8138a4,(%esp)
  80fdd1:	e8 16 f4 ff ff       	call   80f1ec <_panic>

int
sys_net_send(void *buf, uint32_t size)
{
	return syscall(SYS_net_send, 1, (uint32_t)buf, size, 0, 0, 0);
}
  80fdd6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fdd9:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fddc:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fddf:	89 ec                	mov    %ebp,%esp
  80fde1:	5d                   	pop    %ebp
  80fde2:	c3                   	ret    

0080fde3 <sys_ipc_recv>:
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}

int
sys_ipc_recv(void *dstva)
{
  80fde3:	55                   	push   %ebp
  80fde4:	89 e5                	mov    %esp,%ebp
  80fde6:	83 ec 38             	sub    $0x38,%esp
  80fde9:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80fdec:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80fdef:	89 7d fc             	mov    %edi,-0x4(%ebp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fdf2:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fdf7:	b8 0d 00 00 00       	mov    $0xd,%eax
  80fdfc:	8b 55 08             	mov    0x8(%ebp),%edx
  80fdff:	89 cb                	mov    %ecx,%ebx
  80fe01:	89 cf                	mov    %ecx,%edi
  80fe03:	89 ce                	mov    %ecx,%esi
  80fe05:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fe07:	85 c0                	test   %eax,%eax
  80fe09:	7e 28                	jle    80fe33 <sys_ipc_recv+0x50>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fe0b:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fe0f:	c7 44 24 0c 0d 00 00 	movl   $0xd,0xc(%esp)
  80fe16:	00 
  80fe17:	c7 44 24 08 87 38 81 	movl   $0x813887,0x8(%esp)
  80fe1e:	00 
  80fe1f:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fe26:	00 
  80fe27:	c7 04 24 a4 38 81 00 	movl   $0x8138a4,(%esp)
  80fe2e:	e8 b9 f3 ff ff       	call   80f1ec <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80fe33:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fe36:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fe39:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fe3c:	89 ec                	mov    %ebp,%esp
  80fe3e:	5d                   	pop    %ebp
  80fe3f:	c3                   	ret    

0080fe40 <sys_ipc_try_send>:
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80fe40:	55                   	push   %ebp
  80fe41:	89 e5                	mov    %esp,%ebp
  80fe43:	83 ec 0c             	sub    $0xc,%esp
  80fe46:	89 1c 24             	mov    %ebx,(%esp)
  80fe49:	89 74 24 04          	mov    %esi,0x4(%esp)
  80fe4d:	89 7c 24 08          	mov    %edi,0x8(%esp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fe51:	be 00 00 00 00       	mov    $0x0,%esi
  80fe56:	b8 0c 00 00 00       	mov    $0xc,%eax
  80fe5b:	8b 7d 14             	mov    0x14(%ebp),%edi
  80fe5e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80fe61:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fe64:	8b 55 08             	mov    0x8(%ebp),%edx
  80fe67:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80fe69:	8b 1c 24             	mov    (%esp),%ebx
  80fe6c:	8b 74 24 04          	mov    0x4(%esp),%esi
  80fe70:	8b 7c 24 08          	mov    0x8(%esp),%edi
  80fe74:	89 ec                	mov    %ebp,%esp
  80fe76:	5d                   	pop    %ebp
  80fe77:	c3                   	ret    

0080fe78 <sys_env_set_pgfault_upcall>:
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80fe78:	55                   	push   %ebp
  80fe79:	89 e5                	mov    %esp,%ebp
  80fe7b:	83 ec 38             	sub    $0x38,%esp
  80fe7e:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80fe81:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80fe84:	89 7d fc             	mov    %edi,-0x4(%ebp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fe87:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fe8c:	b8 0a 00 00 00       	mov    $0xa,%eax
  80fe91:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fe94:	8b 55 08             	mov    0x8(%ebp),%edx
  80fe97:	89 df                	mov    %ebx,%edi
  80fe99:	89 de                	mov    %ebx,%esi
  80fe9b:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fe9d:	85 c0                	test   %eax,%eax
  80fe9f:	7e 28                	jle    80fec9 <sys_env_set_pgfault_upcall+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fea1:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fea5:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
  80feac:	00 
  80fead:	c7 44 24 08 87 38 81 	movl   $0x813887,0x8(%esp)
  80feb4:	00 
  80feb5:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80febc:	00 
  80febd:	c7 04 24 a4 38 81 00 	movl   $0x8138a4,(%esp)
  80fec4:	e8 23 f3 ff ff       	call   80f1ec <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80fec9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fecc:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fecf:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fed2:	89 ec                	mov    %ebp,%esp
  80fed4:	5d                   	pop    %ebp
  80fed5:	c3                   	ret    

0080fed6 <sys_env_set_trapframe>:
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80fed6:	55                   	push   %ebp
  80fed7:	89 e5                	mov    %esp,%ebp
  80fed9:	83 ec 38             	sub    $0x38,%esp
  80fedc:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80fedf:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80fee2:	89 7d fc             	mov    %edi,-0x4(%ebp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fee5:	bb 00 00 00 00       	mov    $0x0,%ebx
  80feea:	b8 09 00 00 00       	mov    $0x9,%eax
  80feef:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fef2:	8b 55 08             	mov    0x8(%ebp),%edx
  80fef5:	89 df                	mov    %ebx,%edi
  80fef7:	89 de                	mov    %ebx,%esi
  80fef9:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fefb:	85 c0                	test   %eax,%eax
  80fefd:	7e 28                	jle    80ff27 <sys_env_set_trapframe+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  80feff:	89 44 24 10          	mov    %eax,0x10(%esp)
  80ff03:	c7 44 24 0c 09 00 00 	movl   $0x9,0xc(%esp)
  80ff0a:	00 
  80ff0b:	c7 44 24 08 87 38 81 	movl   $0x813887,0x8(%esp)
  80ff12:	00 
  80ff13:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80ff1a:	00 
  80ff1b:	c7 04 24 a4 38 81 00 	movl   $0x8138a4,(%esp)
  80ff22:	e8 c5 f2 ff ff       	call   80f1ec <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80ff27:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ff2a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ff2d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ff30:	89 ec                	mov    %ebp,%esp
  80ff32:	5d                   	pop    %ebp
  80ff33:	c3                   	ret    

0080ff34 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80ff34:	55                   	push   %ebp
  80ff35:	89 e5                	mov    %esp,%ebp
  80ff37:	83 ec 38             	sub    $0x38,%esp
  80ff3a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ff3d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ff40:	89 7d fc             	mov    %edi,-0x4(%ebp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ff43:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ff48:	b8 08 00 00 00       	mov    $0x8,%eax
  80ff4d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ff50:	8b 55 08             	mov    0x8(%ebp),%edx
  80ff53:	89 df                	mov    %ebx,%edi
  80ff55:	89 de                	mov    %ebx,%esi
  80ff57:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ff59:	85 c0                	test   %eax,%eax
  80ff5b:	7e 28                	jle    80ff85 <sys_env_set_status+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ff5d:	89 44 24 10          	mov    %eax,0x10(%esp)
  80ff61:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
  80ff68:	00 
  80ff69:	c7 44 24 08 87 38 81 	movl   $0x813887,0x8(%esp)
  80ff70:	00 
  80ff71:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80ff78:	00 
  80ff79:	c7 04 24 a4 38 81 00 	movl   $0x8138a4,(%esp)
  80ff80:	e8 67 f2 ff ff       	call   80f1ec <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80ff85:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ff88:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ff8b:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ff8e:	89 ec                	mov    %ebp,%esp
  80ff90:	5d                   	pop    %ebp
  80ff91:	c3                   	ret    

0080ff92 <sys_page_unmap>:
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}

int
sys_page_unmap(envid_t envid, void *va)
{
  80ff92:	55                   	push   %ebp
  80ff93:	89 e5                	mov    %esp,%ebp
  80ff95:	83 ec 38             	sub    $0x38,%esp
  80ff98:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ff9b:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ff9e:	89 7d fc             	mov    %edi,-0x4(%ebp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ffa1:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ffa6:	b8 06 00 00 00       	mov    $0x6,%eax
  80ffab:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ffae:	8b 55 08             	mov    0x8(%ebp),%edx
  80ffb1:	89 df                	mov    %ebx,%edi
  80ffb3:	89 de                	mov    %ebx,%esi
  80ffb5:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ffb7:	85 c0                	test   %eax,%eax
  80ffb9:	7e 28                	jle    80ffe3 <sys_page_unmap+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ffbb:	89 44 24 10          	mov    %eax,0x10(%esp)
  80ffbf:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80ffc6:	00 
  80ffc7:	c7 44 24 08 87 38 81 	movl   $0x813887,0x8(%esp)
  80ffce:	00 
  80ffcf:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80ffd6:	00 
  80ffd7:	c7 04 24 a4 38 81 00 	movl   $0x8138a4,(%esp)
  80ffde:	e8 09 f2 ff ff       	call   80f1ec <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80ffe3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ffe6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ffe9:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ffec:	89 ec                	mov    %ebp,%esp
  80ffee:	5d                   	pop    %ebp
  80ffef:	c3                   	ret    

0080fff0 <sys_page_map>:
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80fff0:	55                   	push   %ebp
  80fff1:	89 e5                	mov    %esp,%ebp
  80fff3:	83 ec 38             	sub    $0x38,%esp
  80fff6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80fff9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80fffc:	89 7d fc             	mov    %edi,-0x4(%ebp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ffff:	b8 05 00 00 00       	mov    $0x5,%eax
  810004:	8b 75 18             	mov    0x18(%ebp),%esi
  810007:	8b 7d 14             	mov    0x14(%ebp),%edi
  81000a:	8b 5d 10             	mov    0x10(%ebp),%ebx
  81000d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810010:	8b 55 08             	mov    0x8(%ebp),%edx
  810013:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  810015:	85 c0                	test   %eax,%eax
  810017:	7e 28                	jle    810041 <sys_page_map+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  810019:	89 44 24 10          	mov    %eax,0x10(%esp)
  81001d:	c7 44 24 0c 05 00 00 	movl   $0x5,0xc(%esp)
  810024:	00 
  810025:	c7 44 24 08 87 38 81 	movl   $0x813887,0x8(%esp)
  81002c:	00 
  81002d:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  810034:	00 
  810035:	c7 04 24 a4 38 81 00 	movl   $0x8138a4,(%esp)
  81003c:	e8 ab f1 ff ff       	call   80f1ec <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  810041:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  810044:	8b 75 f8             	mov    -0x8(%ebp),%esi
  810047:	8b 7d fc             	mov    -0x4(%ebp),%edi
  81004a:	89 ec                	mov    %ebp,%esp
  81004c:	5d                   	pop    %ebp
  81004d:	c3                   	ret    

0081004e <sys_page_alloc>:
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  81004e:	55                   	push   %ebp
  81004f:	89 e5                	mov    %esp,%ebp
  810051:	83 ec 38             	sub    $0x38,%esp
  810054:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  810057:	89 75 f8             	mov    %esi,-0x8(%ebp)
  81005a:	89 7d fc             	mov    %edi,-0x4(%ebp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  81005d:	be 00 00 00 00       	mov    $0x0,%esi
  810062:	b8 04 00 00 00       	mov    $0x4,%eax
  810067:	8b 5d 10             	mov    0x10(%ebp),%ebx
  81006a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  81006d:	8b 55 08             	mov    0x8(%ebp),%edx
  810070:	89 f7                	mov    %esi,%edi
  810072:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  810074:	85 c0                	test   %eax,%eax
  810076:	7e 28                	jle    8100a0 <sys_page_alloc+0x52>
		panic("syscall %d returned %d (> 0)", num, ret);
  810078:	89 44 24 10          	mov    %eax,0x10(%esp)
  81007c:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
  810083:	00 
  810084:	c7 44 24 08 87 38 81 	movl   $0x813887,0x8(%esp)
  81008b:	00 
  81008c:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  810093:	00 
  810094:	c7 04 24 a4 38 81 00 	movl   $0x8138a4,(%esp)
  81009b:	e8 4c f1 ff ff       	call   80f1ec <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  8100a0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8100a3:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8100a6:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8100a9:	89 ec                	mov    %ebp,%esp
  8100ab:	5d                   	pop    %ebp
  8100ac:	c3                   	ret    

008100ad <sys_yield>:
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}

void
sys_yield(void)
{
  8100ad:	55                   	push   %ebp
  8100ae:	89 e5                	mov    %esp,%ebp
  8100b0:	83 ec 0c             	sub    $0xc,%esp
  8100b3:	89 1c 24             	mov    %ebx,(%esp)
  8100b6:	89 74 24 04          	mov    %esi,0x4(%esp)
  8100ba:	89 7c 24 08          	mov    %edi,0x8(%esp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8100be:	ba 00 00 00 00       	mov    $0x0,%edx
  8100c3:	b8 0b 00 00 00       	mov    $0xb,%eax
  8100c8:	89 d1                	mov    %edx,%ecx
  8100ca:	89 d3                	mov    %edx,%ebx
  8100cc:	89 d7                	mov    %edx,%edi
  8100ce:	89 d6                	mov    %edx,%esi
  8100d0:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  8100d2:	8b 1c 24             	mov    (%esp),%ebx
  8100d5:	8b 74 24 04          	mov    0x4(%esp),%esi
  8100d9:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8100dd:	89 ec                	mov    %ebp,%esp
  8100df:	5d                   	pop    %ebp
  8100e0:	c3                   	ret    

008100e1 <sys_getenvid>:
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}

envid_t
sys_getenvid(void)
{
  8100e1:	55                   	push   %ebp
  8100e2:	89 e5                	mov    %esp,%ebp
  8100e4:	83 ec 0c             	sub    $0xc,%esp
  8100e7:	89 1c 24             	mov    %ebx,(%esp)
  8100ea:	89 74 24 04          	mov    %esi,0x4(%esp)
  8100ee:	89 7c 24 08          	mov    %edi,0x8(%esp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8100f2:	ba 00 00 00 00       	mov    $0x0,%edx
  8100f7:	b8 02 00 00 00       	mov    $0x2,%eax
  8100fc:	89 d1                	mov    %edx,%ecx
  8100fe:	89 d3                	mov    %edx,%ebx
  810100:	89 d7                	mov    %edx,%edi
  810102:	89 d6                	mov    %edx,%esi
  810104:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  810106:	8b 1c 24             	mov    (%esp),%ebx
  810109:	8b 74 24 04          	mov    0x4(%esp),%esi
  81010d:	8b 7c 24 08          	mov    0x8(%esp),%edi
  810111:	89 ec                	mov    %ebp,%esp
  810113:	5d                   	pop    %ebp
  810114:	c3                   	ret    

00810115 <sys_env_destroy>:
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}

int
sys_env_destroy(envid_t envid)
{
  810115:	55                   	push   %ebp
  810116:	89 e5                	mov    %esp,%ebp
  810118:	83 ec 38             	sub    $0x38,%esp
  81011b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  81011e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  810121:	89 7d fc             	mov    %edi,-0x4(%ebp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  810124:	b9 00 00 00 00       	mov    $0x0,%ecx
  810129:	b8 03 00 00 00       	mov    $0x3,%eax
  81012e:	8b 55 08             	mov    0x8(%ebp),%edx
  810131:	89 cb                	mov    %ecx,%ebx
  810133:	89 cf                	mov    %ecx,%edi
  810135:	89 ce                	mov    %ecx,%esi
  810137:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  810139:	85 c0                	test   %eax,%eax
  81013b:	7e 28                	jle    810165 <sys_env_destroy+0x50>
		panic("syscall %d returned %d (> 0)", num, ret);
  81013d:	89 44 24 10          	mov    %eax,0x10(%esp)
  810141:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
  810148:	00 
  810149:	c7 44 24 08 87 38 81 	movl   $0x813887,0x8(%esp)
  810150:	00 
  810151:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  810158:	00 
  810159:	c7 04 24 a4 38 81 00 	movl   $0x8138a4,(%esp)
  810160:	e8 87 f0 ff ff       	call   80f1ec <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  810165:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  810168:	8b 75 f8             	mov    -0x8(%ebp),%esi
  81016b:	8b 7d fc             	mov    -0x4(%ebp),%edi
  81016e:	89 ec                	mov    %ebp,%esp
  810170:	5d                   	pop    %ebp
  810171:	c3                   	ret    
	...

00810174 <sfork>:
}

// Challenge!
int
sfork(void)
{
  810174:	55                   	push   %ebp
  810175:	89 e5                	mov    %esp,%ebp
  810177:	83 ec 18             	sub    $0x18,%esp
	panic("sfork not implemented");
  81017a:	c7 44 24 08 b2 38 81 	movl   $0x8138b2,0x8(%esp)
  810181:	00 
  810182:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  810189:	00 
  81018a:	c7 04 24 c8 38 81 00 	movl   $0x8138c8,(%esp)
  810191:	e8 56 f0 ff ff       	call   80f1ec <_panic>

00810196 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  810196:	55                   	push   %ebp
  810197:	89 e5                	mov    %esp,%ebp
  810199:	57                   	push   %edi
  81019a:	56                   	push   %esi
  81019b:	53                   	push   %ebx
  81019c:	83 ec 4c             	sub    $0x4c,%esp
	// LAB 4: Your code here.	
	uintptr_t addr;
	int ret;
	size_t i,j;
	
	set_pgfault_handler(pgfault);
  81019f:	c7 04 24 04 04 81 00 	movl   $0x810404,(%esp)
  8101a6:	e8 05 0a 00 00       	call   810bb0 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  8101ab:	ba 07 00 00 00       	mov    $0x7,%edx
  8101b0:	89 d0                	mov    %edx,%eax
  8101b2:	cd 30                	int    $0x30
  8101b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	envid_t envid = sys_exofork();
	if (envid < 0)
  8101b7:	85 c0                	test   %eax,%eax
  8101b9:	79 20                	jns    8101db <fork+0x45>
		panic("sys_exofork: %e", envid);
  8101bb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8101bf:	c7 44 24 08 d3 38 81 	movl   $0x8138d3,0x8(%esp)
  8101c6:	00 
  8101c7:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  8101ce:	00 
  8101cf:	c7 04 24 c8 38 81 00 	movl   $0x8138c8,(%esp)
  8101d6:	e8 11 f0 ff ff       	call   80f1ec <_panic>
	if (envid == 0) 
	{
		// We're the child.
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
  8101db:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
			for(j=0;j<NPTENTRIES;j++)
			{
				addr = (i<<PDXSHIFT)+(j<<PGSHIFT);
				if(addr == UXSTACKTOP-PGSIZE) continue;
				
				if(uvpt[addr>>PGSHIFT] & PTE_P)
  8101e2:	bf 00 00 40 ef       	mov    $0xef400000,%edi
	set_pgfault_handler(pgfault);

	envid_t envid = sys_exofork();
	if (envid < 0)
		panic("sys_exofork: %e", envid);
	if (envid == 0) 
  8101e7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  8101eb:	75 21                	jne    81020e <fork+0x78>
	{
		// We're the child.
		thisenv = &envs[ENVX(sys_getenvid())];
  8101ed:	e8 ef fe ff ff       	call   8100e1 <sys_getenvid>
  8101f2:	25 ff 03 00 00       	and    $0x3ff,%eax
  8101f7:	6b c0 7c             	imul   $0x7c,%eax,%eax
  8101fa:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  8101ff:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
  810204:	b8 00 00 00 00       	mov    $0x0,%eax
		return 0;
  810209:	e9 e5 01 00 00       	jmp    8103f3 <fork+0x25d>
	}

	// We're the parent.
	for(i=0;i<PDX(UTOP);i++)
	{
		if(uvpd[i] & PTE_P && i != PDX(UVPT))
  81020e:	8b 55 d8             	mov    -0x28(%ebp),%edx
  810211:	8b 04 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%eax
  810218:	a8 01                	test   $0x1,%al
  81021a:	0f 84 4c 01 00 00    	je     81036c <fork+0x1d6>
  810220:	81 fa bd 03 00 00    	cmp    $0x3bd,%edx
  810226:	0f 84 cf 01 00 00    	je     8103fb <fork+0x265>
		{
			addr = i << PDXSHIFT;
  81022c:	c1 e2 16             	shl    $0x16,%edx
  81022f:	89 55 e0             	mov    %edx,-0x20(%ebp)
			ret = sys_page_alloc(envid,(void *)addr,PTE_P|PTE_U|PTE_W);
  810232:	89 d3                	mov    %edx,%ebx
  810234:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  81023b:	00 
  81023c:	89 54 24 04          	mov    %edx,0x4(%esp)
  810240:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  810243:	89 04 24             	mov    %eax,(%esp)
  810246:	e8 03 fe ff ff       	call   81004e <sys_page_alloc>
			if(ret < 0) return ret;
  81024b:	85 c0                	test   %eax,%eax
  81024d:	0f 88 a0 01 00 00    	js     8103f3 <fork+0x25d>
			ret = sys_page_unmap(envid,(void *)addr);
  810253:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810257:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  81025a:	89 14 24             	mov    %edx,(%esp)
  81025d:	e8 30 fd ff ff       	call   80ff92 <sys_page_unmap>
			if(ret < 0) return ret;
  810262:	85 c0                	test   %eax,%eax
  810264:	0f 88 89 01 00 00    	js     8103f3 <fork+0x25d>
  81026a:	bb 00 00 00 00       	mov    $0x0,%ebx

			for(j=0;j<NPTENTRIES;j++)
			{
				addr = (i<<PDXSHIFT)+(j<<PGSHIFT);
  81026f:	89 de                	mov    %ebx,%esi
  810271:	c1 e6 0c             	shl    $0xc,%esi
  810274:	03 75 e0             	add    -0x20(%ebp),%esi
				if(addr == UXSTACKTOP-PGSIZE) continue;
  810277:	81 fe 00 f0 bf ee    	cmp    $0xeebff000,%esi
  81027d:	0f 84 da 00 00 00    	je     81035d <fork+0x1c7>
				
				if(uvpt[addr>>PGSHIFT] & PTE_P)
  810283:	c1 ee 0c             	shr    $0xc,%esi
  810286:	8b 04 b7             	mov    (%edi,%esi,4),%eax
  810289:	a8 01                	test   $0x1,%al
  81028b:	0f 84 cc 00 00 00    	je     81035d <fork+0x1c7>
static int
duppage(envid_t envid, unsigned pn)
{
	int ret;
	int perm;
	uint32_t va = pn << PGSHIFT;
  810291:	89 f0                	mov    %esi,%eax
  810293:	c1 e0 0c             	shl    $0xc,%eax
  810296:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	envid_t curr_envid = sys_getenvid();
  810299:	e8 43 fe ff ff       	call   8100e1 <sys_getenvid>
  81029e:	89 45 dc             	mov    %eax,-0x24(%ebp)

	// LAB 4: Your code here.
	perm = uvpt[pn] & 0xFFF;
  8102a1:	8b 04 b7             	mov    (%edi,%esi,4),%eax
  8102a4:	89 c6                	mov    %eax,%esi
  8102a6:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
	
	if((perm & PTE_P) && ( perm & PTE_SHARE))
  8102ac:	25 01 04 00 00       	and    $0x401,%eax
  8102b1:	3d 01 04 00 00       	cmp    $0x401,%eax
  8102b6:	75 3a                	jne    8102f2 <fork+0x15c>
	{
		perm = sys_page_map(curr_envid, (void *)va, envid, (void *)va, PTE_AVAIL|PTE_P|PTE_U|PTE_W);
  8102b8:	c7 44 24 10 07 0e 00 	movl   $0xe07,0x10(%esp)
  8102bf:	00 
  8102c0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8102c3:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8102c7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8102ca:	89 44 24 08          	mov    %eax,0x8(%esp)
  8102ce:	89 54 24 04          	mov    %edx,0x4(%esp)
  8102d2:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8102d5:	89 14 24             	mov    %edx,(%esp)
  8102d8:	e8 13 fd ff ff       	call   80fff0 <sys_page_map>
		if(ret)	panic("sys_page_map: %e", ret);
		cprintf("copy shared page : %x\n",va);
  8102dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8102e0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8102e4:	c7 04 24 e3 38 81 00 	movl   $0x8138e3,(%esp)
  8102eb:	e8 b5 ef ff ff       	call   80f2a5 <cprintf>
  8102f0:	eb 6b                	jmp    81035d <fork+0x1c7>
		return ret;
	}	
	if((perm & PTE_P) && (( perm & PTE_W) || (perm & PTE_COW)))
  8102f2:	f7 c6 01 00 00 00    	test   $0x1,%esi
  8102f8:	74 14                	je     81030e <fork+0x178>
  8102fa:	f7 c6 02 08 00 00    	test   $0x802,%esi
  810300:	74 0c                	je     81030e <fork+0x178>
	{
		perm = (perm & (~PTE_W)) | PTE_COW;
  810302:	81 e6 fd f7 ff ff    	and    $0xfffff7fd,%esi
  810308:	81 ce 00 08 00 00    	or     $0x800,%esi
		//cprintf("copy cow page : %x\n",va);
	}
	ret = sys_page_map(curr_envid, (void *)va, envid, (void *)va, perm);
  81030e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  810311:	89 74 24 10          	mov    %esi,0x10(%esp)
  810315:	89 54 24 0c          	mov    %edx,0xc(%esp)
  810319:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  81031c:	89 44 24 08          	mov    %eax,0x8(%esp)
  810320:	89 54 24 04          	mov    %edx,0x4(%esp)
  810324:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810327:	89 14 24             	mov    %edx,(%esp)
  81032a:	e8 c1 fc ff ff       	call   80fff0 <sys_page_map>
	if(ret<0) return ret;
  81032f:	85 c0                	test   %eax,%eax
  810331:	0f 88 bc 00 00 00    	js     8103f3 <fork+0x25d>

	ret = sys_page_map(curr_envid, (void *)va, curr_envid, (void *)va, perm);
  810337:	89 74 24 10          	mov    %esi,0x10(%esp)
  81033b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81033e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810342:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810345:	89 54 24 08          	mov    %edx,0x8(%esp)
  810349:	89 44 24 04          	mov    %eax,0x4(%esp)
  81034d:	89 14 24             	mov    %edx,(%esp)
  810350:	e8 9b fc ff ff       	call   80fff0 <sys_page_map>
				
				if(uvpt[addr>>PGSHIFT] & PTE_P)
				{
					//cprintf("we are trying to alloc %x\n",addr);		
					ret = duppage(envid,addr>>PGSHIFT);
					if(ret < 0) return ret;
  810355:	85 c0                	test   %eax,%eax
  810357:	0f 88 96 00 00 00    	js     8103f3 <fork+0x25d>
			ret = sys_page_alloc(envid,(void *)addr,PTE_P|PTE_U|PTE_W);
			if(ret < 0) return ret;
			ret = sys_page_unmap(envid,(void *)addr);
			if(ret < 0) return ret;

			for(j=0;j<NPTENTRIES;j++)
  81035d:	83 c3 01             	add    $0x1,%ebx
  810360:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
  810366:	0f 85 03 ff ff ff    	jne    81026f <fork+0xd9>
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}

	// We're the parent.
	for(i=0;i<PDX(UTOP);i++)
  81036c:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
  810370:	81 7d d8 bb 03 00 00 	cmpl   $0x3bb,-0x28(%ebp)
  810377:	0f 85 91 fe ff ff    	jne    81020e <fork+0x78>
			}
		}
	}

	// Allocate a new user exception stack.
	ret = sys_page_alloc(envid,(void *)UXSTACKTOP-PGSIZE,PTE_P|PTE_U|PTE_W);
  81037d:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  810384:	00 
  810385:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  81038c:	ee 
  81038d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  810390:	89 04 24             	mov    %eax,(%esp)
  810393:	e8 b6 fc ff ff       	call   81004e <sys_page_alloc>
	if(ret < 0) return ret;
  810398:	85 c0                	test   %eax,%eax
  81039a:	78 57                	js     8103f3 <fork+0x25d>

	//copy page fault handler
	ret = sys_env_set_pgfault_upcall(envid,thisenv->env_pgfault_upcall);
  81039c:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  8103a1:	8b 40 64             	mov    0x64(%eax),%eax
  8103a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8103a8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8103ab:	89 14 24             	mov    %edx,(%esp)
  8103ae:	e8 c5 fa ff ff       	call   80fe78 <sys_env_set_pgfault_upcall>
	if(ret < 0) return ret;
  8103b3:	85 c0                	test   %eax,%eax
  8103b5:	78 3c                	js     8103f3 <fork+0x25d>
	
	// Start the child environment running
	if ((ret = sys_env_set_status(envid, ENV_RUNNABLE)) < 0)
  8103b7:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  8103be:	00 
  8103bf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8103c2:	89 04 24             	mov    %eax,(%esp)
  8103c5:	e8 6a fb ff ff       	call   80ff34 <sys_env_set_status>
  8103ca:	89 c2                	mov    %eax,%edx
		panic("sys_env_set_status: %e", ret);
  8103cc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	//copy page fault handler
	ret = sys_env_set_pgfault_upcall(envid,thisenv->env_pgfault_upcall);
	if(ret < 0) return ret;
	
	// Start the child environment running
	if ((ret = sys_env_set_status(envid, ENV_RUNNABLE)) < 0)
  8103cf:	85 d2                	test   %edx,%edx
  8103d1:	79 20                	jns    8103f3 <fork+0x25d>
		panic("sys_env_set_status: %e", ret);
  8103d3:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8103d7:	c7 44 24 08 fa 38 81 	movl   $0x8138fa,0x8(%esp)
  8103de:	00 
  8103df:	c7 44 24 04 a8 00 00 	movl   $0xa8,0x4(%esp)
  8103e6:	00 
  8103e7:	c7 04 24 c8 38 81 00 	movl   $0x8138c8,(%esp)
  8103ee:	e8 f9 ed ff ff       	call   80f1ec <_panic>

	return envid;
}
  8103f3:	83 c4 4c             	add    $0x4c,%esp
  8103f6:	5b                   	pop    %ebx
  8103f7:	5e                   	pop    %esi
  8103f8:	5f                   	pop    %edi
  8103f9:	5d                   	pop    %ebp
  8103fa:	c3                   	ret    
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}

	// We're the parent.
	for(i=0;i<PDX(UTOP);i++)
  8103fb:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
  8103ff:	e9 0a fe ff ff       	jmp    81020e <fork+0x78>

00810404 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  810404:	55                   	push   %ebp
  810405:	89 e5                	mov    %esp,%ebp
  810407:	56                   	push   %esi
  810408:	53                   	push   %ebx
  810409:	83 ec 20             	sub    $0x20,%esp
	void *addr;
	uint32_t err = utf->utf_err;
	int ret;
	envid_t envid = sys_getenvid();
  81040c:	e8 d0 fc ff ff       	call   8100e1 <sys_getenvid>
  810411:	89 c3                	mov    %eax,%ebx
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).
	// LAB 4: Your code here.

	uint32_t vp = utf->utf_fault_va >> PGSHIFT;
  810413:	8b 45 08             	mov    0x8(%ebp),%eax
  810416:	8b 00                	mov    (%eax),%eax
  810418:	89 c6                	mov    %eax,%esi
  81041a:	c1 ee 0c             	shr    $0xc,%esi
	addr = (void *) (vp << PGSHIFT);
	
	if(!(uvpt[vp] & PTE_W) && !(uvpt[vp] & PTE_COW))
  81041d:	8b 14 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%edx
  810424:	f6 c2 02             	test   $0x2,%dl
  810427:	75 2c                	jne    810455 <pgfault+0x51>
  810429:	8b 14 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%edx
  810430:	f6 c6 08             	test   $0x8,%dh
  810433:	75 20                	jne    810455 <pgfault+0x51>
		panic("page %x is not set cow or write\n",utf->utf_fault_va);
  810435:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810439:	c7 44 24 08 48 39 81 	movl   $0x813948,0x8(%esp)
  810440:	00 
  810441:	c7 44 24 04 21 00 00 	movl   $0x21,0x4(%esp)
  810448:	00 
  810449:	c7 04 24 c8 38 81 00 	movl   $0x8138c8,(%esp)
  810450:	e8 97 ed ff ff       	call   80f1ec <_panic>
	// page to the old page's address.
	// Hint:
	//   You should make three system calls.
	// LAB 4: Your code here.
	
	if ((ret = sys_page_alloc(envid, UTEMP, PTE_P|PTE_U|PTE_W)) < 0)
  810455:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  81045c:	00 
  81045d:	c7 44 24 04 00 00 40 	movl   $0x400000,0x4(%esp)
  810464:	00 
  810465:	89 1c 24             	mov    %ebx,(%esp)
  810468:	e8 e1 fb ff ff       	call   81004e <sys_page_alloc>
  81046d:	85 c0                	test   %eax,%eax
  81046f:	79 20                	jns    810491 <pgfault+0x8d>
		panic("pgfault alloc: %e", ret);
  810471:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810475:	c7 44 24 08 11 39 81 	movl   $0x813911,0x8(%esp)
  81047c:	00 
  81047d:	c7 44 24 04 2b 00 00 	movl   $0x2b,0x4(%esp)
  810484:	00 
  810485:	c7 04 24 c8 38 81 00 	movl   $0x8138c8,(%esp)
  81048c:	e8 5b ed ff ff       	call   80f1ec <_panic>
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).
	// LAB 4: Your code here.

	uint32_t vp = utf->utf_fault_va >> PGSHIFT;
	addr = (void *) (vp << PGSHIFT);
  810491:	c1 e6 0c             	shl    $0xc,%esi
	// LAB 4: Your code here.
	
	if ((ret = sys_page_alloc(envid, UTEMP, PTE_P|PTE_U|PTE_W)) < 0)
		panic("pgfault alloc: %e", ret);

	memmove((void *)UTEMP, addr, PGSIZE);
  810494:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  81049b:	00 
  81049c:	89 74 24 04          	mov    %esi,0x4(%esp)
  8104a0:	c7 04 24 00 00 40 00 	movl   $0x400000,(%esp)
  8104a7:	e8 03 f6 ff ff       	call   80faaf <memmove>
	if ((ret = sys_page_map(envid, UTEMP, envid, addr, PTE_P|PTE_U|PTE_W)) < 0)
  8104ac:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  8104b3:	00 
  8104b4:	89 74 24 0c          	mov    %esi,0xc(%esp)
  8104b8:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8104bc:	c7 44 24 04 00 00 40 	movl   $0x400000,0x4(%esp)
  8104c3:	00 
  8104c4:	89 1c 24             	mov    %ebx,(%esp)
  8104c7:	e8 24 fb ff ff       	call   80fff0 <sys_page_map>
  8104cc:	85 c0                	test   %eax,%eax
  8104ce:	79 20                	jns    8104f0 <pgfault+0xec>
		panic("pgfault map: %e", ret);	
  8104d0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8104d4:	c7 44 24 08 23 39 81 	movl   $0x813923,0x8(%esp)
  8104db:	00 
  8104dc:	c7 44 24 04 2f 00 00 	movl   $0x2f,0x4(%esp)
  8104e3:	00 
  8104e4:	c7 04 24 c8 38 81 00 	movl   $0x8138c8,(%esp)
  8104eb:	e8 fc ec ff ff       	call   80f1ec <_panic>

	ret = sys_page_unmap(envid,(void *)UTEMP);
  8104f0:	c7 44 24 04 00 00 40 	movl   $0x400000,0x4(%esp)
  8104f7:	00 
  8104f8:	89 1c 24             	mov    %ebx,(%esp)
  8104fb:	e8 92 fa ff ff       	call   80ff92 <sys_page_unmap>
	if(ret) panic("pgfault unmap: %e", ret);
  810500:	85 c0                	test   %eax,%eax
  810502:	74 20                	je     810524 <pgfault+0x120>
  810504:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810508:	c7 44 24 08 33 39 81 	movl   $0x813933,0x8(%esp)
  81050f:	00 
  810510:	c7 44 24 04 32 00 00 	movl   $0x32,0x4(%esp)
  810517:	00 
  810518:	c7 04 24 c8 38 81 00 	movl   $0x8138c8,(%esp)
  81051f:	e8 c8 ec ff ff       	call   80f1ec <_panic>

}
  810524:	83 c4 20             	add    $0x20,%esp
  810527:	5b                   	pop    %ebx
  810528:	5e                   	pop    %esi
  810529:	5d                   	pop    %ebp
  81052a:	c3                   	ret    
	...

0081052c <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  81052c:	55                   	push   %ebp
  81052d:	89 e5                	mov    %esp,%ebp
  81052f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810532:	b8 00 00 00 00       	mov    $0x0,%eax
	int i;
	for (i = 0; i < NENV; i++)
		if (envs[i].env_type == type)
  810537:	6b d0 7c             	imul   $0x7c,%eax,%edx
  81053a:	81 c2 50 00 c0 ee    	add    $0xeec00050,%edx
  810540:	8b 12                	mov    (%edx),%edx
  810542:	39 ca                	cmp    %ecx,%edx
  810544:	75 0c                	jne    810552 <ipc_find_env+0x26>
			return envs[i].env_id;
  810546:	6b c0 7c             	imul   $0x7c,%eax,%eax
  810549:	05 48 00 c0 ee       	add    $0xeec00048,%eax
  81054e:	8b 00                	mov    (%eax),%eax
  810550:	eb 0e                	jmp    810560 <ipc_find_env+0x34>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  810552:	83 c0 01             	add    $0x1,%eax
  810555:	3d 00 04 00 00       	cmp    $0x400,%eax
  81055a:	75 db                	jne    810537 <ipc_find_env+0xb>
  81055c:	66 b8 00 00          	mov    $0x0,%ax
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
}
  810560:	5d                   	pop    %ebp
  810561:	c3                   	ret    

00810562 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  810562:	55                   	push   %ebp
  810563:	89 e5                	mov    %esp,%ebp
  810565:	57                   	push   %edi
  810566:	56                   	push   %esi
  810567:	53                   	push   %ebx
  810568:	83 ec 2c             	sub    $0x2c,%esp
  81056b:	8b 75 08             	mov    0x8(%ebp),%esi
  81056e:	8b 7d 0c             	mov    0xc(%ebp),%edi
  810571:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.

	int ret;	
	if(!pg) pg = (void *)UTOP;
  810574:	85 db                	test   %ebx,%ebx
  810576:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  81057b:	0f 44 d8             	cmove  %eax,%ebx
	do
	{ret = sys_ipc_try_send(to_env,val,pg,perm);}
  81057e:	8b 45 14             	mov    0x14(%ebp),%eax
  810581:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810585:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810589:	89 7c 24 04          	mov    %edi,0x4(%esp)
  81058d:	89 34 24             	mov    %esi,(%esp)
  810590:	e8 ab f8 ff ff       	call   80fe40 <sys_ipc_try_send>
	while(ret == -E_IPC_NOT_RECV);
  810595:	83 f8 f9             	cmp    $0xfffffff9,%eax
  810598:	74 e4                	je     81057e <ipc_send+0x1c>

	if(ret)	panic("ipc_send fails %d\n",__func__,ret);
  81059a:	85 c0                	test   %eax,%eax
  81059c:	74 28                	je     8105c6 <ipc_send+0x64>
  81059e:	89 44 24 10          	mov    %eax,0x10(%esp)
  8105a2:	c7 44 24 0c 86 39 81 	movl   $0x813986,0xc(%esp)
  8105a9:	00 
  8105aa:	c7 44 24 08 69 39 81 	movl   $0x813969,0x8(%esp)
  8105b1:	00 
  8105b2:	c7 44 24 04 3a 00 00 	movl   $0x3a,0x4(%esp)
  8105b9:	00 
  8105ba:	c7 04 24 7c 39 81 00 	movl   $0x81397c,(%esp)
  8105c1:	e8 26 ec ff ff       	call   80f1ec <_panic>
	//if(!ret) sys_yield();
}
  8105c6:	83 c4 2c             	add    $0x2c,%esp
  8105c9:	5b                   	pop    %ebx
  8105ca:	5e                   	pop    %esi
  8105cb:	5f                   	pop    %edi
  8105cc:	5d                   	pop    %ebp
  8105cd:	c3                   	ret    

008105ce <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  8105ce:	55                   	push   %ebp
  8105cf:	89 e5                	mov    %esp,%ebp
  8105d1:	83 ec 28             	sub    $0x28,%esp
  8105d4:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8105d7:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8105da:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8105dd:	8b 75 08             	mov    0x8(%ebp),%esi
  8105e0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8105e3:	8b 7d 10             	mov    0x10(%ebp),%edi
	// LAB 4: Your code here.
	int32_t ret;
	envid_t curr_id;

	if(!pg) pg = (void *)UTOP;
  8105e6:	85 c0                	test   %eax,%eax
  8105e8:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  8105ed:	0f 44 c2             	cmove  %edx,%eax
	ret = sys_ipc_recv(pg);
  8105f0:	89 04 24             	mov    %eax,(%esp)
  8105f3:	e8 eb f7 ff ff       	call   80fde3 <sys_ipc_recv>
  8105f8:	89 c3                	mov    %eax,%ebx
	thisenv = &envs[ENVX(sys_getenvid())];	
  8105fa:	e8 e2 fa ff ff       	call   8100e1 <sys_getenvid>
  8105ff:	25 ff 03 00 00       	and    $0x3ff,%eax
  810604:	6b c0 7c             	imul   $0x7c,%eax,%eax
  810607:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  81060c:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
	//cprintf("thisenv->env_ipc_perm = %d ret = %d\n",thisenv->env_ipc_perm,ret);
	
	if(from_env_store) *from_env_store = ret ? 0 : thisenv->env_ipc_from;
  810611:	85 f6                	test   %esi,%esi
  810613:	74 0e                	je     810623 <ipc_recv+0x55>
  810615:	ba 00 00 00 00       	mov    $0x0,%edx
  81061a:	85 db                	test   %ebx,%ebx
  81061c:	75 03                	jne    810621 <ipc_recv+0x53>
  81061e:	8b 50 74             	mov    0x74(%eax),%edx
  810621:	89 16                	mov    %edx,(%esi)
	if(perm_store) *perm_store = ret ? 0 : thisenv->env_ipc_perm;
  810623:	85 ff                	test   %edi,%edi
  810625:	74 13                	je     81063a <ipc_recv+0x6c>
  810627:	b8 00 00 00 00       	mov    $0x0,%eax
  81062c:	85 db                	test   %ebx,%ebx
  81062e:	75 08                	jne    810638 <ipc_recv+0x6a>
  810630:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810635:	8b 40 78             	mov    0x78(%eax),%eax
  810638:	89 07                	mov    %eax,(%edi)
	return ret ? ret : thisenv->env_ipc_value;
  81063a:	85 db                	test   %ebx,%ebx
  81063c:	75 08                	jne    810646 <ipc_recv+0x78>
  81063e:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810643:	8b 58 70             	mov    0x70(%eax),%ebx
}
  810646:	89 d8                	mov    %ebx,%eax
  810648:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  81064b:	8b 75 f8             	mov    -0x8(%ebp),%esi
  81064e:	8b 7d fc             	mov    -0x4(%ebp),%edi
  810651:	89 ec                	mov    %ebp,%esp
  810653:	5d                   	pop    %ebp
  810654:	c3                   	ret    
  810655:	00 00                	add    %al,(%eax)
	...

00810658 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  810658:	55                   	push   %ebp
  810659:	89 e5                	mov    %esp,%ebp
  81065b:	53                   	push   %ebx
  81065c:	83 ec 14             	sub    $0x14,%esp
  81065f:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  810661:	83 3d d0 b1 b3 00 00 	cmpl   $0x0,0xb3b1d0
  810668:	75 11                	jne    81067b <nsipc+0x23>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  81066a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  810671:	e8 b6 fe ff ff       	call   81052c <ipc_find_env>
  810676:	a3 d0 b1 b3 00       	mov    %eax,0xb3b1d0
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  81067b:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  810682:	00 
  810683:	c7 44 24 08 00 d0 b3 	movl   $0xb3d000,0x8(%esp)
  81068a:	00 
  81068b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81068f:	a1 d0 b1 b3 00       	mov    0xb3b1d0,%eax
  810694:	89 04 24             	mov    %eax,(%esp)
  810697:	e8 c6 fe ff ff       	call   810562 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  81069c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8106a3:	00 
  8106a4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8106ab:	00 
  8106ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8106b3:	e8 16 ff ff ff       	call   8105ce <ipc_recv>
}
  8106b8:	83 c4 14             	add    $0x14,%esp
  8106bb:	5b                   	pop    %ebx
  8106bc:	5d                   	pop    %ebp
  8106bd:	c3                   	ret    

008106be <nsipc_socket>:
	return nsipc(NSREQ_SEND);
}

int
nsipc_socket(int domain, int type, int protocol)
{
  8106be:	55                   	push   %ebp
  8106bf:	89 e5                	mov    %esp,%ebp
  8106c1:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  8106c4:	8b 45 08             	mov    0x8(%ebp),%eax
  8106c7:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.socket.req_type = type;
  8106cc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8106cf:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	nsipcbuf.socket.req_protocol = protocol;
  8106d4:	8b 45 10             	mov    0x10(%ebp),%eax
  8106d7:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SOCKET);
  8106dc:	b8 09 00 00 00       	mov    $0x9,%eax
  8106e1:	e8 72 ff ff ff       	call   810658 <nsipc>
}
  8106e6:	c9                   	leave  
  8106e7:	c3                   	ret    

008106e8 <nsipc_listen>:
	return nsipc(NSREQ_CONNECT);
}

int
nsipc_listen(int s, int backlog)
{
  8106e8:	55                   	push   %ebp
  8106e9:	89 e5                	mov    %esp,%ebp
  8106eb:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  8106ee:	8b 45 08             	mov    0x8(%ebp),%eax
  8106f1:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.listen.req_backlog = backlog;
  8106f6:	8b 45 0c             	mov    0xc(%ebp),%eax
  8106f9:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_LISTEN);
  8106fe:	b8 06 00 00 00       	mov    $0x6,%eax
  810703:	e8 50 ff ff ff       	call   810658 <nsipc>
}
  810708:	c9                   	leave  
  810709:	c3                   	ret    

0081070a <nsipc_close>:
	return nsipc(NSREQ_SHUTDOWN);
}

int
nsipc_close(int s)
{
  81070a:	55                   	push   %ebp
  81070b:	89 e5                	mov    %esp,%ebp
  81070d:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  810710:	8b 45 08             	mov    0x8(%ebp),%eax
  810713:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return nsipc(NSREQ_CLOSE);
  810718:	b8 04 00 00 00       	mov    $0x4,%eax
  81071d:	e8 36 ff ff ff       	call   810658 <nsipc>
}
  810722:	c9                   	leave  
  810723:	c3                   	ret    

00810724 <nsipc_shutdown>:
	return nsipc(NSREQ_BIND);
}

int
nsipc_shutdown(int s, int how)
{
  810724:	55                   	push   %ebp
  810725:	89 e5                	mov    %esp,%ebp
  810727:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  81072a:	8b 45 08             	mov    0x8(%ebp),%eax
  81072d:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.shutdown.req_how = how;
  810732:	8b 45 0c             	mov    0xc(%ebp),%eax
  810735:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_SHUTDOWN);
  81073a:	b8 03 00 00 00       	mov    $0x3,%eax
  81073f:	e8 14 ff ff ff       	call   810658 <nsipc>
}
  810744:	c9                   	leave  
  810745:	c3                   	ret    

00810746 <nsipc_send>:
	return r;
}

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  810746:	55                   	push   %ebp
  810747:	89 e5                	mov    %esp,%ebp
  810749:	53                   	push   %ebx
  81074a:	83 ec 14             	sub    $0x14,%esp
  81074d:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  810750:	8b 45 08             	mov    0x8(%ebp),%eax
  810753:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	assert(size < 1600);
  810758:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  81075e:	7e 24                	jle    810784 <nsipc_send+0x3e>
  810760:	c7 44 24 0c 8f 39 81 	movl   $0x81398f,0xc(%esp)
  810767:	00 
  810768:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  81076f:	00 
  810770:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  810777:	00 
  810778:	c7 04 24 9b 39 81 00 	movl   $0x81399b,(%esp)
  81077f:	e8 68 ea ff ff       	call   80f1ec <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  810784:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810788:	8b 45 0c             	mov    0xc(%ebp),%eax
  81078b:	89 44 24 04          	mov    %eax,0x4(%esp)
  81078f:	c7 04 24 0c d0 b3 00 	movl   $0xb3d00c,(%esp)
  810796:	e8 14 f3 ff ff       	call   80faaf <memmove>
	nsipcbuf.send.req_size = size;
  81079b:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	nsipcbuf.send.req_flags = flags;
  8107a1:	8b 45 14             	mov    0x14(%ebp),%eax
  8107a4:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SEND);
  8107a9:	b8 08 00 00 00       	mov    $0x8,%eax
  8107ae:	e8 a5 fe ff ff       	call   810658 <nsipc>
}
  8107b3:	83 c4 14             	add    $0x14,%esp
  8107b6:	5b                   	pop    %ebx
  8107b7:	5d                   	pop    %ebp
  8107b8:	c3                   	ret    

008107b9 <nsipc_recv>:
	return nsipc(NSREQ_LISTEN);
}

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  8107b9:	55                   	push   %ebp
  8107ba:	89 e5                	mov    %esp,%ebp
  8107bc:	56                   	push   %esi
  8107bd:	53                   	push   %ebx
  8107be:	83 ec 10             	sub    $0x10,%esp
  8107c1:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  8107c4:	8b 45 08             	mov    0x8(%ebp),%eax
  8107c7:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.recv.req_len = len;
  8107cc:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	nsipcbuf.recv.req_flags = flags;
  8107d2:	8b 45 14             	mov    0x14(%ebp),%eax
  8107d5:	a3 08 d0 b3 00       	mov    %eax,0xb3d008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  8107da:	b8 07 00 00 00       	mov    $0x7,%eax
  8107df:	e8 74 fe ff ff       	call   810658 <nsipc>
  8107e4:	89 c3                	mov    %eax,%ebx
  8107e6:	85 c0                	test   %eax,%eax
  8107e8:	78 46                	js     810830 <nsipc_recv+0x77>
		assert(r < 1600 && r <= len);
  8107ea:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  8107ef:	7f 04                	jg     8107f5 <nsipc_recv+0x3c>
  8107f1:	39 c6                	cmp    %eax,%esi
  8107f3:	7d 24                	jge    810819 <nsipc_recv+0x60>
  8107f5:	c7 44 24 0c a7 39 81 	movl   $0x8139a7,0xc(%esp)
  8107fc:	00 
  8107fd:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  810804:	00 
  810805:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  81080c:	00 
  81080d:	c7 04 24 9b 39 81 00 	movl   $0x81399b,(%esp)
  810814:	e8 d3 e9 ff ff       	call   80f1ec <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810819:	89 44 24 08          	mov    %eax,0x8(%esp)
  81081d:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  810824:	00 
  810825:	8b 45 0c             	mov    0xc(%ebp),%eax
  810828:	89 04 24             	mov    %eax,(%esp)
  81082b:	e8 7f f2 ff ff       	call   80faaf <memmove>
	}

	return r;
}
  810830:	89 d8                	mov    %ebx,%eax
  810832:	83 c4 10             	add    $0x10,%esp
  810835:	5b                   	pop    %ebx
  810836:	5e                   	pop    %esi
  810837:	5d                   	pop    %ebp
  810838:	c3                   	ret    

00810839 <nsipc_connect>:
	return nsipc(NSREQ_CLOSE);
}

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  810839:	55                   	push   %ebp
  81083a:	89 e5                	mov    %esp,%ebp
  81083c:	53                   	push   %ebx
  81083d:	83 ec 14             	sub    $0x14,%esp
  810840:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  810843:	8b 45 08             	mov    0x8(%ebp),%eax
  810846:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  81084b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  81084f:	8b 45 0c             	mov    0xc(%ebp),%eax
  810852:	89 44 24 04          	mov    %eax,0x4(%esp)
  810856:	c7 04 24 04 d0 b3 00 	movl   $0xb3d004,(%esp)
  81085d:	e8 4d f2 ff ff       	call   80faaf <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  810862:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_CONNECT);
  810868:	b8 05 00 00 00       	mov    $0x5,%eax
  81086d:	e8 e6 fd ff ff       	call   810658 <nsipc>
}
  810872:	83 c4 14             	add    $0x14,%esp
  810875:	5b                   	pop    %ebx
  810876:	5d                   	pop    %ebp
  810877:	c3                   	ret    

00810878 <nsipc_bind>:
	return r;
}

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  810878:	55                   	push   %ebp
  810879:	89 e5                	mov    %esp,%ebp
  81087b:	53                   	push   %ebx
  81087c:	83 ec 14             	sub    $0x14,%esp
  81087f:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  810882:	8b 45 08             	mov    0x8(%ebp),%eax
  810885:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  81088a:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  81088e:	8b 45 0c             	mov    0xc(%ebp),%eax
  810891:	89 44 24 04          	mov    %eax,0x4(%esp)
  810895:	c7 04 24 04 d0 b3 00 	movl   $0xb3d004,(%esp)
  81089c:	e8 0e f2 ff ff       	call   80faaf <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  8108a1:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_BIND);
  8108a7:	b8 02 00 00 00       	mov    $0x2,%eax
  8108ac:	e8 a7 fd ff ff       	call   810658 <nsipc>
}
  8108b1:	83 c4 14             	add    $0x14,%esp
  8108b4:	5b                   	pop    %ebx
  8108b5:	5d                   	pop    %ebp
  8108b6:	c3                   	ret    

008108b7 <nsipc_accept>:
	return ipc_recv(NULL, NULL, NULL);
}

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8108b7:	55                   	push   %ebp
  8108b8:	89 e5                	mov    %esp,%ebp
  8108ba:	83 ec 28             	sub    $0x28,%esp
  8108bd:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8108c0:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8108c3:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8108c6:	8b 7d 10             	mov    0x10(%ebp),%edi
	int r;

	nsipcbuf.accept.req_s = s;
  8108c9:	8b 45 08             	mov    0x8(%ebp),%eax
  8108cc:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.accept.req_addrlen = *addrlen;
  8108d1:	8b 07                	mov    (%edi),%eax
  8108d3:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  8108d8:	b8 01 00 00 00       	mov    $0x1,%eax
  8108dd:	e8 76 fd ff ff       	call   810658 <nsipc>
  8108e2:	89 c6                	mov    %eax,%esi
  8108e4:	85 c0                	test   %eax,%eax
  8108e6:	78 22                	js     81090a <nsipc_accept+0x53>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  8108e8:	bb 10 d0 b3 00       	mov    $0xb3d010,%ebx
  8108ed:	8b 03                	mov    (%ebx),%eax
  8108ef:	89 44 24 08          	mov    %eax,0x8(%esp)
  8108f3:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  8108fa:	00 
  8108fb:	8b 45 0c             	mov    0xc(%ebp),%eax
  8108fe:	89 04 24             	mov    %eax,(%esp)
  810901:	e8 a9 f1 ff ff       	call   80faaf <memmove>
		*addrlen = ret->ret_addrlen;
  810906:	8b 03                	mov    (%ebx),%eax
  810908:	89 07                	mov    %eax,(%edi)
	}
	return r;
}
  81090a:	89 f0                	mov    %esi,%eax
  81090c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  81090f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  810912:	8b 7d fc             	mov    -0x4(%ebp),%edi
  810915:	89 ec                	mov    %ebp,%esp
  810917:	5d                   	pop    %ebp
  810918:	c3                   	ret    
  810919:	00 00                	add    %al,(%eax)
	...

0081091c <free>:
	return v;
}

void
free(void *v)
{
  81091c:	55                   	push   %ebp
  81091d:	89 e5                	mov    %esp,%ebp
  81091f:	56                   	push   %esi
  810920:	53                   	push   %ebx
  810921:	83 ec 10             	sub    $0x10,%esp
  810924:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  810927:	85 db                	test   %ebx,%ebx
  810929:	0f 84 b9 00 00 00    	je     8109e8 <free+0xcc>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  81092f:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  810935:	76 08                	jbe    81093f <free+0x23>
  810937:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  81093d:	76 24                	jbe    810963 <free+0x47>
  81093f:	c7 44 24 0c bc 39 81 	movl   $0x8139bc,0xc(%esp)
  810946:	00 
  810947:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  81094e:	00 
  81094f:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  810956:	00 
  810957:	c7 04 24 ec 39 81 00 	movl   $0x8139ec,(%esp)
  81095e:	e8 89 e8 ff ff       	call   80f1ec <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  810963:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  810969:	be 00 00 40 ef       	mov    $0xef400000,%esi
  81096e:	eb 4a                	jmp    8109ba <free+0x9e>
		sys_page_unmap(0, c);
  810970:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810974:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81097b:	e8 12 f6 ff ff       	call   80ff92 <sys_page_unmap>
		c += PGSIZE;
  810980:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  810986:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  81098c:	76 08                	jbe    810996 <free+0x7a>
  81098e:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  810994:	76 24                	jbe    8109ba <free+0x9e>
  810996:	c7 44 24 0c f9 39 81 	movl   $0x8139f9,0xc(%esp)
  81099d:	00 
  81099e:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  8109a5:	00 
  8109a6:	c7 44 24 04 81 00 00 	movl   $0x81,0x4(%esp)
  8109ad:	00 
  8109ae:	c7 04 24 ec 39 81 00 	movl   $0x8139ec,(%esp)
  8109b5:	e8 32 e8 ff ff       	call   80f1ec <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8109ba:	89 d8                	mov    %ebx,%eax
  8109bc:	c1 e8 0c             	shr    $0xc,%eax
  8109bf:	8b 04 86             	mov    (%esi,%eax,4),%eax
  8109c2:	f6 c4 02             	test   $0x2,%ah
  8109c5:	75 a9                	jne    810970 <free+0x54>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  8109c7:	8d 93 fc 0f 00 00    	lea    0xffc(%ebx),%edx
	if (--(*ref) == 0)
  8109cd:	8b 02                	mov    (%edx),%eax
  8109cf:	83 e8 01             	sub    $0x1,%eax
  8109d2:	89 02                	mov    %eax,(%edx)
  8109d4:	85 c0                	test   %eax,%eax
  8109d6:	75 10                	jne    8109e8 <free+0xcc>
		sys_page_unmap(0, c);
  8109d8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8109dc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8109e3:	e8 aa f5 ff ff       	call   80ff92 <sys_page_unmap>
}
  8109e8:	83 c4 10             	add    $0x10,%esp
  8109eb:	5b                   	pop    %ebx
  8109ec:	5e                   	pop    %esi
  8109ed:	5d                   	pop    %ebp
  8109ee:	c3                   	ret    

008109ef <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  8109ef:	55                   	push   %ebp
  8109f0:	89 e5                	mov    %esp,%ebp
  8109f2:	57                   	push   %edi
  8109f3:	56                   	push   %esi
  8109f4:	53                   	push   %ebx
  8109f5:	83 ec 3c             	sub    $0x3c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  8109f8:	83 3d d4 b1 b3 00 00 	cmpl   $0x0,0xb3b1d4
  8109ff:	75 0a                	jne    810a0b <malloc+0x1c>
		mptr = mbegin;
  810a01:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  810a08:	00 00 08 

	n = ROUNDUP(n, 4);
  810a0b:	8b 45 08             	mov    0x8(%ebp),%eax
  810a0e:	83 c0 03             	add    $0x3,%eax
  810a11:	83 e0 fc             	and    $0xfffffffc,%eax
  810a14:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if (n >= MAXMALLOC)
  810a17:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  810a1c:	0f 87 7e 01 00 00    	ja     810ba0 <malloc+0x1b1>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  810a22:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  810a27:	89 c2                	mov    %eax,%edx
  810a29:	a9 ff 0f 00 00       	test   $0xfff,%eax
  810a2e:	74 4d                	je     810a7d <malloc+0x8e>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  810a30:	89 c3                	mov    %eax,%ebx
  810a32:	c1 eb 0c             	shr    $0xc,%ebx
  810a35:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  810a38:	8d 4c 30 03          	lea    0x3(%eax,%esi,1),%ecx
  810a3c:	c1 e9 0c             	shr    $0xc,%ecx
  810a3f:	39 cb                	cmp    %ecx,%ebx
  810a41:	75 1e                	jne    810a61 <malloc+0x72>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  810a43:	81 c2 ff 0f 00 00    	add    $0xfff,%edx
  810a49:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  810a4f:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  810a53:	8d 14 30             	lea    (%eax,%esi,1),%edx
  810a56:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
			return v;
  810a5c:	e9 44 01 00 00       	jmp    810ba5 <malloc+0x1b6>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  810a61:	89 04 24             	mov    %eax,(%esp)
  810a64:	e8 b3 fe ff ff       	call   81091c <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  810a69:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  810a6e:	05 00 10 00 00       	add    $0x1000,%eax
  810a73:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  810a78:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
  810a7d:	8b 3d d4 b1 b3 00    	mov    0xb3b1d4,%edi
  810a83:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			return 0;
	return 1;
}

void*
malloc(size_t n)
  810a8a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  810a8d:	83 c0 04             	add    $0x4,%eax
  810a90:	89 45 d8             	mov    %eax,-0x28(%ebp)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  810a93:	bb 00 d0 7b ef       	mov    $0xef7bd000,%ebx
  810a98:	be 00 00 40 ef       	mov    $0xef400000,%esi
			return 0;
	return 1;
}

void*
malloc(size_t n)
  810a9d:	8b 45 d8             	mov    -0x28(%ebp),%eax
  810aa0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  810aa3:	89 c1                	mov    %eax,%ecx
  810aa5:	01 f9                	add    %edi,%ecx
  810aa7:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  810aaa:	89 f8                	mov    %edi,%eax
  810aac:	eb 26                	jmp    810ad4 <malloc+0xe5>
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  810aae:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  810ab3:	77 28                	ja     810add <malloc+0xee>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  810ab5:	89 c2                	mov    %eax,%edx
  810ab7:	c1 ea 16             	shr    $0x16,%edx
  810aba:	8b 14 93             	mov    (%ebx,%edx,4),%edx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  810abd:	f6 c2 01             	test   $0x1,%dl
  810ac0:	74 0d                	je     810acf <malloc+0xe0>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  810ac2:	89 c2                	mov    %eax,%edx
  810ac4:	c1 ea 0c             	shr    $0xc,%edx
  810ac7:	8b 14 96             	mov    (%esi,%edx,4),%edx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  810aca:	f6 c2 01             	test   $0x1,%dl
  810acd:	75 0e                	jne    810add <malloc+0xee>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810acf:	05 00 10 00 00       	add    $0x1000,%eax
  810ad4:	39 c1                	cmp    %eax,%ecx
  810ad6:	77 d6                	ja     810aae <malloc+0xbf>
  810ad8:	e9 91 00 00 00       	jmp    810b6e <malloc+0x17f>
  810add:	81 c7 00 10 00 00    	add    $0x1000,%edi
  810ae3:	81 c1 00 10 00 00    	add    $0x1000,%ecx
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  810ae9:	81 ff 00 00 00 10    	cmp    $0x10000000,%edi
  810aef:	75 b6                	jne    810aa7 <malloc+0xb8>
			mptr = mbegin;
			if (++nwrap == 2)
  810af1:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
  810af5:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
  810af9:	74 07                	je     810b02 <malloc+0x113>
  810afb:	bf 00 00 00 08       	mov    $0x8000000,%edi
  810b00:	eb 9b                	jmp    810a9d <malloc+0xae>
  810b02:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  810b09:	00 00 08 
  810b0c:	b8 00 00 00 00       	mov    $0x0,%eax
  810b11:	e9 8f 00 00 00       	jmp    810ba5 <malloc+0x1b6>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  810b16:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  810b1c:	39 fe                	cmp    %edi,%esi
  810b1e:	19 c0                	sbb    %eax,%eax
  810b20:	25 00 02 00 00       	and    $0x200,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810b25:	83 c8 07             	or     $0x7,%eax
  810b28:	89 44 24 08          	mov    %eax,0x8(%esp)
  810b2c:	03 15 d4 b1 b3 00    	add    0xb3b1d4,%edx
  810b32:	89 54 24 04          	mov    %edx,0x4(%esp)
  810b36:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810b3d:	e8 0c f5 ff ff       	call   81004e <sys_page_alloc>
  810b42:	85 c0                	test   %eax,%eax
  810b44:	78 22                	js     810b68 <malloc+0x179>
  810b46:	89 f3                	mov    %esi,%ebx
  810b48:	eb 35                	jmp    810b7f <malloc+0x190>
			for (; i >= 0; i -= PGSIZE)
				sys_page_unmap(0, mptr + i);
  810b4a:	89 d8                	mov    %ebx,%eax
  810b4c:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810b52:	89 44 24 04          	mov    %eax,0x4(%esp)
  810b56:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810b5d:	e8 30 f4 ff ff       	call   80ff92 <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  810b62:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  810b68:	85 db                	test   %ebx,%ebx
  810b6a:	79 de                	jns    810b4a <malloc+0x15b>
  810b6c:	eb 32                	jmp    810ba0 <malloc+0x1b1>
  810b6e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  810b71:	89 35 d4 b1 b3 00    	mov    %esi,0xb3b1d4
  810b77:	bb 00 00 00 00       	mov    $0x0,%ebx
  810b7c:	8b 7d e0             	mov    -0x20(%ebp),%edi
  810b7f:	89 da                	mov    %ebx,%edx
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  810b81:	39 df                	cmp    %ebx,%edi
  810b83:	77 91                	ja     810b16 <malloc+0x127>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  810b85:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  810b8a:	c7 44 18 fc 02 00 00 	movl   $0x2,-0x4(%eax,%ebx,1)
  810b91:	00 
	v = mptr;
	mptr += n;
  810b92:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  810b95:	8d 14 10             	lea    (%eax,%edx,1),%edx
  810b98:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
	return v;
  810b9e:	eb 05                	jmp    810ba5 <malloc+0x1b6>
  810ba0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810ba5:	83 c4 3c             	add    $0x3c,%esp
  810ba8:	5b                   	pop    %ebx
  810ba9:	5e                   	pop    %esi
  810baa:	5f                   	pop    %edi
  810bab:	5d                   	pop    %ebp
  810bac:	c3                   	ret    
  810bad:	00 00                	add    %al,(%eax)
	...

00810bb0 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  810bb0:	55                   	push   %ebp
  810bb1:	89 e5                	mov    %esp,%ebp
  810bb3:	53                   	push   %ebx
  810bb4:	83 ec 24             	sub    $0x24,%esp
	int ret;

	if (_pgfault_handler == 0) {
  810bb7:	83 3d 00 e0 b3 00 00 	cmpl   $0x0,0xb3e000
  810bbe:	75 5b                	jne    810c1b <set_pgfault_handler+0x6b>
		// First time through!
		// LAB 4: Your code here.
		envid_t envid = sys_getenvid();
  810bc0:	e8 1c f5 ff ff       	call   8100e1 <sys_getenvid>
  810bc5:	89 c3                	mov    %eax,%ebx
		ret = sys_page_alloc(envid, (void*) (UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W);
  810bc7:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  810bce:	00 
  810bcf:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  810bd6:	ee 
  810bd7:	89 04 24             	mov    %eax,(%esp)
  810bda:	e8 6f f4 ff ff       	call   81004e <sys_page_alloc>
		if(ret) panic("%s sys_page_alloc err %e",__func__,ret);
  810bdf:	85 c0                	test   %eax,%eax
  810be1:	74 28                	je     810c0b <set_pgfault_handler+0x5b>
  810be3:	89 44 24 10          	mov    %eax,0x10(%esp)
  810be7:	c7 44 24 0c 38 3a 81 	movl   $0x813a38,0xc(%esp)
  810bee:	00 
  810bef:	c7 44 24 08 11 3a 81 	movl   $0x813a11,0x8(%esp)
  810bf6:	00 
  810bf7:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  810bfe:	00 
  810bff:	c7 04 24 2a 3a 81 00 	movl   $0x813a2a,(%esp)
  810c06:	e8 e1 e5 ff ff       	call   80f1ec <_panic>
		
		sys_env_set_pgfault_upcall(envid,_pgfault_upcall);
  810c0b:	c7 44 24 04 2c 0c 81 	movl   $0x810c2c,0x4(%esp)
  810c12:	00 
  810c13:	89 1c 24             	mov    %ebx,(%esp)
  810c16:	e8 5d f2 ff ff       	call   80fe78 <sys_env_set_pgfault_upcall>
		if(ret) panic("%s sys_env_set_pgfault_upcall err %e",__func__,ret);
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  810c1b:	8b 45 08             	mov    0x8(%ebp),%eax
  810c1e:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	
}
  810c23:	83 c4 24             	add    $0x24,%esp
  810c26:	5b                   	pop    %ebx
  810c27:	5d                   	pop    %ebp
  810c28:	c3                   	ret    
  810c29:	00 00                	add    %al,(%eax)
	...

00810c2c <_pgfault_upcall>:
  810c2c:	54                   	push   %esp
  810c2d:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
  810c32:	ff d0                	call   *%eax
  810c34:	83 c4 04             	add    $0x4,%esp
  810c37:	83 c4 08             	add    $0x8,%esp
  810c3a:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  810c3e:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  810c42:	89 59 fc             	mov    %ebx,-0x4(%ecx)
  810c45:	83 e9 04             	sub    $0x4,%ecx
  810c48:	89 4c 24 28          	mov    %ecx,0x28(%esp)
  810c4c:	61                   	popa   
  810c4d:	83 c4 04             	add    $0x4,%esp
  810c50:	9d                   	popf   
  810c51:	5c                   	pop    %esp
  810c52:	c3                   	ret    
	...

00810c60 <__udivdi3>:
  810c60:	55                   	push   %ebp
  810c61:	89 e5                	mov    %esp,%ebp
  810c63:	57                   	push   %edi
  810c64:	56                   	push   %esi
  810c65:	83 ec 10             	sub    $0x10,%esp
  810c68:	8b 45 14             	mov    0x14(%ebp),%eax
  810c6b:	8b 55 08             	mov    0x8(%ebp),%edx
  810c6e:	8b 75 10             	mov    0x10(%ebp),%esi
  810c71:	8b 7d 0c             	mov    0xc(%ebp),%edi
  810c74:	85 c0                	test   %eax,%eax
  810c76:	89 55 f0             	mov    %edx,-0x10(%ebp)
  810c79:	75 35                	jne    810cb0 <__udivdi3+0x50>
  810c7b:	39 fe                	cmp    %edi,%esi
  810c7d:	77 61                	ja     810ce0 <__udivdi3+0x80>
  810c7f:	85 f6                	test   %esi,%esi
  810c81:	75 0b                	jne    810c8e <__udivdi3+0x2e>
  810c83:	b8 01 00 00 00       	mov    $0x1,%eax
  810c88:	31 d2                	xor    %edx,%edx
  810c8a:	f7 f6                	div    %esi
  810c8c:	89 c6                	mov    %eax,%esi
  810c8e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  810c91:	31 d2                	xor    %edx,%edx
  810c93:	89 f8                	mov    %edi,%eax
  810c95:	f7 f6                	div    %esi
  810c97:	89 c7                	mov    %eax,%edi
  810c99:	89 c8                	mov    %ecx,%eax
  810c9b:	f7 f6                	div    %esi
  810c9d:	89 c1                	mov    %eax,%ecx
  810c9f:	89 fa                	mov    %edi,%edx
  810ca1:	89 c8                	mov    %ecx,%eax
  810ca3:	83 c4 10             	add    $0x10,%esp
  810ca6:	5e                   	pop    %esi
  810ca7:	5f                   	pop    %edi
  810ca8:	5d                   	pop    %ebp
  810ca9:	c3                   	ret    
  810caa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810cb0:	39 f8                	cmp    %edi,%eax
  810cb2:	77 1c                	ja     810cd0 <__udivdi3+0x70>
  810cb4:	0f bd d0             	bsr    %eax,%edx
  810cb7:	83 f2 1f             	xor    $0x1f,%edx
  810cba:	89 55 f4             	mov    %edx,-0xc(%ebp)
  810cbd:	75 39                	jne    810cf8 <__udivdi3+0x98>
  810cbf:	3b 75 f0             	cmp    -0x10(%ebp),%esi
  810cc2:	0f 86 a0 00 00 00    	jbe    810d68 <__udivdi3+0x108>
  810cc8:	39 f8                	cmp    %edi,%eax
  810cca:	0f 82 98 00 00 00    	jb     810d68 <__udivdi3+0x108>
  810cd0:	31 ff                	xor    %edi,%edi
  810cd2:	31 c9                	xor    %ecx,%ecx
  810cd4:	89 c8                	mov    %ecx,%eax
  810cd6:	89 fa                	mov    %edi,%edx
  810cd8:	83 c4 10             	add    $0x10,%esp
  810cdb:	5e                   	pop    %esi
  810cdc:	5f                   	pop    %edi
  810cdd:	5d                   	pop    %ebp
  810cde:	c3                   	ret    
  810cdf:	90                   	nop
  810ce0:	89 d1                	mov    %edx,%ecx
  810ce2:	89 fa                	mov    %edi,%edx
  810ce4:	89 c8                	mov    %ecx,%eax
  810ce6:	31 ff                	xor    %edi,%edi
  810ce8:	f7 f6                	div    %esi
  810cea:	89 c1                	mov    %eax,%ecx
  810cec:	89 fa                	mov    %edi,%edx
  810cee:	89 c8                	mov    %ecx,%eax
  810cf0:	83 c4 10             	add    $0x10,%esp
  810cf3:	5e                   	pop    %esi
  810cf4:	5f                   	pop    %edi
  810cf5:	5d                   	pop    %ebp
  810cf6:	c3                   	ret    
  810cf7:	90                   	nop
  810cf8:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  810cfc:	89 f2                	mov    %esi,%edx
  810cfe:	d3 e0                	shl    %cl,%eax
  810d00:	89 45 ec             	mov    %eax,-0x14(%ebp)
  810d03:	b8 20 00 00 00       	mov    $0x20,%eax
  810d08:	2b 45 f4             	sub    -0xc(%ebp),%eax
  810d0b:	89 c1                	mov    %eax,%ecx
  810d0d:	d3 ea                	shr    %cl,%edx
  810d0f:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  810d13:	0b 55 ec             	or     -0x14(%ebp),%edx
  810d16:	d3 e6                	shl    %cl,%esi
  810d18:	89 c1                	mov    %eax,%ecx
  810d1a:	89 75 e8             	mov    %esi,-0x18(%ebp)
  810d1d:	89 fe                	mov    %edi,%esi
  810d1f:	d3 ee                	shr    %cl,%esi
  810d21:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  810d25:	89 55 ec             	mov    %edx,-0x14(%ebp)
  810d28:	8b 55 f0             	mov    -0x10(%ebp),%edx
  810d2b:	d3 e7                	shl    %cl,%edi
  810d2d:	89 c1                	mov    %eax,%ecx
  810d2f:	d3 ea                	shr    %cl,%edx
  810d31:	09 d7                	or     %edx,%edi
  810d33:	89 f2                	mov    %esi,%edx
  810d35:	89 f8                	mov    %edi,%eax
  810d37:	f7 75 ec             	divl   -0x14(%ebp)
  810d3a:	89 d6                	mov    %edx,%esi
  810d3c:	89 c7                	mov    %eax,%edi
  810d3e:	f7 65 e8             	mull   -0x18(%ebp)
  810d41:	39 d6                	cmp    %edx,%esi
  810d43:	89 55 ec             	mov    %edx,-0x14(%ebp)
  810d46:	72 30                	jb     810d78 <__udivdi3+0x118>
  810d48:	8b 55 f0             	mov    -0x10(%ebp),%edx
  810d4b:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  810d4f:	d3 e2                	shl    %cl,%edx
  810d51:	39 c2                	cmp    %eax,%edx
  810d53:	73 05                	jae    810d5a <__udivdi3+0xfa>
  810d55:	3b 75 ec             	cmp    -0x14(%ebp),%esi
  810d58:	74 1e                	je     810d78 <__udivdi3+0x118>
  810d5a:	89 f9                	mov    %edi,%ecx
  810d5c:	31 ff                	xor    %edi,%edi
  810d5e:	e9 71 ff ff ff       	jmp    810cd4 <__udivdi3+0x74>
  810d63:	90                   	nop
  810d64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810d68:	31 ff                	xor    %edi,%edi
  810d6a:	b9 01 00 00 00       	mov    $0x1,%ecx
  810d6f:	e9 60 ff ff ff       	jmp    810cd4 <__udivdi3+0x74>
  810d74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810d78:	8d 4f ff             	lea    -0x1(%edi),%ecx
  810d7b:	31 ff                	xor    %edi,%edi
  810d7d:	89 c8                	mov    %ecx,%eax
  810d7f:	89 fa                	mov    %edi,%edx
  810d81:	83 c4 10             	add    $0x10,%esp
  810d84:	5e                   	pop    %esi
  810d85:	5f                   	pop    %edi
  810d86:	5d                   	pop    %ebp
  810d87:	c3                   	ret    
	...

00810d90 <__umoddi3>:
  810d90:	55                   	push   %ebp
  810d91:	89 e5                	mov    %esp,%ebp
  810d93:	57                   	push   %edi
  810d94:	56                   	push   %esi
  810d95:	83 ec 20             	sub    $0x20,%esp
  810d98:	8b 55 14             	mov    0x14(%ebp),%edx
  810d9b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810d9e:	8b 7d 10             	mov    0x10(%ebp),%edi
  810da1:	8b 75 0c             	mov    0xc(%ebp),%esi
  810da4:	85 d2                	test   %edx,%edx
  810da6:	89 c8                	mov    %ecx,%eax
  810da8:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  810dab:	75 13                	jne    810dc0 <__umoddi3+0x30>
  810dad:	39 f7                	cmp    %esi,%edi
  810daf:	76 3f                	jbe    810df0 <__umoddi3+0x60>
  810db1:	89 f2                	mov    %esi,%edx
  810db3:	f7 f7                	div    %edi
  810db5:	89 d0                	mov    %edx,%eax
  810db7:	31 d2                	xor    %edx,%edx
  810db9:	83 c4 20             	add    $0x20,%esp
  810dbc:	5e                   	pop    %esi
  810dbd:	5f                   	pop    %edi
  810dbe:	5d                   	pop    %ebp
  810dbf:	c3                   	ret    
  810dc0:	39 f2                	cmp    %esi,%edx
  810dc2:	77 4c                	ja     810e10 <__umoddi3+0x80>
  810dc4:	0f bd ca             	bsr    %edx,%ecx
  810dc7:	83 f1 1f             	xor    $0x1f,%ecx
  810dca:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  810dcd:	75 51                	jne    810e20 <__umoddi3+0x90>
  810dcf:	3b 7d f4             	cmp    -0xc(%ebp),%edi
  810dd2:	0f 87 e0 00 00 00    	ja     810eb8 <__umoddi3+0x128>
  810dd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810ddb:	29 f8                	sub    %edi,%eax
  810ddd:	19 d6                	sbb    %edx,%esi
  810ddf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  810de2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810de5:	89 f2                	mov    %esi,%edx
  810de7:	83 c4 20             	add    $0x20,%esp
  810dea:	5e                   	pop    %esi
  810deb:	5f                   	pop    %edi
  810dec:	5d                   	pop    %ebp
  810ded:	c3                   	ret    
  810dee:	66 90                	xchg   %ax,%ax
  810df0:	85 ff                	test   %edi,%edi
  810df2:	75 0b                	jne    810dff <__umoddi3+0x6f>
  810df4:	b8 01 00 00 00       	mov    $0x1,%eax
  810df9:	31 d2                	xor    %edx,%edx
  810dfb:	f7 f7                	div    %edi
  810dfd:	89 c7                	mov    %eax,%edi
  810dff:	89 f0                	mov    %esi,%eax
  810e01:	31 d2                	xor    %edx,%edx
  810e03:	f7 f7                	div    %edi
  810e05:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e08:	f7 f7                	div    %edi
  810e0a:	eb a9                	jmp    810db5 <__umoddi3+0x25>
  810e0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810e10:	89 c8                	mov    %ecx,%eax
  810e12:	89 f2                	mov    %esi,%edx
  810e14:	83 c4 20             	add    $0x20,%esp
  810e17:	5e                   	pop    %esi
  810e18:	5f                   	pop    %edi
  810e19:	5d                   	pop    %ebp
  810e1a:	c3                   	ret    
  810e1b:	90                   	nop
  810e1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810e20:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  810e24:	d3 e2                	shl    %cl,%edx
  810e26:	89 55 f4             	mov    %edx,-0xc(%ebp)
  810e29:	ba 20 00 00 00       	mov    $0x20,%edx
  810e2e:	2b 55 f0             	sub    -0x10(%ebp),%edx
  810e31:	89 55 ec             	mov    %edx,-0x14(%ebp)
  810e34:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  810e38:	89 fa                	mov    %edi,%edx
  810e3a:	d3 ea                	shr    %cl,%edx
  810e3c:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  810e40:	0b 55 f4             	or     -0xc(%ebp),%edx
  810e43:	d3 e7                	shl    %cl,%edi
  810e45:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  810e49:	89 55 f4             	mov    %edx,-0xc(%ebp)
  810e4c:	89 f2                	mov    %esi,%edx
  810e4e:	89 7d e8             	mov    %edi,-0x18(%ebp)
  810e51:	89 c7                	mov    %eax,%edi
  810e53:	d3 ea                	shr    %cl,%edx
  810e55:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  810e59:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  810e5c:	89 c2                	mov    %eax,%edx
  810e5e:	d3 e6                	shl    %cl,%esi
  810e60:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  810e64:	d3 ea                	shr    %cl,%edx
  810e66:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  810e6a:	09 d6                	or     %edx,%esi
  810e6c:	89 f0                	mov    %esi,%eax
  810e6e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  810e71:	d3 e7                	shl    %cl,%edi
  810e73:	89 f2                	mov    %esi,%edx
  810e75:	f7 75 f4             	divl   -0xc(%ebp)
  810e78:	89 d6                	mov    %edx,%esi
  810e7a:	f7 65 e8             	mull   -0x18(%ebp)
  810e7d:	39 d6                	cmp    %edx,%esi
  810e7f:	72 2b                	jb     810eac <__umoddi3+0x11c>
  810e81:	39 c7                	cmp    %eax,%edi
  810e83:	72 23                	jb     810ea8 <__umoddi3+0x118>
  810e85:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  810e89:	29 c7                	sub    %eax,%edi
  810e8b:	19 d6                	sbb    %edx,%esi
  810e8d:	89 f0                	mov    %esi,%eax
  810e8f:	89 f2                	mov    %esi,%edx
  810e91:	d3 ef                	shr    %cl,%edi
  810e93:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  810e97:	d3 e0                	shl    %cl,%eax
  810e99:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  810e9d:	09 f8                	or     %edi,%eax
  810e9f:	d3 ea                	shr    %cl,%edx
  810ea1:	83 c4 20             	add    $0x20,%esp
  810ea4:	5e                   	pop    %esi
  810ea5:	5f                   	pop    %edi
  810ea6:	5d                   	pop    %ebp
  810ea7:	c3                   	ret    
  810ea8:	39 d6                	cmp    %edx,%esi
  810eaa:	75 d9                	jne    810e85 <__umoddi3+0xf5>
  810eac:	2b 45 e8             	sub    -0x18(%ebp),%eax
  810eaf:	1b 55 f4             	sbb    -0xc(%ebp),%edx
  810eb2:	eb d1                	jmp    810e85 <__umoddi3+0xf5>
  810eb4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810eb8:	39 f2                	cmp    %esi,%edx
  810eba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810ec0:	0f 82 12 ff ff ff    	jb     810dd8 <__umoddi3+0x48>
  810ec6:	e9 17 ff ff ff       	jmp    810de2 <__umoddi3+0x52>
